{"version":3,"file":"index.js","sources":["../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/globals.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/each.js","../node_modules/svelte/src/runtime/internal/spread.js","../node_modules/svelte/src/runtime/internal/Component.js","../src/lib/utils/debug.ts","../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../node_modules/svelte/src/shared/version.js","../src/lib/utils/uniqueId.ts","../src/lib/utils/numberUtils.ts","../src/lib/utils/typeUtils.ts","../src/lib/utils/arrayUtils.ts","../src/lib/utils/jsonUtils.ts","../src/lib/types.ts","../src/lib/utils/domUtils.ts","../src/lib/utils/navigatorUtils.ts","../src/lib/utils/keyBindings.ts","../src/lib/components/modals/popup/AbsolutePopupEntry.svelte","../src/lib/components/modals/popup/AbsolutePopup.svelte","../src/lib/utils/stringUtils.ts","../src/lib/plugins/query/jsonQueryLanguage.ts","../node_modules/svelte-awesome/package/components/svg/Raw.svelte","../node_modules/svelte-awesome/package/components/svg/Svg.svelte","../node_modules/svelte-awesome/package/components/Icon.svelte","../src/lib/plugins/value/components/BooleanToggle.svelte","../src/lib/components/controls/ColorPickerPopup.svelte","../src/lib/plugins/value/components/ColorPicker.svelte","../src/lib/constants.ts","../src/lib/logic/expandItemsSections.ts","../src/lib/typeguards.ts","../src/lib/logic/documentState.ts","../src/lib/logic/selection.ts","../src/lib/utils/cssUtils.ts","../src/lib/plugins/value/components/utils/getValueClass.ts","../src/lib/components/controls/EditableDiv.svelte","../src/lib/plugins/value/components/EditableValue.svelte","../src/lib/logic/operations.ts","../src/lib/logic/search.ts","../src/lib/components/modes/treemode/highlight/SearchResultHighlighter.svelte","../src/lib/plugins/value/components/ReadonlyValue.svelte","../src/lib/components/controls/tooltip/Tooltip.svelte","../src/lib/components/controls/tooltip/tooltip.ts","../src/lib/plugins/value/components/TimestampTag.svelte","../src/lib/plugins/value/renderValue.ts","../src/lib/utils/pathUtils.ts","../src/lib/components/modals/transformModalStates.ts","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/svelte-select/filter.js","../node_modules/svelte-select/get-items.js","../node_modules/svelte-select/ChevronIcon.svelte","../node_modules/svelte-select/ClearIcon.svelte","../node_modules/svelte-select/LoadingIcon.svelte","../node_modules/svelte-select/Select.svelte","../node_modules/svelte-floating-ui/index.js","../src/lib/components/modals/TransformWizard.svelte","../src/lib/components/controls/selectQueryLanguage/SelectQueryLanguage.svelte","../src/lib/components/modals/Header.svelte","../src/lib/components/modals/TransformModalHeader.svelte","../src/lib/components/controls/createAutoScrollHandler.ts","../src/lib/assets/jump.js/src/easing.ts","../src/lib/assets/jump.js/src/jump.ts","../src/lib/logic/history.ts","../src/lib/utils/timeUtils.ts","../src/lib/logic/validation.ts","../src/lib/components/controls/createFocusTracker.ts","../src/lib/components/controls/Message.svelte","../src/lib/components/controls/ValidationErrorsOverview.svelte","../src/lib/actions/onEscape.ts","../src/lib/components/modals/Modal.svelte","../src/lib/components/modals/CopyPasteModal.svelte","../src/lib/components/controls/Menu.svelte","../src/lib/components/modals/repair/JSONRepairComponent.svelte","../src/lib/components/modals/JSONRepairModal.svelte","../src/lib/components/modes/treemode/CollapsedItems.svelte","../src/lib/components/controls/contextmenu/ContextMenuPointer.svelte","../src/lib/components/modes/treemode/JSONKey.svelte","../src/lib/components/modes/treemode/JSONValue.svelte","../src/lib/components/modes/treemode/singleton.ts","../src/lib/logic/dragging.ts","../src/lib/components/modes/treemode/ValidationErrorIcon.svelte","../src/lib/components/modes/treemode/JSONNode.svelte","../src/lib/img/customFontawesomeIcons.ts","../src/lib/components/modes/treemode/menu/TreeMenu.svelte","../src/lib/components/modes/treemode/Welcome.svelte","../src/lib/logic/sort.ts","../src/lib/components/controls/navigationBar/NavigationBarDropdown.svelte","../src/lib/components/controls/navigationBar/NavigationBarItem.svelte","../src/lib/utils/copyToClipboard.ts","../src/lib/components/controls/navigationBar/NavigationBarPathEditor.svelte","../src/lib/components/controls/navigationBar/NavigationBar.svelte","../src/lib/components/controls/SearchBox.svelte","../src/lib/logic/table.ts","../src/lib/logic/actions.ts","../src/lib/components/controls/JSONPreview.svelte","../src/lib/components/controls/contextmenu/ContextMenuButton.svelte","../src/lib/components/controls/DropdownButton.svelte","../src/lib/components/controls/contextmenu/ContextMenuDropDownButton.svelte","../src/lib/components/controls/contextmenu/ContextMenu.svelte","../src/lib/components/modes/treemode/TreeMode.svelte","../src/lib/components/modes/treemode/contextmenu/createTreeContextMenuItems.ts","../src/lib/utils/readonlyProxy.ts","../src/lib/components/modals/TransformModal.svelte","../src/lib/utils/noop.ts","../src/lib/utils/fileUtils.ts","../src/lib/components/modes/textmode/menu/TextMenu.svelte","../src/lib/components/modes/textmode/StatusBar.svelte","../src/lib/components/modes/textmode/codemirror/codemirror-theme.ts","../src/lib/actions/resizeObserver.ts","../src/lib/components/modes/textmode/TextMode.svelte","../src/lib/components/modes/tablemode/menu/TableMenu.svelte","../src/lib/components/modes/tablemode/tag/InlineValue.svelte","../src/lib/components/modes/tablemode/ColumnHeader.svelte","../src/lib/components/modes/tablemode/TableModeWelcome.svelte","../src/lib/components/modes/tablemode/RefreshColumnHeader.svelte","../src/lib/components/modes/tablemode/TableMode.svelte","../src/lib/components/modes/tablemode/contextmenu/createTableContextMenuItems.ts","../src/lib/components/modes/JSONEditorRoot.svelte","../src/lib/components/modals/JSONEditorModal.svelte","../src/lib/components/modals/sortModalStates.ts","../src/lib/components/modals/SortModal.svelte","../src/lib/components/JSONEditor.svelte","../src/lib/plugins/value/components/EnumValue.svelte","../src/lib/utils/jsonSchemaUtils.ts","../src/lib/plugins/value/renderJSONSchemaEnum.ts","../src/lib/plugins/validator/createAjvValidator.ts","../src/lib/plugins/query/jmespathQueryLanguage.ts","../src/lib/plugins/query/jsonpathQueryLanguage.ts","../src/lib/plugins/query/lodashQueryLanguage.ts","../src/lib/plugins/query/javascriptQueryLanguage.ts","../src/lib/index-vanilla.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","/** @type {typeof globalThis} */\nexport const globals =\n\ttypeof window !== 'undefined'\n\t\t? window\n\t\t: typeof globalThis !== 'undefined'\n\t\t? globalThis\n\t\t: // @ts-ignore Node typings have this\n\t\t  global;\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro — restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro — we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro — needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","/**\n * Create a lightweight debug function to log output into the browser console.\n *\n * Inspired by https://github.com/visionmedia/debug (some code is copied below)\n *\n * Usage:\n *\n *     import { createDebug } from './debug.js'\n *\n *     const debug = createDebug('my:namespace')\n *\n *     debug('testing:', 2 + 2)\n *\n * By default, logging is only enabled when a property DEBUG is set in the\n * localStorage of your browser:\n *\n *     localStorage['debug'] = '*'\n *     localStorage['debug'] = 'jsoneditor:*'\n *     localStorage['debug'] = 'jsoneditor:TreeMode'\n *\n * The actual value of 'debug' is used to filter the debug messages.\n * The value can end with a '*' wild card to match any remaining text.\n *\n * By providing a value for `enabled`, you can choose conditions to\n * enable/disable debugging if you want, for example some flag determining\n * whether in development or production.\n */\nexport function createDebug(\n  namespace: string,\n  enabled = enableDebug(namespace)\n): (...args: unknown[]) => void {\n  if (!enabled) {\n    return noop\n  }\n\n  const color = selectColor(namespace)\n\n  return function debug(...args) {\n    console.log(`%c${namespace}`, `color:${color}`, ...args)\n  }\n}\n\nfunction enableDebug(namespace: string) {\n  const debug = tryReadLocalStorage('debug')\n\n  return debug?.endsWith('*') ? namespace.startsWith(debug.slice(0, -1)) : namespace === debug\n}\n\nfunction noop() {\n  // no operation\n}\n\n/**\n * Try read a specific key from localStorage\n */\nfunction tryReadLocalStorage(key: string): string | undefined {\n  try {\n    if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {\n      // reading local storage can fail for example because of security restrictions\n      return window.localStorage[key]\n    }\n  } catch {\n    // we do nothing with the error, not needed in this specific case\n  }\n\n  return undefined\n}\n\n/**\n * Selects a color for a debug namespace\n *\n * Code is copied from the following source: https://github.com/visionmedia/debug\n *\n * @param namespace The namespace string for the debug instance to be colored\n * @return An ANSI color code for the given namespace\n */\nfunction selectColor(namespace: string): string {\n  let hash = 0\n\n  for (let i = 0; i < namespace.length; i++) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i)\n    hash |= 0 // Convert to 32bit integer\n  }\n\n  return colors[Math.abs(hash) % colors.length]\n}\n\nconst colors = [\n  '#0000CC',\n  '#0099FF',\n  '#009400',\n  '#8dd200',\n  '#CCCC00',\n  '#CC9933',\n  '#ae04e7',\n  '#ff35d7',\n  '#FF3333',\n  '#FF6600',\n  '#FF9933',\n  '#FFCC33'\n]\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.19';\nexport const PUBLIC_VERSION = '4';\n","let id = 0\n\nexport function uniqueId(): number {\n  id++\n  return id\n}\n","export function int(value: string): number {\n  return parseInt(value, 10)\n}\n\nexport function isDigit(char: string): boolean {\n  return DIGIT_REGEX.test(char)\n}\n\nconst DIGIT_REGEX = /^[0-9]$/\n\n// TODO: unit test\nexport function containsNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n","// TODO: unit test typeUtils.js\n\nimport { containsNumber } from './numberUtils.js'\nimport type { JSONParser } from '../types.js'\n\n/**\n * Test whether a value is an Object (and not an Array or Class)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  // note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined || value.constructor.name === 'Object')\n  )\n}\n\n/**\n * Test whether a value is an Object or an Array (and not a Class)\n */\nexport function isObjectOrArray(value: unknown): value is object | Array<unknown> {\n  // Note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined ||\n      value.constructor.name === 'Object' ||\n      value.constructor.name === 'Array')\n  )\n}\n\n/**\n * Test whether a value is a boolean\n *\n * @param {*} value\n * @return {boolean}\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return value === true || value === false\n}\n\n/**\n * Test whether a value is a timestamp in milliseconds after the year 2000.\n */\nexport function isTimestamp(value: unknown): boolean {\n  const YEAR_2000 = 946684800000\n\n  if (typeof value === 'number') {\n    return (\n      value > YEAR_2000 &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      !isNaN(new Date(value).valueOf())\n    )\n  }\n\n  if (typeof value === 'bigint') {\n    return isTimestamp(Number(value))\n  }\n\n  // try getting the primitive value if that is different. For example when having a LosslessNumber\n  try {\n    const valueOf = value ? value.valueOf() : value\n    if (valueOf !== value) {\n      return isTimestamp(valueOf)\n    }\n  } catch {\n    return false\n  }\n\n  return false\n}\n\n/**\n * Get the applied color given a color name or code\n * Returns the color if the input is a valid color, and returns null otherwise.\n *\n * Example output:\n *\n *     'rgba(255,0,0,0.7)' or 'rgb(255,0,0)'\n *\n * Source: https://stackoverflow.com/questions/6386090/validating-css-color-names/33184805\n */\nexport function getColorCSS(color: string): string | undefined {\n  colorTestDiv = colorTestDiv || window.document.createElement('div')\n\n  colorTestDiv.style.color = ''\n  colorTestDiv.style.color = color\n\n  const applied = colorTestDiv.style.color\n  return applied !== '' ? applied.replace(/\\s+/g, '').toLowerCase() : undefined\n}\nlet colorTestDiv: HTMLDivElement | undefined = undefined\n\n/**\n * Test if a string contains a valid color name or code.\n * Returns true if a valid color, false otherwise\n */\nexport function isColor(value: unknown): boolean {\n  const maxColorLength = 99\n  return typeof value === 'string' && value.length < maxColorLength && !!getColorCSS(value)\n}\n\n/**\n * Get the type of the value\n */\nexport function valueType(value: unknown, parser: JSONParser): string {\n  // primitive types\n  if (\n    typeof value === 'number' ||\n    typeof value === 'string' ||\n    typeof value === 'boolean' ||\n    typeof value === 'undefined'\n  ) {\n    return typeof value\n  }\n  if (typeof value === 'bigint') {\n    return 'number' // we return number here, not bigint: all numeric types should return the same name\n  }\n  if (value === null) {\n    return 'null'\n  }\n\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  if (isObject(value)) {\n    // plain object only\n    return 'object'\n  }\n\n  // unknown type (like a LosslessNumber). Try out what stringfying results in\n  const valueStr = parser.stringify(value)\n  if (valueStr && containsNumber(valueStr)) {\n    return 'number'\n  }\n  if (valueStr === 'true' || valueStr === 'false') {\n    return 'boolean'\n  }\n  if (valueStr === 'null') {\n    return 'null'\n  }\n\n  return 'unknown'\n}\n\n/**\n * Test whether a text contains a url (matches when a string starts\n * with 'http://*' or 'https://*' and has no whitespace characters)\n */\nconst isUrlRegex = /^https?:\\/\\/\\S+$/\nexport function isUrl(text: unknown): boolean {\n  return typeof text === 'string' && isUrlRegex.test(text)\n}\n\n/**\n * Convert contents of a string to the correct JSON type. This can be a string,\n * a number, a boolean, etc\n */\nexport function stringConvert(str: string, parser: JSONParser): unknown {\n  if (str === '') {\n    return ''\n  }\n\n  const strTrim = str.trim()\n\n  if (strTrim === 'null') {\n    return null\n  }\n\n  if (strTrim === 'true') {\n    return true\n  }\n\n  if (strTrim === 'false') {\n    return false\n  }\n\n  if (containsNumber(strTrim)) {\n    return parser.parse(strTrim)\n  }\n\n  return str\n}\n\n/**\n * Test whether a string contains a numeric, boolean, or null value.\n * Returns true when the string contains a number, boolean, or null.\n */\nexport function isStringContainingPrimitiveValue(str: unknown): boolean {\n  // note that we can safely use JSON parser here instead of the configured JSONParser,\n  // since we do not actually use the parsed number, just want to check that it is not a string\n  return typeof str === 'string' && typeof stringConvert(str, JSON) !== 'string'\n}\n\n/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n","import { isObject } from './typeUtils.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { isEqual } from 'lodash-es'\n\nconst MAX_ITEM_PATHS_COLLECTION = 10000\nconst ROOT_PATH: JSONPath = []\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareAsc)    // [2,4,5]\n */\nexport function compareAsc<T>(a: T, b: T): number {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareDesc)   // [5,4,2]\n */\nexport function compareDesc<T>(a: T, b: T): number {\n  return a > b ? -1 : a < b ? 1 : 0\n}\n\n/**\n * Test whether all items of an array are strictly equal\n */\nexport function strictShallowEqual<T>(a: Array<T>, b: Array<T>): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function compareArrays<T>(a: Array<T>, b: Array<T>): number {\n  const minLength = Math.min(a.length, b.length)\n\n  for (let i = 0; i < minLength; i++) {\n    if (a[i] < b[i]) {\n      return -1\n    }\n\n    if (a[i] > b[i]) {\n      return 1\n    }\n  }\n\n  return a.length - b.length\n}\n\n/**\n * Get the paths of all nested properties in the items of an array\n * @param array\n * @param includeObjects If true, object and array paths are returned as well\n */\nexport function getNestedPaths(array: unknown, includeObjects = false): JSONPath[] {\n  const pointersMap: Record<string, boolean> = {}\n\n  if (!Array.isArray(array)) {\n    throw new TypeError('Array expected')\n  }\n\n  function recurseNestedPaths(obj: unknown, path: JSONPath) {\n    const isValue = !Array.isArray(obj) && !isObject(obj)\n\n    if (isValue || (includeObjects && path.length > 0)) {\n      pointersMap[compileJSONPointer(path)] = true\n    }\n\n    if (isObject(obj)) {\n      Object.keys(obj).forEach((key) => {\n        recurseNestedPaths(obj[key], path.concat(key))\n      })\n    }\n  }\n\n  const max = Math.min(array.length, MAX_ITEM_PATHS_COLLECTION)\n  for (let i = 0; i < max; i++) {\n    const item = array[i]\n    recurseNestedPaths(item, ROOT_PATH)\n  }\n\n  const pathsArray = Object.keys(pointersMap).sort()\n\n  return pathsArray.map(parseJSONPointer)\n}\n\n/**\n * Invoke the callback with\n * @param start   Included start index\n * @param end       Excluded end index. End must be larger or equal to start\n * @param iteratee\n */\n// TODO: write tests\nexport function forEachIndex(start: number, end: number, iteratee: (index: number) => void) {\n  if (end <= start) {\n    return\n  }\n\n  for (let index = start; index < end; index++) {\n    iteratee(index)\n  }\n}\n\n/**\n * Limit the number of items in an array\n */\n// TODO: write unit test\nexport function limit<T>(array: Array<T>, max: number): Array<T> {\n  return array.length > max ? array.slice(0, max) : array\n}\n\n/**\n * Convert an array into an object having the array indices as keys\n */\nexport function arrayToObject<T>(array: Array<T>): Record<number, T> {\n  return {\n    ...array\n  }\n}\n\n/**\n * Get the values of an object as an array\n */\nexport function objectToArray<T>(object: Record<string, T>): Array<T> {\n  return Object.values(object)\n}\n\n/**\n * Test whether an array starts with a sub array\n */\nexport function arrayStartsWith<T>(\n  array: T[],\n  searchArray: T[],\n  equal: (a: T, b: T) => boolean = isEqual\n): boolean {\n  for (let i = 0; i < searchArray.length; i++) {\n    if (!equal(array[i], searchArray[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Move a set of items inside an array\n */\nexport function moveItems<T>(array: T[], index: number, count: number, offset: number): T[] {\n  // TODO: check boundaries: index+offset >= 0, index+offset+count<array.length, index+count<array.length, etc\n  const copy = array.slice(0)\n  const moving: T[] = copy.splice(index, count)\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  copy.splice.apply(copy, [index + offset, 0, ...moving])\n  return copy\n}\n\n/**\n * Take samples out of a large array, equally spread from start till end\n */\nexport function forEachSample<T>(\n  array: T[],\n  maxSampleCount: number,\n  callback: (item: T, index: number, array: T[]) => void\n) {\n  if (array.length < maxSampleCount) {\n    array.forEach(callback)\n  } else {\n    const step = maxSampleCount > 1 ? (array.length - 1) / (maxSampleCount - 1) : array.length\n    for (let i = 0; i < maxSampleCount; i++) {\n      const index = Math.floor(i * step)\n      callback(array[index], index, array)\n    }\n  }\n}\n\nexport function insertItemsAt<T>(array: T[], index: number, items: T[]): T[] {\n  return array.slice(0, index).concat(items).concat(array.slice(index))\n}\n","import type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer } from 'immutable-json-patch'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport jsonSourceMap from 'json-source-map'\nimport { jsonrepair } from 'jsonrepair'\nimport { isObject, isObjectOrArray, valueType } from './typeUtils.js'\nimport { arrayToObject, objectToArray } from './arrayUtils.js'\nimport type {\n  Content,\n  JSONContent,\n  JSONParser,\n  ParseError,\n  TextContent,\n  TextLocation\n} from '../types'\nimport { int } from './numberUtils.js'\n\n/**\n * Parse the JSON. if this fails, try to repair and parse.\n * Throws an exception when the JSON is invalid and could not be parsed.\n */\nexport function parseAndRepair(jsonText: string, parser: JSONParser): unknown {\n  try {\n    return parser.parse(jsonText)\n  } catch {\n    // this can also throw\n    return parser.parse(jsonrepair(jsonText))\n  }\n}\n\n/**\n * Parse the JSON and if needed repair it.\n * When not valid, undefined is returned.\n */\nexport function parseAndRepairOrUndefined(\n  partialJson: string,\n  parser: JSONParser\n): unknown | undefined {\n  try {\n    return parseAndRepair(partialJson, parser)\n  } catch {\n    return undefined\n  }\n}\n\n// TODO: deduplicate the logic in repairPartialJson and parseAndRepairPartialJson ?\nexport function parsePartialJson(partialJson: string, parse: (text: string) => unknown): unknown {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return parse(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('{' + partialJson + '}')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('[' + partialJson + ']')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to parse partial JSON')\n}\n\n/**\n * Repair partial JSON\n */\nexport function repairPartialJson(partialJson: string): string {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return jsonrepair(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('[' + partialJson + ']')\n    return repaired.substring(1, repaired.length - 1) // remove the outer [...] again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('{' + partialJson + '}')\n    return repaired.substring(1, repaired.length - 1) // remove the outer {...} again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to repair partial JSON')\n}\n\n// test whether a string ends with a comma, followed by zero or more white space characters\nconst END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX = /,\\s*$/\n\n/**\n * Normalize a parse error message like\n *     \"Unexpected token i in JSON at position 4\"\n * or\n *     \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n * and return the line and column numbers in an object\n *\n * Note that the returned line and column number in the object are zero-based,\n * and in the message are one based (human-readable)\n */\nexport function normalizeJsonParseError(jsonText: string, parseErrorMessage: string): ParseError {\n  const positionMatch = POSITION_REGEX.exec(parseErrorMessage)\n\n  if (positionMatch) {\n    // a message from Chrome, like \"Unexpected token i in JSON at line 2 column 3\"\n    const position = int(positionMatch[2])\n\n    const line = countCharacterOccurrences(jsonText, '\\n', 0, position)\n    const lastIndex = jsonText.lastIndexOf('\\n', position)\n    const column = position - lastIndex - 1\n\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(POSITION_REGEX, () => {\n        return `line ${line + 1} column ${column + 1}`\n      })\n    }\n  } else {\n    // a message from Firefox, like \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n    const lineMatch = LINE_REGEX.exec(parseErrorMessage)\n    const lineOneBased = lineMatch ? int(lineMatch[1]) : undefined\n    const line = lineOneBased !== undefined ? lineOneBased - 1 : undefined\n\n    const columnMatch = COLUMN_REGEX.exec(parseErrorMessage)\n    const columnOneBased = columnMatch ? int(columnMatch[1]) : undefined\n    const column = columnOneBased !== undefined ? columnOneBased - 1 : undefined\n\n    const position =\n      line !== undefined && column !== undefined\n        ? calculatePosition(jsonText, line, column)\n        : undefined\n\n    // line and column are one based in the message\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(/^JSON.parse: /, '').replace(/ of the JSON data$/, '')\n    }\n  }\n}\n\n/**\n * Calculate the position in the text based on a line and column number\n * @param text\n * @param line     Zero-based line number\n * @param column   Zero-based column number\n */\nexport function calculatePosition(text: string, line: number, column: number): number | undefined {\n  let index = text.indexOf('\\n')\n  let i = 1\n\n  while (i < line && index !== -1) {\n    index = text.indexOf('\\n', index + 1)\n    i++\n  }\n\n  return index !== -1\n    ? index + column + 1 // +1 for the return character itself\n    : undefined\n}\n\nexport function countCharacterOccurrences(\n  text: string,\n  character: string,\n  start = 0,\n  end = text.length\n) {\n  let count = 0\n\n  for (let i = start; i < end; i++) {\n    if (text.charAt(i) === character) {\n      count++\n    }\n  }\n\n  return count\n}\n\n/**\n * Find the text location of a JSON path\n */\n// TODO: write unit tests\nexport function findTextLocation(text: string, path: JSONPath): TextLocation {\n  try {\n    const jsmap = jsonSourceMap.parse(text)\n\n    const pointerName = compileJSONPointer(path)\n    const pointer = jsmap.pointers[pointerName]\n    if (pointer) {\n      return {\n        path,\n        line: pointer.key ? pointer.key.line : pointer.value ? pointer.value.line : 0,\n        column: pointer.key ? pointer.key.column : pointer.value ? pointer.value.column : 0,\n        from: pointer.key ? pointer.key.pos : pointer.value ? pointer.value.pos : 0,\n        to: pointer.keyEnd ? pointer.keyEnd.pos : pointer.valueEnd ? pointer.valueEnd.pos : 0\n      }\n    }\n  } catch (err) {\n    console.error(err)\n  }\n\n  return {\n    path,\n    line: 0,\n    column: 0,\n    from: 0,\n    to: 0\n  }\n}\n\n/**\n * Convert a JSON object, array, or value to another type\n * If it cannot be converted, an error is thrown\n */\nexport function convertValue(\n  value: unknown,\n  type: 'value' | 'object' | 'array',\n  parser: JSONParser\n): unknown {\n  // FIXME: improve the TypeScript here, there are a couple of conversions\n  if (type === 'array') {\n    if (Array.isArray(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (isObject(value)) {\n      return objectToArray(value)\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (Array.isArray(parsedValue)) {\n          return parsedValue\n        }\n\n        if (isObject(parsedValue)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return objectToArray(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first key of the array\n        return [value]\n      }\n    }\n\n    //all other cases, we return the value as the first key of the array, same as the parsing error under the string case\n    return [value]\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      return arrayToObject(value)\n    }\n\n    if (isObject(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (isObject(parsedValue)) {\n          return parsedValue\n        }\n\n        if (Array.isArray(parsedValue)) {\n          return arrayToObject(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first value of the object with key 'value'\n        return { value: value }\n      }\n    }\n\n    //all other cases, we return the value keyed under \"value\", same as the parsing error under the string case\n    return { value: value }\n  }\n\n  if (type === 'value') {\n    if (isObjectOrArray(value)) {\n      return parser.stringify(value)\n    }\n\n    // nothing to do\n    return value\n  }\n\n  throw new Error(`Cannot convert ${valueType(value, parser)} to ${type}`)\n}\n\n/**\n * Check whether provided value is valid a content type for JSONEditor\n * Returns a string with validation error message when there is an issue,\n * or null otherwise\n */\nexport function validateContentType(content: unknown): string | undefined {\n  if (!isObject(content)) {\n    return 'Content must be an object'\n  }\n\n  if (content.json !== undefined) {\n    if (content.text !== undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\" but not both'\n    } else {\n      return undefined\n    }\n  } else {\n    if (content.text === undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\"'\n    } else if (typeof content.text !== 'string') {\n      return (\n        'Content \"text\" property must be a string containing a JSON document. ' +\n        'Did you mean to use the \"json\" property instead?'\n      )\n    } else {\n      return undefined\n    }\n  }\n}\n\n/**\n * Check whether a value is Content (TextContent or JSONContent)\n */\nexport function isContent(content: unknown): content is Content {\n  return (\n    isObject(content) && (typeof content.json !== 'undefined' || typeof content.text === 'string')\n  )\n}\n\n/**\n * Check whether content contains text (and not JSON)\n */\nexport function isTextContent(content: unknown): content is TextContent {\n  return isObject(content) && typeof content.text === 'string'\n}\n\n/**\n * Check whether content contains json\n */\nexport function isJSONContent(content: unknown): content is JSONContent {\n  return isObject(content) && typeof content.json !== 'undefined'\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n */\nexport function toTextContent(\n  content: Content,\n  indentation: number | string | undefined = undefined,\n  parser: JSONParser = JSON\n): TextContent {\n  return isTextContent(content)\n    ? content\n    : { text: parser.stringify(content.json, null, indentation) as string }\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n * @throws {SyntaxError} Will throw a parse error when the text contents does not contain valid JSON\n */\nexport function toJSONContent(content: Content, parser: JSONParser = JSON): JSONContent {\n  return isJSONContent(content) ? content : { json: parser.parse(content.text) }\n}\n\n/**\n * Get the contents as Text. If the contents is JSON, the JSON will be parsed.\n */\nexport function getText(content: Content, indentation: number | string, parser: JSONParser) {\n  return toTextContent(content, indentation, parser).text\n}\n\n/**\n * Returns true when the (estimated) size of the contents exceeds the\n * provided maxSize.\n * @param content\n * @param maxSize  Maximum content size in bytes\n */\nexport function isLargeContent(content: Content, maxSize: number): boolean {\n  return estimateSerializedSize(content, maxSize) > maxSize\n}\n\n/**\n * A rough, fast estimation on whether a document is larger than given size\n * when serialized.\n *\n * maxSize is an optional max size in bytes. When reached, size estimation will\n * be cancelled. This is useful when you're only interested in knowing whether\n * the size exceeds a certain maximum size.\n */\nexport function estimateSerializedSize(content: Content, maxSize = Infinity): number {\n  if (isTextContent(content)) {\n    return content.text.length\n  }\n\n  const json = content.json\n\n  let estimatedSize = 0\n\n  function recurse(json: unknown) {\n    if (Array.isArray(json)) {\n      // open and close bracket, commas between items\n      estimatedSize += 2 + (json.length - 1)\n\n      if (estimatedSize > maxSize) {\n        return\n      }\n\n      for (let i = 0; i < json.length; i++) {\n        const item = json[i]\n\n        recurse(item)\n\n        if (estimatedSize > maxSize) {\n          return\n        }\n      }\n    } else if (isObject(json)) {\n      const keys = Object.keys(json)\n\n      // open and close brackets, separators between all keys and values, comma's between key/value pairs\n      estimatedSize += 2 + keys.length + (keys.length - 1)\n\n      for (let k = 0; k < keys.length; k++) {\n        const key = keys[k]\n        const value = json[key]\n\n        // key length and double quotes around it\n        estimatedSize += key.length + 2\n\n        recurse(value)\n      }\n    } else if (typeof json === 'string') {\n      estimatedSize += json.length + 2 // string length plus two for the double quote characters\n    } else {\n      // true, false, null, number\n      estimatedSize += String(json).length\n    }\n  }\n\n  recurse(json)\n\n  return estimatedSize\n}\n\nconst POSITION_REGEX = /(position|char) (\\d+)/\nconst LINE_REGEX = /line (\\d+)/\nconst COLUMN_REGEX = /column (\\d+)/\n\n/**\n * Check whether the actual functions of parse and stringify are strictly equal.\n * The object holding the functions may be a differing instance.\n */\nexport function isEqualParser(a: JSONParser, b: JSONParser): boolean {\n  return a.parse === b.parse && a.stringify === b.stringify\n}\n\n/**\n * Apply a fast and cheap heuristic to determine whether the content needs formatting (i.e. is compact).\n */\nexport function needsFormatting(jsonText: string): boolean {\n  const maxLength = 999\n  const head = jsonText.substring(0, maxLength).trim()\n  return !head.includes('\\n') && DELIMITER_WITHOUT_SPACING_REGEX.test(head)\n}\n\n// This regex matches cases of a comma or colon NOT followed by a whitespace\nconst DELIMITER_WITHOUT_SPACING_REGEX = /[,:]\\S/\n","import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\nimport type { SvelteComponent } from 'svelte'\nimport type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { Action } from 'svelte/action'\n\nexport type TextContent = { text: string }\n\nexport type JSONContent = { json: unknown }\n\nexport type Content = JSONContent | TextContent\n\n// The `JSONParser` interface is compatible with `JSON`,\n// except that JSON.stringify is wrongly defined to return a string whilst it can return a string or undefined\n// see: https://stackoverflow.com/questions/74461780/is-the-official-type-definition-for-json-stringify-wrong\nexport interface JSONParser {\n  parse(\n    text: string,\n    reviver?: ((this: unknown, key: string, value: unknown) => unknown) | null\n  ): unknown\n\n  stringify(\n    value: unknown,\n    replacer?:\n      | ((this: unknown, key: string, value: unknown) => unknown)\n      | Array<number | string>\n      | null,\n    space?: string | number\n  ): string | undefined\n}\n\nexport interface JSONPathParser {\n  parse: (pathStr: string) => JSONPath\n  stringify: (path: JSONPath) => string\n}\n\nexport interface VisibleSection {\n  start: number\n  end: number\n}\n\nexport enum Mode {\n  text = 'text',\n  tree = 'tree',\n  table = 'table'\n}\n\nexport enum SelectionType {\n  after = 'after',\n  inside = 'inside',\n  key = 'key',\n  value = 'value',\n  multi = 'multi',\n  text = 'text' // in text mode\n}\n\nexport enum CaretType {\n  after = 'after',\n  key = 'key',\n  value = 'value',\n  inside = 'inside'\n}\n\nexport interface PathOption {\n  value: JSONPath\n  label: string\n}\n\nexport interface NumberOption {\n  value: 1 | -1\n  label: string\n}\n\nexport interface CaretPosition {\n  path: JSONPath\n  type: CaretType // TODO: refactor this to use SelectionType here, then we can simplify the util functions to turn this into a selection\n}\n\nexport interface ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, RecursiveState | undefined>\n}\n\nexport interface ArrayRecursiveState {\n  type: 'array'\n  items: Array<RecursiveState | undefined>\n}\n\nexport interface ValueRecursiveState {\n  type: 'value'\n}\n\nexport type RecursiveState = ObjectRecursiveState | ArrayRecursiveState | ValueRecursiveState\n\nexport interface RecursiveStateFactory {\n  createObjectDocumentState: () => ObjectRecursiveState\n  createArrayDocumentState: () => ArrayRecursiveState\n  createValueDocumentState: () => ValueRecursiveState\n}\n\nexport interface ObjectDocumentState extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, DocumentState | undefined>\n  expanded: boolean\n}\n\nexport interface ArrayDocumentState extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<DocumentState | undefined>\n  expanded: boolean\n  visibleSections: VisibleSection[]\n}\n\nexport interface ValueDocumentState extends ValueRecursiveState {\n  type: 'value'\n  enforceString?: boolean\n}\n\nexport type DocumentState = ObjectDocumentState | ArrayDocumentState | ValueDocumentState\n\nexport interface ObjectSearchResults extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ArraySearchResults extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ValueSearchResults extends ValueRecursiveState {\n  type: 'value'\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport type SearchResults = ObjectSearchResults | ArraySearchResults | ValueSearchResults\n\nexport type WithSearchResults = SearchResults & {\n  searchResults: ExtendedSearchResultItem[]\n}\n\nexport interface ObjectValidationErrors extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ArrayValidationErrors extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ValueValidationErrors extends ValueRecursiveState {\n  type: 'value'\n  validationError?: NestedValidationError\n}\n\nexport type ValidationErrors =\n  | ObjectValidationErrors\n  | ArrayValidationErrors\n  | ValueValidationErrors\n\nexport interface JSONPatchResult {\n  json: unknown\n  previousJson: unknown\n  undo: JSONPatchDocument\n  redo: JSONPatchDocument\n}\n\nexport type AfterPatchCallback = (\n  patchedJson: unknown,\n  patchedState: DocumentState | undefined,\n  patchedSelection: JSONSelection | undefined\n) =>\n  | {\n      json?: unknown\n      state?: DocumentState | undefined\n      selection?: JSONSelection | undefined\n      sortedColumn?: SortedColumn | undefined\n    }\n  | undefined\n\nexport interface MultiSelection {\n  type: SelectionType.multi\n  anchorPath: JSONPath\n  focusPath: JSONPath\n}\n\nexport interface AfterSelection {\n  type: SelectionType.after\n  path: JSONPath\n}\n\nexport interface InsideSelection {\n  type: SelectionType.inside\n  path: JSONPath\n}\n\nexport interface KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n}\n\nexport interface EditKeySelection extends KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type ValueSelection = {\n  type: SelectionType.value\n  path: JSONPath\n}\n\nexport interface EditValueSelection extends ValueSelection {\n  type: SelectionType.value\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type JSONSelection =\n  | MultiSelection\n  | AfterSelection\n  | InsideSelection\n  | KeySelection\n  | EditKeySelection\n  | ValueSelection\n  | EditValueSelection\n\n// TextSelection is the result of EditorSelection.toJSON() from CodeMirror,\n// with an additional `type` property\nexport interface TextSelection {\n  type: SelectionType.text\n  ranges: { anchor: number; head: number }[]\n  main: number\n}\n\nexport type JSONEditorSelection = JSONSelection | TextSelection\n\nexport type ClipboardValues = Array<{ key: string; value: unknown }>\n\nexport interface MenuButton {\n  type: 'button'\n  onClick: (event: MouseEvent) => void\n  icon?: IconDefinition\n  text?: string\n  title?: string\n  className?: string\n  disabled?: boolean\n}\n\nexport interface MenuDropDownButton {\n  type: 'dropdown-button'\n  main: MenuButton\n  width?: string\n  items: MenuButton[]\n}\n\nexport interface MenuLabel {\n  type: 'label'\n  text: string\n}\n\nexport interface MenuSeparator {\n  type: 'separator'\n}\n\nexport interface MenuSpace {\n  type: 'space'\n}\n\nexport type MenuItem = MenuButton | MenuSeparator | MenuSpace\n\nexport interface ContextMenuColumn {\n  type: 'column'\n  items: Array<MenuButton | MenuDropDownButton | MenuLabel | MenuSeparator>\n}\nexport interface ContextMenuRow {\n  type: 'row'\n  items: Array<MenuButton | MenuDropDownButton | ContextMenuColumn>\n}\nexport type ContextMenuItem = MenuButton | MenuDropDownButton | MenuSeparator | ContextMenuRow\n\nexport interface MessageAction {\n  text: string\n  title: string\n  icon?: IconDefinition\n  onClick?: () => void\n  onMouseDown?: () => void\n  disabled?: boolean\n}\n\nexport enum ValidationSeverity {\n  info = 'info',\n  warning = 'warning',\n  error = 'error'\n}\n\nexport interface ValidationError {\n  path: JSONPath\n  message: string\n  severity: ValidationSeverity\n}\n\nexport interface NestedValidationError extends ValidationError {\n  isChildError?: boolean\n}\n\nexport type Validator = (json: unknown) => ValidationError[]\n\nexport interface ParseError {\n  position: number | undefined\n  line: number | undefined\n  column: number | undefined\n  message: string\n}\n\nexport interface ContentParseError {\n  parseError: ParseError\n  isRepairable: boolean\n}\n\nexport interface ContentValidationErrors {\n  validationErrors: ValidationError[]\n}\n\nexport type ContentErrors = ContentParseError | ContentValidationErrors\n\nexport interface RichValidationError extends ValidationError {\n  line: number | undefined\n  column: number | undefined\n  from: number | undefined\n  to: number | undefined\n  actions: Array<{ name: string; apply: () => void }> | undefined\n}\n\nexport interface TextLocation {\n  path: JSONPath\n  line: number\n  column: number\n  from: number\n  to: number\n}\n\nexport interface Section {\n  start: number // start included\n  end: number // end excluded\n}\n\nexport interface QueryLanguage {\n  id: string\n  name: string\n  description: string\n  createQuery: (json: unknown, queryOptions: QueryLanguageOptions) => string\n  executeQuery: (json: unknown, query: string, parser: JSONParser) => unknown\n}\n\nexport interface QueryLanguageOptions {\n  filter?: {\n    path?: JSONPath\n    relation?: '==' | '!=' | '<' | '<=' | '>' | '>='\n    value?: string\n  }\n  sort?: {\n    path?: JSONPath\n    direction?: 'asc' | 'desc'\n  }\n  projection?: {\n    paths?: JSONPath[]\n  }\n}\n\nexport type OnChangeQueryLanguage = (queryLanguageId: string) => void\nexport interface OnChangeStatus {\n  contentErrors: ContentErrors | undefined\n  patchResult: JSONPatchResult | undefined\n}\nexport type OnChange =\n  | ((content: Content, previousContent: Content, status: OnChangeStatus) => void)\n  | undefined\nexport type OnJSONSelect = (selection: JSONSelection) => void\nexport type OnSelect = (selection: JSONEditorSelection | undefined) => void\nexport type OnPatch = (\n  operations: JSONPatchDocument,\n  afterPatch?: AfterPatchCallback\n) => JSONPatchResult\nexport type OnChangeText = (updatedText: string, afterPatch?: AfterPatchCallback) => void\nexport type OnSort = (params: {\n  operations: JSONPatchDocument\n  rootPath: JSONPath\n  itemPath: JSONPath\n  direction: 1 | -1\n}) => void\nexport type OnFind = (findAndReplace: boolean) => void\nexport type OnPaste = (pastedText: string) => void\nexport type OnPasteJson = (pastedJson: PastedJson) => void\nexport type OnExpand = (relativePath: JSONPath) => boolean\nexport type OnRenderValue = (props: RenderValueProps) => RenderValueComponentDescription[]\nexport type OnClassName = (path: JSONPath, value: unknown) => string | undefined\nexport type OnChangeMode = (mode: Mode) => void\nexport type OnContextMenu = (contextMenuProps: AbsolutePopupOptions) => void\nexport type RenderMenuContext = {\n  mode: Mode\n  modal: boolean\n  readOnly: boolean\n}\nexport type OnRenderMenu = (items: MenuItem[], context: RenderMenuContext) => MenuItem[] | undefined\nexport type OnRenderMenuInternal = (items: MenuItem[]) => MenuItem[] | undefined\nexport type RenderContextMenuContext = RenderMenuContext & {\n  selection: JSONEditorSelection | undefined\n}\nexport type OnRenderContextMenu = (\n  items: ContextMenuItem[],\n  context: RenderContextMenuContext\n) => ContextMenuItem[] | false | undefined\nexport type OnRenderContextMenuInternal = (\n  items: ContextMenuItem[]\n) => ContextMenuItem[] | false | undefined\nexport type OnError = (error: Error) => void\nexport type OnFocus = () => void\nexport type OnBlur = () => void\nexport type OnSortModal = (props: SortModalCallback) => void\nexport type OnTransformModal = (props: TransformModalCallback) => void\nexport type OnJSONEditorModal = (props: JSONEditorModalCallback) => void\nexport type FindNextInside = (path: JSONPath) => JSONSelection | undefined\n\nexport interface SearchResultDetails {\n  items: ExtendedSearchResultItem[]\n  activeItem: ExtendedSearchResultItem | undefined\n  activeIndex: number | -1\n}\n\nexport enum SearchField {\n  key = 'key',\n  value = 'value'\n}\n\nexport interface SearchOptions {\n  maxResults?: number\n  columns?: JSONPath[]\n}\n\nexport interface SearchResultItem {\n  path: JSONPath\n  field: SearchField\n  fieldIndex: number\n  start: number\n  end: number\n}\n\nexport interface ExtendedSearchResultItem extends SearchResultItem {\n  active: boolean\n}\n\nexport type EscapeValue = (value: unknown) => string\n\nexport type UnescapeValue = (escapedValue: string) => string\n\nexport interface ValueNormalization {\n  escapeValue: EscapeValue\n  unescapeValue: UnescapeValue\n}\n\nexport type PastedJson = {\n  path: JSONPath\n  contents: unknown\n  onPasteAsJson: () => void\n}\n\nexport interface DragInsideProps {\n  json: unknown\n  selection: JSONSelection\n  deltaY: number\n  items: Array<{ path: JSONPath; height: number }>\n}\n\nexport type DragInsideAction =\n  | { beforePath: JSONPath; offset: number }\n  | { append: true; offset: number }\n\nexport interface RenderedItem {\n  path: JSONPath\n  height: number\n}\n\nexport interface HistoryItem {\n  undo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n  redo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n}\n\nexport type ConvertType = 'value' | 'object' | 'array'\nexport type InsertType = ConvertType | 'structure'\n\nexport interface PopupEntry {\n  id: number\n  component: typeof SvelteComponent<Record<string, unknown>>\n  props: Record<string, unknown>\n  options: AbsolutePopupOptions\n}\n\nexport interface AbsolutePopupOptions {\n  anchor?: Element\n  position?: 'top' | 'left'\n  left?: number\n  top?: number\n  width?: number\n  height?: number\n  offsetTop?: number\n  offsetLeft?: number\n  showTip?: boolean\n  closeOnOuterClick?: boolean\n  onClose?: () => void\n}\n\nexport interface AbsolutePopupContext {\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport interface JSONEditorPropsOptional {\n  content?: Content\n  readOnly?: boolean\n  indentation?: number | string\n  tabSize?: number\n  mode?: Mode\n  mainMenuBar?: boolean\n  navigationBar?: boolean\n  statusBar?: boolean\n  askToFormat?: boolean\n  escapeControlCharacters?: boolean\n  escapeUnicodeCharacters?: boolean\n  flattenColumns?: boolean\n  parser?: JSONParser\n  validator?: Validator | undefined\n  validationParser?: JSONParser\n  pathParser?: JSONPathParser\n\n  queryLanguages?: QueryLanguage[]\n  queryLanguageId?: string\n\n  onChangeQueryLanguage?: OnChangeQueryLanguage\n  onChange?: OnChange\n  onRenderValue?: OnRenderValue\n  onClassName?: OnClassName\n  onRenderMenu?: OnRenderMenu\n  onRenderContextMenu?: OnRenderContextMenu\n  onChangeMode?: OnChangeMode\n  onSelect?: OnSelect\n  onError?: OnError\n  onFocus?: OnFocus\n  onBlur?: OnBlur\n}\n\nexport interface JSONEditorModalProps {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n\n  readOnly: boolean\n  indentation: number | string\n  tabSize: number\n  mainMenuBar: boolean\n  navigationBar: boolean\n  statusBar: boolean\n  askToFormat: boolean\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  flattenColumns: boolean\n  parser: JSONParser\n  validator: Validator | undefined\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  onRenderValue: OnRenderValue\n  onClassName: OnClassName\n  onRenderMenu: OnRenderMenu\n  onRenderContextMenu: OnRenderContextMenu\n  onSortModal: (props: SortModalCallback) => void\n  onTransformModal: (props: TransformModalCallback) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorContext {\n  mode: Mode\n  readOnly: boolean\n  parser: JSONParser\n  normalization: ValueNormalization\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  findNextInside: FindNextInside\n  focus: () => void\n  onPatch: OnPatch\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  onPasteJson: (newPastedJson: PastedJson) => void\n  onRenderValue: OnRenderValue\n}\n\nexport interface TreeModeContext extends JSONEditorContext {\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  getSelection: () => JSONSelection | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  onInsert: (type: InsertType) => void\n  onExpand: (path: JSONPath, expanded: boolean, recursive?: boolean) => void\n  onExpandSection: (path: JSONPath, section: Section) => void\n  onContextMenu: OnContextMenu\n  onClassName: OnClassName\n  onDrag: (event: MouseEvent) => void\n  onDragEnd: () => void\n}\n\nexport interface RenderValueProps {\n  path: JSONPath\n  value: unknown\n  mode: Mode\n  readOnly: boolean\n  enforceString: boolean\n  selection: JSONSelection | undefined\n  searchResultItems: SearchResultItem[] | undefined\n  isEditing: boolean\n  parser: JSONParser\n  normalization: ValueNormalization\n  onPatch: OnPatch\n  onPasteJson: OnPasteJson\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  findNextInside: FindNextInside\n  focus: () => void\n}\n\nexport type RenderValuePropsOptional = Partial<RenderValueProps>\n\nexport interface DraggingState {\n  initialTarget: Element\n  initialClientY: number\n  initialContentTop: number\n  selectionStartIndex: number\n  selectionItemsCount: number\n  items: RenderedItem[]\n  offset: number\n  didMoveItems: boolean\n}\n\nexport type RenderValueComponentDescription = SvelteComponentRenderer | SvelteActionRenderer\n\nexport interface SvelteComponentRenderer {\n  component: typeof SvelteComponent<RenderValuePropsOptional>\n  props: Record<string, unknown>\n}\n\nexport interface SvelteActionRenderer {\n  action: Action<HTMLElement, Record<string, unknown>>\n  props: Record<string, unknown>\n}\n\nexport interface TransformModalOptions {\n  id?: string\n  rootPath?: JSONPath\n  onTransform?: (state: {\n    operations: JSONPatchDocument\n    json: unknown\n    transformedJson: unknown\n  }) => void\n  onClose?: () => void\n}\n\nexport interface TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface TransformModalProps extends TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  indentation: number | string\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  parser: JSONParser\n  parseMemoizeOne: JSONParser['parse']\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  queryLanguages: QueryLanguage[]\n  queryLanguageId: string\n  onChangeQueryLanguage: OnChangeQueryLanguage\n\n  onRenderValue: OnRenderValue\n  onRenderMenu: OnRenderMenuInternal\n  onRenderContextMenu: OnRenderContextMenuInternal\n  onClassName: OnClassName\n\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface SortModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onSort: OnSort\n  onClose: () => void\n}\n\nexport interface JSONRepairModalProps {\n  text: string\n  onParse: (text: string) => void\n  onRepair: (text: string) => string\n  onApply: (repairedText: string) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorModalCallback {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n  onClose: () => void\n}\n\nexport enum SortDirection {\n  asc = 'asc',\n  desc = 'desc'\n}\n\nexport enum UpdateSelectionAfterChange {\n  no = 'no',\n  self = 'self',\n  nextInside = 'nextInside'\n}\n\nexport interface TableCellIndex {\n  rowIndex: number\n  columnIndex: number\n}\n\nexport interface SortedColumn {\n  path: JSONPath\n  sortDirection: SortDirection\n}\n\n// TODO: work out the JSONSchema type in detail.\n//  Ideally, we use use Schema from Ajv, but this interface isn't worked out either\nexport type JSONSchema = Record<string, unknown>\nexport type JSONSchemaDefinitions = Record<string, JSONSchema>\nexport type JSONSchemaEnum = Array<unknown>\n","import type { ValueNormalization } from '$lib/types.js'\nimport { SelectionType } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { map, minBy } from 'lodash-es'\n\n/**\n * Create serialization functions to escape and stringify text,\n * and the other way around: to parse and unescape text.\n */\nexport function createNormalizationFunctions({\n  escapeControlCharacters,\n  escapeUnicodeCharacters\n}: {\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n}): ValueNormalization {\n  if (escapeControlCharacters) {\n    if (escapeUnicodeCharacters) {\n      return normalizeControlAndUnicode\n    } else {\n      return normalizeControl\n    }\n  } else {\n    if (escapeUnicodeCharacters) {\n      return normalizeUnicode\n    } else {\n      return normalizeNothing\n    }\n  }\n}\n\nconst normalizeControlAndUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(jsonEscapeControl(String(value))),\n  unescapeValue: (value: string) => jsonUnescapeControl(jsonUnescapeUnicode(value))\n}\n\nconst normalizeControl = {\n  escapeValue: (value: unknown) => jsonEscapeControl(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeControl(value)\n}\n\nconst normalizeUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeUnicode(value)\n}\n\nconst normalizeNothing = {\n  escapeValue: (value: unknown) => String(value),\n  unescapeValue: (value: string) => value\n}\n\n/**\n * Source:  https://stackoverflow.com/questions/12271547/shouldnt-json-stringify-escape-unicode-characters\n */\nexport function jsonEscapeUnicode(value: string): string {\n  return value.replace(/[^\\x20-\\x7F]/g, (x) => {\n    if (x === '\\b' || x === '\\f' || x === '\\n' || x === '\\r' || x === '\\t') {\n      return x\n    }\n\n    return '\\\\u' + ('000' + x.codePointAt(0)?.toString(16)).slice(-4)\n  })\n}\n\nexport function jsonUnescapeUnicode(value: string): string {\n  return value.replace(/\\\\u[a-fA-F0-9]{4}/g, (x) => {\n    try {\n      const unescaped: string = JSON.parse('\"' + x + '\"')\n      // the resolved character can be a control character like \" or \\n,\n      // that would result in invalid JSON, so we need to keep that escaped\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return controlCharacters[unescaped] || unescaped\n    } catch {\n      return x\n    }\n  })\n}\n\nconst controlCharacters = {\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n  // unicode is handled separately\n}\n\nconst escapedControlCharacters = {\n  '\\\\\"': '\"',\n  '\\\\\\\\': '\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\\\/': '/',\n  '\\\\b': '\\b',\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t'\n  // unicode is handled separately\n}\n\nexport function jsonEscapeControl(value: string): string {\n  return value.replace(/[\"\\b\\f\\n\\r\\t\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return controlCharacters[x] || x\n  })\n}\n\nexport function jsonUnescapeControl(value: string): string {\n  return value.replace(/\\\\[\"bfnrt\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return escapedControlCharacters[x] || x\n  })\n}\n\nexport function addNewLineSuffix(value: unknown): string {\n  if (typeof value !== 'string') {\n    return String(value)\n  }\n\n  if (value.endsWith('\\n')) {\n    // DOM innerText strips the last \\n, therefore we add an extra \\n here\n    return value + '\\n'\n  }\n\n  return value\n}\n\n/**\n * Remove a newline suffix from text returned by element.innerText, it adds\n * one return too much.\n */\nexport function removeNewLineSuffix(text: string): string {\n  return text.replace(/\\n$/, '')\n}\n\n// regular expression matching one or multiple return characters with all their\n// enclosing white spaces\nexport function removeReturnsAndSurroundingWhitespace(text: string): string {\n  return text.replace(/(\\b|^)\\s*(\\b|$)/g, (match) => {\n    return /\\n/.exec(match) ? '' : match\n  })\n}\n\nexport function isChildOfNodeName(element: Element, nodeName: string): boolean {\n  return isChildOf(element, (e) => e.nodeName.toUpperCase() === nodeName.toUpperCase())\n}\n\nexport function isChildOfAttribute(element: Element, name: string, value: string): boolean {\n  return isChildOf(element, (e) => hasAttribute(e, name, value))\n}\n\n// test whether a DOM element is a content editable div\nexport function isContentEditableDiv(element: HTMLElement): boolean {\n  return element.nodeName === 'DIV' && element.contentEditable === 'true'\n}\n\n// test whether a DOM element is an \"input\" with type \"text\"\nexport function isTextInput(element: HTMLInputElement): boolean {\n  return (\n    element.nodeName === 'INPUT' &&\n    element.type !== undefined &&\n    element.type.toLowerCase() === 'text'\n  )\n}\n\nfunction hasAttribute(element: Element, name: string, value: string): boolean {\n  return typeof element.getAttribute === 'function' && element.getAttribute(name) === value\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n */\nexport function isChildOf(element: Element, predicate: (element: Element) => boolean): boolean {\n  return !!findParent(element, predicate)\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n * @param {HTMLElement} element\n * @param {function (element: HTMLElement) : boolean} predicate\n * @returns {HTMLElement | undefined}\n */\nexport function findParent(\n  element: Element,\n  predicate: (element: Element) => boolean\n): Element | undefined {\n  let e: Element | undefined = element\n\n  while (e && !predicate(e)) {\n    e = e.parentNode as Element\n  }\n\n  return e\n}\n\n/**\n * Set the cursor to the end of a content editable div\n * Source: https://stackoverflow.com/questions/13513329/set-cursor-to-the-end-of-contenteditable-div\n * @param {HTMLElement} element\n */\nexport function setCursorToEnd(element: HTMLElement) {\n  if (element.firstChild == null) {\n    element.focus()\n    return\n  }\n\n  const range = document.createRange()\n  const selection = window.getSelection()\n  range.setStart(element, 1)\n  range.collapse(true)\n  selection?.removeAllRanges()\n  selection?.addRange(range)\n}\n\n/**\n * Gets a DOM element's Window.  This is normally just the global `window`\n * variable, but if we opened a child window, it may be different.\n */\nexport function getWindow(element: Element): Window | undefined {\n  return element?.ownerDocument?.defaultView ?? undefined\n}\n\nexport function activeElementIsChildOf(element: Element) {\n  const window = getWindow(element)\n  const activeElement = window?.document.activeElement\n  return activeElement ? isChildOf(activeElement, (e) => e === element) : false\n}\n\n/**\n * Traverse over the parents of the element until a node is found with the\n * searched for node name. If the element itself contains the nodeName, the\n * element itself will be returned\n */\nexport function findParentWithNodeName(element: Element, nodeName: string): Element | undefined {\n  return findParent(element, (e) => e.nodeName === nodeName)\n}\n\nexport function getSelectionTypeFromTarget(target: Element): SelectionType {\n  if (isChildOfAttribute(target, 'data-type', 'selectable-key')) {\n    return SelectionType.key\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'selectable-value')) {\n    return SelectionType.value\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-inside')) {\n    return SelectionType.inside\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-after')) {\n    return SelectionType.after\n  }\n\n  return SelectionType.multi\n}\n\n/**\n * Encode a path into a string that can be used as attribute in HTML\n */\nexport function encodeDataPath(path: JSONPath): string {\n  return encodeURIComponent(compileJSONPointer(path))\n}\n\n/**\n * Decode a path that was stringified for use as an HTML attribute\n */\nexport function decodeDataPath(pathStr: string): JSONPath {\n  return parseJSONPointer(decodeURIComponent(pathStr))\n}\n\n/**\n * Find the data path of the given element. Traverses the parent nodes until find\n */\nexport function getDataPathFromTarget(target: Element): JSONPath | undefined {\n  const parent = findParent(target, (element) => {\n    return element?.hasAttribute ? element.hasAttribute('data-path') : false\n  })\n\n  const dataPath = parent?.getAttribute('data-path') ?? undefined\n  return dataPath ? decodeDataPath(dataPath) : undefined\n}\n\n/**\n * Find the nearest element in a given context menu with buttons or inputs\n */\n// TODO: unit test\nexport function findNearestElement<T extends Element>({\n  allElements,\n  currentElement,\n  direction,\n  hasPrio = () => true,\n  margin = 10\n}: {\n  allElements: T[]\n  currentElement: T\n  direction: 'Up' | 'Down' | 'Left' | 'Right'\n  margin?: number\n  hasPrio?: (element: T) => boolean\n}): T | undefined {\n  const all = map(allElements.filter(isVisible), calculateCenter)\n  const current = calculateCenter(currentElement)\n\n  interface CenterLocation {\n    x: number\n    y: number\n    rect: DOMRect\n    element: T\n  }\n\n  function isVisible(element: T): boolean {\n    const rect = element.getBoundingClientRect()\n    return rect.width > 0 && rect.height > 0\n  }\n\n  function calculateCenter(element: T): CenterLocation {\n    const rect = element.getBoundingClientRect()\n    return {\n      x: rect.left + rect.width / 2,\n      y: rect.top + rect.height / 2,\n      rect,\n      element\n    }\n  }\n\n  const isOnSameRow = (a: CenterLocation, b: CenterLocation) => Math.abs(a.y - b.y) < margin\n  const isLeft = (a: CenterLocation, b: CenterLocation) => a.rect.left + margin < b.rect.left\n  const isRight = (a: CenterLocation, b: CenterLocation) => a.rect.right > b.rect.right + margin\n  const isAbove = (a: CenterLocation, b: CenterLocation) => a.y + margin < b.y\n  const isBelow = (a: CenterLocation, b: CenterLocation) => a.y > b.y + margin\n\n  function distance(a: CenterLocation, b: CenterLocation, weightY = 1): number {\n    const diffX = a.x - b.x\n    const diffY = (a.y - b.y) * weightY\n    return Math.sqrt(diffX * diffX + diffY * diffY)\n  }\n  const distanceToCurrent = (candidate: CenterLocation) => distance(candidate, current)\n  const distanceToCurrentWeighted = (candidate: CenterLocation) => distance(candidate, current, 10)\n\n  if (direction === 'Left' || direction === 'Right') {\n    // First we find the first button left from the current button on the same row\n    // if not found, search the closest button left/right from current button\n    const candidatesLeft =\n      direction === 'Left'\n        ? all.filter((button) => isLeft(button, current))\n        : all.filter((button) => isRight(button, current))\n    const candidatesLeftOnRow = candidatesLeft.filter((button) => isOnSameRow(button, current))\n    const nearest =\n      minBy(candidatesLeftOnRow, distanceToCurrent) ||\n      minBy(candidatesLeft, distanceToCurrentWeighted)\n\n    return nearest?.element\n  }\n\n  if (direction === 'Up' || direction === 'Down') {\n    // first we only search through the prio buttons\n    // if there were no matching prio buttons, search all matching buttons\n    const candidates =\n      direction === 'Up'\n        ? all.filter((button) => isAbove(button, current))\n        : all.filter((button) => isBelow(button, current))\n    const prioCandidates = candidates.filter((button) => hasPrio(button.element))\n    const nearest = minBy(prioCandidates, distanceToCurrent) || minBy(candidates, distanceToCurrent)\n\n    return nearest?.element\n  }\n\n  return undefined\n}\n","declare global {\n  // extend with the userAgentData: NavigatorUAData property (currently experimental)\n  // see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgentData\n  interface Navigator {\n    userAgentData?: {\n      platform: string\n    }\n  }\n}\n\nexport function isMacDevice() {\n  return (\n    typeof navigator !== 'undefined' &&\n    (navigator?.platform?.toUpperCase().includes('MAC') ??\n      navigator?.userAgentData?.platform?.toUpperCase().includes('MAC') ??\n      false)\n  )\n}\n","// inspiration: https://github.com/andrepolischuk/keycomb\n\nimport { isMacDevice } from './navigatorUtils.js'\n\n// KeyComboEvent is a subset of KeyboardEvent\nexport interface KeyComboEvent {\n  ctrlKey: boolean\n  metaKey: boolean\n  altKey: boolean\n  shiftKey: boolean\n  key: string\n}\n\n/**\n * Get the active key combination from a keyboard event.\n * For example returns \"Ctrl+Shift+ArrowUp\" or \"Ctrl+A\"\n *\n * Returns the same output on both Windows and Mac:\n * meta keys \"Ctrl\" (\"Command\" on Mac), and \"Alt\" (\"Alt\" or \"Option\" on Mac)\n * So pressing \"Command\" and \"A\"on Mac will return \"Ctrl+A\"\n */\nexport function keyComboFromEvent(\n  event: KeyComboEvent,\n  separator = '+',\n  isMac = isMacDevice\n): string {\n  const combi = []\n\n  if (isCtrlKeyDown(event, isMac)) {\n    // on Mac this is called Command or Cmd\n    combi.push('Ctrl')\n  }\n  if (event.altKey) {\n    // on Mac this is called Option\n    combi.push('Alt')\n  }\n  if (event.shiftKey) {\n    combi.push('Shift')\n  }\n\n  const keyName = event.key.length === 1 ? event.key.toUpperCase() : event.key\n  if (!(keyName in metaKeys)) {\n    // prevent output like 'Ctrl+Ctrl'\n    combi.push(keyName)\n  }\n\n  return combi.join(separator)\n}\n\n/**\n * Test whether the Ctrl key (windows, linux) or Command key (mac) is down\n */\nexport function isCtrlKeyDown(\n  event: { ctrlKey: boolean; metaKey: boolean },\n  isMac = isMacDevice\n): boolean {\n  // metaKey is the Command key ⌘ on a Mac (but the Windows Key ⊞ on Windows)\n  return event.ctrlKey || (event.metaKey && isMac())\n}\n\nconst metaKeys = {\n  Ctrl: true,\n  Command: true,\n  Control: true,\n  Alt: true,\n  Option: true,\n  Shift: true\n}\n","<script lang=\"ts\">\n  import type { AbsolutePopupOptions, PopupEntry } from '$lib/types.js'\n  import { onMount } from 'svelte'\n  import { isChildOf } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n\n  export let popup: PopupEntry\n  export let closeAbsolutePopup: (popupId: number) => void\n\n  let refRootPopup: HTMLDivElement\n  let refHiddenInput: HTMLInputElement\n\n  onMount(focus)\n\n  function closeWhenOutside(event: Event) {\n    if (\n      popup.options &&\n      popup.options.closeOnOuterClick &&\n      !isChildOf(event.target as HTMLElement, (e) => e === refRootPopup)\n    ) {\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleWindowMouseDown(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function handleMouseDownInside(event: Event) {\n    event.stopPropagation()\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleScrollWheel(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function calculateStyle(refRootPopup: HTMLDivElement, options: AbsolutePopupOptions) {\n    function calculatePosition() {\n      if (options.anchor) {\n        const { anchor, width = 0, height = 0, offsetTop = 0, offsetLeft = 0, position } = options\n        const { left, top, bottom, right } = anchor.getBoundingClientRect()\n\n        const positionAbove =\n          position === 'top' || (top + height > window.innerHeight && top > height)\n        const positionLeft =\n          position === 'left' || (left + width > window.innerWidth && left > width)\n\n        return {\n          left: positionLeft ? right - offsetLeft : left + offsetLeft,\n          top: positionAbove ? top - offsetTop : bottom + offsetTop,\n          positionAbove,\n          positionLeft\n        }\n      } else if (typeof options.left === 'number' && typeof options.top === 'number') {\n        const { left, top, width = 0, height = 0 } = options\n\n        const positionAbove = top + height > window.innerHeight && top > height\n        const positionLeft = left + width > window.innerWidth && left > width\n\n        return {\n          left,\n          top,\n          positionAbove,\n          positionLeft\n        }\n      } else {\n        throw new Error('Invalid config: pass either \"left\" and \"top\", or pass \"anchor\"')\n      }\n    }\n\n    const rootRect = refRootPopup.getBoundingClientRect()\n    const { left, top, positionAbove, positionLeft } = calculatePosition()\n\n    const verticalStyling = positionAbove\n      ? `bottom: ${rootRect.top - top}px;`\n      : `top: ${top - rootRect.top}px;`\n\n    const horizontalStyling = positionLeft\n      ? `right: ${rootRect.left - left}px;`\n      : `left: ${left - rootRect.left}px;`\n\n    return verticalStyling + horizontalStyling\n  }\n\n  function focus() {\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n    }\n  }\n</script>\n\n<svelte:window\n  on:mousedown|capture={handleWindowMouseDown}\n  on:keydown|capture={handleKeyDown}\n  on:wheel|capture={handleScrollWheel}\n/>\n\n<div\n  role=\"none\"\n  bind:this={refRootPopup}\n  class=\"jse-absolute-popup\"\n  on:mousedown={handleMouseDownInside}\n  on:keydown={handleKeyDown}\n>\n  {#if refRootPopup}\n    <div class=\"jse-absolute-popup-content\" style={calculateStyle(refRootPopup, popup.options)}>\n      <input\n        type=\"text\"\n        readonly\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n      />\n      <svelte:component this={popup.component} {...popup.props} />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./AbsolutePopupEntry.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '$lib/utils/debug.js'\n  import { setContext, type SvelteComponent } from 'svelte'\n  import type { AbsolutePopupOptions, PopupEntry, AbsolutePopupContext } from '$lib/types'\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import AbsolutePopupEntry from './AbsolutePopupEntry.svelte'\n\n  const debug = createDebug('jsoneditor:AbsolutePopup')\n\n  let popups: PopupEntry[] = []\n\n  function openAbsolutePopup(\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ): number {\n    debug('open...', props, options)\n\n    const popup: PopupEntry = {\n      id: uniqueId(),\n      component: component,\n      props: props || {},\n      options: options || {}\n    }\n\n    popups = [...popups, popup]\n\n    return popup.id\n  }\n\n  function closeAbsolutePopup(popupId: number | undefined) {\n    const popupIndex = popups.findIndex((popup) => popup.id === popupId)\n\n    if (popupIndex !== -1) {\n      const popup = popups[popupIndex]\n      if (popup.options.onClose) {\n        popup.options.onClose()\n      }\n\n      popups = popups.filter((popup) => popup.id !== popupId)\n    }\n  }\n\n  $: debug('popups', popups)\n\n  setContext<AbsolutePopupContext>('absolute-popup', { openAbsolutePopup, closeAbsolutePopup })\n</script>\n\n{#each popups as popup}\n  <AbsolutePopupEntry {popup} {closeAbsolutePopup} />\n{/each}\n\n<slot />\n","/**\n * Find a unique name. Suffix the name with ' (copy)', '(copy 2)', etc\n * until a unique name is found\n * @param name    Proposed name\n * @param keys    Array with existing keys\n */\nexport function findUniqueName(name: string, keys: string[]): string {\n  const keysSet = new Set(keys)\n\n  // remove any \" (copy)\" or \" (copy 2)\" suffix from the name\n  const nameWithoutCopySuffix = name.replace(/ \\(copy( \\d+)?\\)$/, '')\n\n  let validName = name\n  let i = 1\n\n  while (keysSet.has(validName)) {\n    const copy = 'copy' + (i > 1 ? ' ' + i : '')\n    validName = `${nameWithoutCopySuffix} (${copy})`\n    i++\n  }\n\n  return validName\n}\n\n/**\n * Transform a text into lower case with the first character upper case\n */\nexport function toCapital(text: string): string {\n  return text && text.length > 0 ? text[0].toUpperCase() + text.substring(1).toLowerCase() : text\n}\n\nexport function compareStrings(a: string, b: string): -1 | 0 | 1 {\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\n/**\n * Duplicate a piece of text\n */\nexport function duplicateInText(text: string, anchorOffset: number, focusOffset: number): string {\n  const startOffset = Math.min(anchorOffset, focusOffset)\n  const endOffset = Math.max(anchorOffset, focusOffset)\n\n  return (\n    text.slice(0, endOffset) +\n    text.slice(startOffset, endOffset) + // the duplicated piece of the text\n    text.slice(endOffset)\n  )\n}\n\n/**\n * Truncate a text to a maximum length.\n * When truncated, the text will pe appended with ellipsis '...'\n * @param text Text to be truncated\n * @param maxLength Maximum allowed length for the text including ellipsis\n */\nexport function truncate(text: string, maxLength: number): string {\n  const ellipsis = '...'\n  const maxTextLength = maxLength - ellipsis.length\n\n  return text.length > maxLength ? text.substring(0, maxTextLength) + ellipsis : text\n}\n\n/**\n * Cast contents of a string to the correct type.\n * This can be a string, a number, a boolean, null, undefined, etc\n * @param str\n * @return parsed string\n */\nexport function parseString(str: string): string | number | boolean | null | undefined {\n  if (str === '') {\n    return ''\n  }\n\n  const lower = str.toLowerCase()\n  if (lower === 'null') {\n    return null\n  }\n  if (lower === 'true') {\n    return true\n  }\n  if (lower === 'false') {\n    return false\n  }\n  if (lower === 'undefined') {\n    return undefined\n  }\n\n  const num = Number(str) // will nicely fail with '123ab'\n  const numFloat = parseFloat(str) // will nicely fail with '  '\n  if (!isNaN(num) && !isNaN(numFloat)) {\n    return num\n  }\n\n  return str\n}\n","import { jsonquery, type JSONQuery, parse, stringify } from '@jsonquerylang/jsonquery'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jsonquerylang.org\" target=\"_blank\" \n  rel=\"noopener noreferrer\">JSON Query</a> function to filter, sort, or transform the data.\n  You can use functions like <code>get</code>, <code>filter</code>,\n  <code>sort</code>, <code>pick</code>, <code>groupBy</code>, <code>uniq</code>, etcetera. \n  Example query: <code>filter(.age >= 18)</code>\n</p>\n`\n\nexport const jsonQueryLanguage: QueryLanguage = {\n  id: 'jsonquery',\n  name: 'JSONQuery',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryFunctions: JSONQuery[] = []\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    queryFunctions.push([\n      'filter',\n      [\n        getOperatorName(filter.relation),\n        getter(filter.path),\n        parseString(filter.value) as JSONQuery\n      ]\n    ])\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryFunctions.push(['sort', getter(sort.path), sort.direction === 'desc' ? 'desc' : 'asc'])\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      queryFunctions.push(['pick', ...projection.paths.map(getter)])\n    } else {\n      queryFunctions.push(['map', getter(projection.paths[0])])\n    }\n  }\n\n  return stringify(['pipe', ...queryFunctions])\n}\n\nfunction getter(path: JSONPath): ['get', ...path: JSONPath] {\n  return ['get', ...path]\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  return query.trim() !== '' ? jsonquery(json, query) : json\n}\n\nfunction getOperatorName(operator: string): string {\n  // a trick to get the name of the operator by parsing the operator in a temporary query\n  return (parse(`1 ${operator} 1`) as [string, number, number])[0]\n}\n","<g>\n  {@html raw}\n</g>\n\n<script lang=\"ts\">\n  import type { IconData } from '../Icon.svelte';\n\n  let cursor = 0xd4937;\n  function getId() {\n    cursor += 1;\n    return `fa-${cursor.toString(16)}`;\n  }\n\n  let raw = '';\n\n  export let data: IconData;\n\n  function getRaw(data: IconData) {\n    if (!data || !data.raw) {\n      return '';\n    }\n    let rawData = data.raw;\n    const ids: Record<string, string> = {};\n    rawData = rawData.replace(/\\s(?:xml:)?id=[\"']?([^\"')\\s]+)/g, (match, id) => {\n      const uniqueId = getId();\n      ids[id] = uniqueId;\n      return ` id=\"${uniqueId}\"`;\n    });\n\n    rawData = rawData.replace(\n      /#(?:([^'\")\\s]+)|xpointer\\(id\\((['\"]?)([^')]+)\\2\\)\\))/g,\n      (match, rawId, _, pointerId) => {\n        const id = rawId || pointerId;\n        if (!id || !ids[id]) {\n          return match;\n        }\n        return `#${ids[id]}`;\n      }\n    );\n    return rawData;\n  }\n\n  $: raw = getRaw(data);\n</script>\n","<svg\n  version=\"1.1\"\n  class=\"fa-icon {className}\"\n  class:fa-spin={spin}\n  class:fa-pulse={pulse}\n  class:fa-inverse={inverse}\n  class:fa-flip-horizontal={flip === 'horizontal'}\n  class:fa-flip-vertical={flip === 'vertical'}\n  {width}\n  {height}\n  aria-label={label}\n  role={label ? 'img' : 'presentation'}\n  viewBox={box}\n  {style}\n  {...$$restProps}\n>\n  <slot />\n</svg>\n\n<style>\n  .fa-icon {\n    display: inline-block;\n    fill: currentColor;\n  }\n  .fa-flip-horizontal {\n    transform: scale(-1, 1);\n  }\n  .fa-flip-vertical {\n    transform: scale(1, -1);\n  }\n  .fa-spin {\n    animation: fa-spin 1s 0s infinite linear;\n  }\n  .fa-inverse {\n    color: #fff;\n  }\n  .fa-pulse {\n    animation: fa-spin 1s infinite steps(8);\n  }\n  @keyframes fa-spin {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n\n<script lang=\"ts\">\n  let className: string = '';\n\n  export { className as class };\n\n  export let width: number;\n  export let height: number;\n  export let box: string = '0 0 0 0';\n\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: string = 'none';\n\n  // optionals\n  export let style: string = '';\n  export let label: string = '';\n</script>\n","<Svg\n  {label}\n  {width}\n  {height}\n  {box}\n  style={combinedStyle}\n  {spin}\n  {flip}\n  {inverse}\n  {pulse}\n  class={className}\n  {...$$restProps}\n>\n  <slot>\n    {#each iconData?.paths || [] as path}\n      <path {...path} />\n    {/each}\n    {#each iconData?.polygons || [] as polygon}\n      <polygon {...polygon} />\n    {/each}\n    {#if iconData?.raw}\n      <Raw bind:data={iconData} />\n    {/if}\n  </slot>\n</Svg>\n\n<script context=\"module\" lang=\"ts\">\n  export interface FaIconDefinition {\n    prefix: string;\n    iconName: string;\n    icon: [\n      number, // width\n      number, // height\n      string[], // ligatures\n      string, // unicode\n      string | string[] // svgPathData\n    ];\n  }\n\n  export interface IconPath {\n    id?: string;\n    d: string;\n    style?: string;\n    stroke?: string;\n  }\n\n  export interface IconPolygon {\n    points: string;\n    style?: string;\n  }\n\n  export interface IconData {\n    width: number;\n    height: number;\n    paths?: IconPath[];\n    polygons?: IconPolygon[];\n    raw?: string;\n  }\n\n  export type IconType = Record<string, IconData> | FaIconDefinition;\n</script>\n\n<script lang=\"ts\">\n  import Raw from './svg/Raw.svelte';\n  import Svg from './svg/Svg.svelte';\n\n  let className = '';\n\n  export let data: IconType;\n  let iconData: IconData | undefined;\n  export let scale = 1;\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: 'horizontal' | 'vertical' | undefined = undefined;\n  export let label: string = '';\n  export let style: string = '';\n  export { className as class };\n\n  // internal\n  let childrenHeight = 0;\n  let childrenWidth = 0;\n  let outerScale = 1;\n\n  let width: number = 10;\n  let height: number = 10;\n  let combinedStyle: string;\n  let box: string;\n\n  function normaliseData(data: IconType): IconData | undefined {\n    let name: string;\n    let iconData: IconData;\n    if (!data) {\n      return undefined;\n    } else if ('definition' in data) {\n      console.error(\n        \"`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead\"\n      );\n      return undefined;\n    } else if ('iconName' in data && 'icon' in data) {\n      name = data.iconName as string;\n      // fontawesome v5/6 icon imported with:\n      // import { iconName } from '@fortawesome/packagename/iconName';\n      // import { iconName } from '@fortawesome/packagename';\n      const [width, height, , , path] = data.icon as Exclude<IconType['icon'], IconData>;\n      const paths = Array.isArray(path) ? path : [path];\n      iconData = {\n        width,\n        height,\n        paths: paths.map((path) => {\n          return { d: path };\n        })\n      };\n    } else {\n      // inbuilt icons\n      name = Object.keys(data)[0];\n      iconData = data[name];\n    }\n    return iconData;\n  }\n\n  function normalisedScale() {\n    let numScale = 1;\n    if (typeof scale !== 'undefined') {\n      numScale = Number(scale);\n    }\n    if (isNaN(numScale) || numScale <= 0) {\n      console.warn('Invalid prop: prop \"scale\" should be a number over 0.');\n      return outerScale;\n    }\n    return numScale * outerScale;\n  }\n\n  function calculateBox() {\n    if (iconData) {\n      return `0 0 ${iconData.width} ${iconData.height}`;\n    }\n    return `0 0 ${width} ${height}`;\n  }\n\n  function calculateRatio() {\n    if (!iconData) {\n      return 1;\n    }\n    return Math.max(iconData.width, iconData.height) / 16;\n  }\n\n  function calculateWidth() {\n    if (childrenWidth) {\n      return childrenWidth;\n    }\n    if (iconData) {\n      return (iconData.width / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateHeight() {\n    if (childrenHeight) {\n      return childrenHeight;\n    }\n    if (iconData) {\n      return (iconData.height / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateStyle() {\n    let combined = '';\n    if (style !== null) {\n      combined += style;\n    }\n    let size = normalisedScale();\n    if (size === 1) {\n      if (combined.length === 0) {\n        return '';\n      }\n      return combined;\n    }\n    if (combined !== '' && !combined.endsWith(';')) {\n      combined += '; ';\n    }\n    return `${combined}font-size: ${size}em`;\n  }\n\n  $: {\n    iconData = normaliseData(data);\n    style;\n    scale;\n    width = calculateWidth();\n    height = calculateHeight();\n    combinedStyle = calculateStyle();\n    box = calculateBox();\n  }\n</script>\n\n<svelte:options namespace=\"svg\" />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import Icon from 'svelte-awesome'\n  import type { OnPatch } from '$lib/types.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  function toggleBooleanValue(event: MouseEvent) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: !value\n      }\n    ])\n\n    focus()\n  }\n</script>\n\n<div\n  role=\"checkbox\"\n  tabindex=\"-1\"\n  aria-checked={value === true}\n  class=\"jse-boolean-toggle\"\n  class:jse-readonly={readOnly}\n  on:mousedown={toggleBooleanValue}\n  title={!readOnly ? 'Click to toggle this boolean value' : `Boolean value ${value}`}\n>\n  <Icon data={value === true ? faCheckSquare : faSquare} />\n</div>\n\n<style src=\"./BooleanToggle.scss\"></style>\n","<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n\n  export let color: string\n  export let onChange: (newColor: string) => void\n  export let showOnTop: boolean\n\n  let ref: HTMLElement | undefined\n  let destroyColorPicker = () => {}\n\n  onMount(async () => {\n    // Dynamically import VanillaPicker, because it requires `document` to be defined,\n    // and that is not supported server side\n    const VanillaPicker = (await import('vanilla-picker'))?.default\n\n    const colorPicker = new VanillaPicker({\n      parent: ref,\n      color,\n      popup: showOnTop ? 'top' : 'bottom',\n      onDone: function (color) {\n        const alpha = color.rgba[3]\n        const hex =\n          alpha === 1\n            ? color.hex.substring(0, 7) // return #RRGGBB\n            : color.hex // return #RRGGBBAA\n        onChange(hex)\n      }\n    })\n\n    colorPicker.show()\n\n    destroyColorPicker = () => {\n      colorPicker.destroy()\n    }\n  })\n\n  onDestroy(() => {\n    destroyColorPicker()\n  })\n</script>\n\n<div class=\"jse-color-picker-popup\" bind:this={ref}></div>\n\n<style src=\"./ColorPickerPopup.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getColorCSS } from '$lib/utils/typeUtils.js'\n  import { getWindow } from '$lib/utils/domUtils.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getContext } from 'svelte'\n  import ColorPickerPopup from '../../../components/controls/ColorPickerPopup.svelte'\n  import type { AbsolutePopupContext, OnPatch } from '$lib/types.js'\n\n  const { openAbsolutePopup } = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let value: string\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  $: color = getColorCSS(value)\n  $: title = !readOnly ? 'Click to open a color picker' : `Color ${value}`\n\n  function onChange(color: string) {\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: color\n      }\n    ])\n\n    onClose()\n  }\n\n  function onClose() {\n    focus()\n  }\n\n  function openColorPicker(event: MouseEvent) {\n    if (readOnly) {\n      return\n    }\n\n    // estimate of the color picker height\n    // we'll render the color picker on top\n    // when there is not enough space below, and there is enough space above\n    const height = 300\n\n    const target = event.target as Element\n    const top = target.getBoundingClientRect().top\n    const windowHeight = getWindow(target)?.innerHeight ?? 0\n    const showOnTop = windowHeight - top < height && top > height\n\n    const props = {\n      color: value,\n      onChange,\n      showOnTop\n    }\n\n    openAbsolutePopup(ColorPickerPopup, props, {\n      anchor: target,\n      closeOnOuterClick: true,\n      onClose,\n      offsetTop: 18,\n      offsetLeft: -8,\n      height\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-color-picker-button\"\n  class:jse-readonly={readOnly}\n  style=\"background: {color}\"\n  {title}\n  aria-label={title}\n  on:click={openColorPicker}\n></button>\n\n<style src=\"./ColorPicker.scss\"></style>\n","import type { Section } from './types'\nimport { SortDirection } from './types.js'\n\nexport const SCROLL_DURATION = 300 // ms\nexport const DEBOUNCE_DELAY = 300 // ms\nexport const TEXT_MODE_ONCHANGE_DELAY = 300 // ms\nexport const AUTO_SCROLL_INTERVAL = 50 // ms\nexport const AUTO_SCROLL_SPEED_SLOW = 200 // pixels per second\nexport const AUTO_SCROLL_SPEED_NORMAL = 400 // pixels per second\nexport const AUTO_SCROLL_SPEED_FAST = 1200 // pixels per second\nexport const MAX_SEARCH_RESULTS = 1000\nexport const ARRAY_SECTION_SIZE = 100\nexport const MAX_VALIDATION_ERRORS = 100\nexport const MAX_CHARACTERS_TEXT_PREVIEW = 20000\nexport const MAX_INLINE_OBJECT_CHARS = 50\nexport const MAX_HEADER_NAME_CHARACTERS = 50\nexport const DEFAULT_VISIBLE_SECTIONS: Section[] = [{ start: 0, end: ARRAY_SECTION_SIZE }]\nexport const MAX_VALIDATABLE_SIZE = 100 * 1024 * 1024 // 1 MB\nexport const MAX_AUTO_REPAIRABLE_SIZE = 1024 * 1024 // 1 MB\nexport const MAX_DOCUMENT_SIZE_TEXT_MODE = 10 * 1024 * 1024 // 10 MB\nexport const MAX_DOCUMENT_SIZE_EXPAND_ALL = 10 * 1024 // 10 KB\n\nexport const INSERT_EXPLANATION =\n  'Insert or paste contents, ' +\n  'enter [ insert a new array, ' +\n  'enter { to insert a new object, ' +\n  'or start typing to insert a new value'\n\nexport const CONTEXT_MENU_EXPLANATION =\n  'Open context menu ' +\n  '(Click here, ' +\n  'right click on the selection, ' +\n  'or use the context menu button or Ctrl+Q)'\n\nexport const HOVER_INSERT_INSIDE = 'hover-insert-inside'\nexport const HOVER_INSERT_AFTER = 'hover-insert-after'\nexport const HOVER_COLLECTION = 'hover-collection'\n\nexport const JSON_STATUS_VALID = 'valid'\nexport const JSON_STATUS_REPAIRABLE = 'repairable'\nexport const JSON_STATUS_INVALID = 'invalid'\n\n// TODO: can we dynamically calculate the size?\nexport const CONTEXT_MENU_HEIGHT = (40 + 2) * 8 // px\nexport const CONTEXT_MENU_WIDTH = 260 // px\nexport const SEARCH_BOX_HEIGHT = 100 // px for search and replace\n\nexport const SORT_DIRECTION_NAMES = {\n  [SortDirection.asc]: 'ascending',\n  [SortDirection.desc]: 'descending'\n}\n","import { sortBy } from 'lodash-es'\nimport { ARRAY_SECTION_SIZE } from '../constants.js'\nimport type { Section } from '$lib/types.js'\n\n/**\n * Create sections that can be expanded.\n * Used to display a button like \"Show items 100-200\"\n */\nexport function getExpandItemsSections(startIndex: number, endIndex: number): Section[] {\n  // expand the start of the section\n  const section1 = {\n    start: startIndex,\n    end: Math.min(nextRoundNumber(startIndex), endIndex)\n  }\n\n  // expand the middle of the section\n  const start2 = Math.max(currentRoundNumber((startIndex + endIndex) / 2), startIndex)\n  const section2 = {\n    start: start2,\n    end: Math.min(nextRoundNumber(start2), endIndex)\n  }\n\n  // expand the end of the section\n  const currentIndex = currentRoundNumber(endIndex)\n  const previousIndex = currentIndex === endIndex ? currentIndex - ARRAY_SECTION_SIZE : currentIndex\n  const section3 = {\n    start: Math.max(previousIndex, startIndex),\n    end: endIndex\n  }\n\n  const sections = [section1]\n\n  const showSection2 = section2.start >= section1.end && section2.end <= section3.start\n  if (showSection2) {\n    sections.push(section2)\n  }\n\n  const showSection3 = section3.start >= (showSection2 ? section2.end : section1.end)\n  if (showSection3) {\n    sections.push(section3)\n  }\n\n  return sections\n}\n\n/**\n * Sort and merge a list with sections\n */\nexport function mergeSections(sections: Section[]): Section[] {\n  const sortedSections = sortBy(sections, (section) => section.start)\n\n  const mergedSections = [sortedSections[0]]\n\n  for (let sortedIndex = 0; sortedIndex < sortedSections.length; sortedIndex++) {\n    const mergedIndex = mergedSections.length - 1\n    const previous = mergedSections[mergedIndex]\n    const current = sortedSections[sortedIndex]\n\n    if (current.start <= previous.end) {\n      // there is overlap -> replace the previous item\n      mergedSections[mergedIndex] = {\n        start: Math.min(previous.start, current.start),\n        end: Math.max(previous.end, current.end)\n      }\n    } else {\n      // no overlap, just add the item\n      mergedSections.push(current)\n    }\n  }\n\n  return mergedSections\n}\n\n// TODO: write unit test\nexport function inVisibleSection(sections: Section[], index: number): boolean {\n  return sections.some((section) => {\n    return index >= section.start && index < section.end\n  })\n}\n\nexport function nextRoundNumber(index: number): number {\n  return currentRoundNumber(index) + ARRAY_SECTION_SIZE\n}\n\nexport function currentRoundNumber(index: number): number {\n  return Math.floor(index / ARRAY_SECTION_SIZE) * ARRAY_SECTION_SIZE\n}\n","import type {\n  ContentParseError,\n  ContentValidationErrors,\n  ContextMenuColumn,\n  ContextMenuRow,\n  MenuButton,\n  MenuDropDownButton,\n  MenuLabel,\n  MenuSeparator,\n  MenuSpace,\n  ValidationError,\n  NestedValidationError,\n  SvelteActionRenderer,\n  SvelteComponentRenderer,\n  RecursiveState,\n  ArrayRecursiveState,\n  ObjectRecursiveState,\n  ValueRecursiveState,\n  SearchResults,\n  WithSearchResults\n} from './types.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\nexport function isMenuSpace(item: unknown): item is MenuSpace {\n  // checking the .space property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'space' || item['space'] === true : false\n}\n\nexport function isMenuSeparator(item: unknown): item is MenuSeparator {\n  // checking the .separator property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'separator' || item['separator'] === true : false\n}\n\nexport function isMenuLabel(item: unknown): item is MenuLabel {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'label' && typeof item['text'] === 'string' : false\n}\n\nexport function isMenuButton(item: unknown): item is MenuButton {\n  // for backward compatibility, we only check .onClick here and not item['type'] === 'button'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? typeof item['onClick'] === 'function' : false\n}\n\nexport function isMenuDropDownButton(item: unknown): item is MenuDropDownButton {\n  return item\n    ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      item['type'] === 'dropdown-button' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        isMenuButton(item['main']) &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        Array.isArray(item['items'])\n    : false\n}\n\nexport function isContextMenuRow(item: unknown): item is ContextMenuRow {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'row' && Array.isArray(item['items']) : false\n}\n\nexport function isContextMenuColumn(item: unknown): item is ContextMenuColumn {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'column' && Array.isArray(item['items']) : false\n}\n\nexport function isContentParseError(contentErrors: unknown): contentErrors is ContentParseError {\n  return isObject(contentErrors) && isObject(contentErrors['parseError'])\n}\n\nexport function isContentValidationErrors(\n  contentErrors: unknown\n): contentErrors is ContentValidationErrors {\n  return isObject(contentErrors) && Array.isArray(contentErrors['validationErrors'])\n}\n\nexport function isValidationError(value: unknown): value is ValidationError {\n  return (\n    isObject(value) &&\n    Array.isArray(value.path) &&\n    typeof value.message === 'string' &&\n    'severity' in value\n  )\n}\n\nexport function isNestedValidationError(value: unknown): value is NestedValidationError {\n  return isObject(value) && isValidationError(value) && typeof value.isChildError === 'boolean'\n}\n\nexport function isSvelteComponentRenderer(value: unknown): value is SvelteComponentRenderer {\n  return isObject(value) && 'component' in value && isObject(value.props)\n}\n\nexport function isSvelteActionRenderer(value: unknown): value is SvelteActionRenderer {\n  return isObject(value) && typeof value.action === 'function' && isObject(value.props)\n}\n\nexport function isObjectRecursiveState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState {\n  return state !== undefined && state.type === 'object'\n}\n\nexport function isArrayRecursiveState(\n  state: RecursiveState | undefined\n): state is ArrayRecursiveState {\n  return state !== undefined && state.type === 'array'\n}\n\nexport function isValueRecursiveState(\n  state: RecursiveState | undefined\n): state is ValueRecursiveState {\n  return state !== undefined && state.type === 'value'\n}\n\nexport function isExpandableState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState | ArrayRecursiveState {\n  return isObjectRecursiveState(state) || isArrayRecursiveState(state)\n}\n\nexport function hasSearchResults(state: SearchResults | undefined): state is WithSearchResults {\n  return (\n    state !== undefined &&\n    Array.isArray((state as unknown as Record<string, unknown>).searchResults)\n  )\n}\n","import {\n  compileJSONPointer,\n  deleteIn,\n  existsIn,\n  getIn,\n  immutableJSONPatch,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchMove,\n  type JSONPatchOperation,\n  type JSONPatchRemove,\n  type JSONPath,\n  parsePath,\n  setIn,\n  updateIn\n} from 'immutable-json-patch'\nimport { initial, last } from 'lodash-es'\nimport { DEFAULT_VISIBLE_SECTIONS, MAX_DOCUMENT_SIZE_EXPAND_ALL } from '../constants.js'\nimport { forEachIndex, insertItemsAt, strictShallowEqual } from '../utils/arrayUtils.js'\nimport { isObject, isStringContainingPrimitiveValue } from '../utils/typeUtils.js'\nimport {\n  currentRoundNumber,\n  inVisibleSection,\n  mergeSections,\n  nextRoundNumber\n} from './expandItemsSections.js'\nimport type {\n  ArrayDocumentState,\n  CaretPosition,\n  DocumentState,\n  ObjectDocumentState,\n  OnExpand,\n  ArrayRecursiveState,\n  RecursiveState,\n  RecursiveStateFactory,\n  Section,\n  ValueDocumentState,\n  VisibleSection\n} from '$lib/types'\nimport { CaretType } from '$lib/types.js'\nimport { int } from '../utils/numberUtils.js'\nimport { isLargeContent } from '$lib/utils/jsonUtils.js'\nimport {\n  isArrayRecursiveState,\n  isExpandableState,\n  isObjectRecursiveState,\n  isValueRecursiveState\n} from '$lib/typeguards.js'\n\nexport type CreateRecursiveStateProps = {\n  json: unknown | undefined\n  factory: RecursiveStateFactory\n}\n\nexport function createRecursiveState({\n  json,\n  factory\n}: CreateRecursiveStateProps): RecursiveState | undefined {\n  return Array.isArray(json)\n    ? factory.createArrayDocumentState()\n    : isObject(json)\n      ? factory.createObjectDocumentState()\n      : json !== undefined\n        ? factory.createValueDocumentState()\n        : undefined\n}\n\nexport type CreateDocumentStateProps = {\n  json: unknown | undefined\n  expand?: OnExpand\n}\n\nexport function createDocumentState({\n  json,\n  expand\n}: CreateDocumentStateProps): DocumentState | undefined {\n  let documentState: DocumentState | undefined = createRecursiveState({\n    json,\n    factory: documentStateFactory\n  }) as DocumentState\n\n  if (expand && documentState) {\n    documentState = expandPath(json, documentState, [], expand)\n  }\n\n  return documentState\n}\n\nexport function createArrayDocumentState({ expanded } = { expanded: false }): ArrayDocumentState {\n  return { type: 'array', expanded, visibleSections: DEFAULT_VISIBLE_SECTIONS, items: [] }\n}\n\nexport function createObjectDocumentState({ expanded } = { expanded: false }): ObjectDocumentState {\n  return { type: 'object', expanded, properties: {} }\n}\n\nexport function createValueDocumentState(): ValueDocumentState {\n  return { type: 'value' }\n}\n\nexport const documentStateFactory: RecursiveStateFactory = {\n  createObjectDocumentState,\n  createArrayDocumentState,\n  createValueDocumentState\n}\n\nexport function ensureRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  {\n    createObjectDocumentState,\n    createArrayDocumentState,\n    createValueDocumentState\n  }: RecursiveStateFactory\n): T {\n  function recurse(value: unknown, state: T | undefined, path: JSONPath): T {\n    if (Array.isArray(value)) {\n      const arrayState: ArrayRecursiveState = isArrayRecursiveState(state)\n        ? state\n        : createArrayDocumentState()\n      if (path.length === 0) {\n        return arrayState as T\n      }\n\n      const index = int(path[0])\n      const itemState = recurse(value[index], arrayState.items[index] as T, path.slice(1))\n      return setIn(arrayState, ['items', path[0]], itemState)\n    }\n\n    if (isObject(value)) {\n      const objectState = isObjectRecursiveState(state) ? state : createObjectDocumentState()\n      if (path.length === 0) {\n        return objectState as T\n      }\n\n      const key = path[0]\n      const itemState = recurse(value[key], objectState.properties[key] as T, path.slice(1))\n      return setIn(objectState, ['properties', key], itemState)\n    }\n\n    return isValueRecursiveState(state) ? state : (createValueDocumentState() as T)\n  }\n\n  return recurse(json, documentState, path)\n}\n\nexport function syncDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath = []\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState) => {\n      if (nestedJson === undefined || nestedState === undefined) {\n        return undefined\n      }\n\n      if (Array.isArray(nestedJson)) {\n        if (isArrayRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createArrayDocumentState({ expanded })\n      }\n\n      if (isObject(nestedJson)) {\n        if (isObjectRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createObjectDocumentState({ expanded })\n      }\n\n      // json is of type value\n      if (isValueRecursiveState(nestedState)) {\n        return nestedState\n      }\n\n      // type of state does not match the actual type of the json\n      return undefined\n    },\n    () => true\n  )\n}\n\nfunction _transformDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: (\n    nestedJson: unknown,\n    nestedState: DocumentState | undefined,\n    path: JSONPath\n  ) => DocumentState | undefined,\n  recurse: (nestedState: DocumentState | undefined) => boolean\n): DocumentState | undefined {\n  const updatedState = callback(json, documentState, path)\n\n  if (Array.isArray(json) && isArrayRecursiveState(updatedState) && recurse(updatedState)) {\n    const items: (DocumentState | undefined)[] = []\n\n    forEachVisibleIndex(json, updatedState.visibleSections, (index) => {\n      const itemPath = path.concat(String(index))\n      const value = json[index]\n      const item = updatedState.items[index]\n      const updatedItem = _transformDocumentState(value, item, itemPath, callback, recurse)\n      if (updatedItem !== undefined) {\n        items[index] = updatedItem\n      }\n    })\n\n    const changed = !strictShallowEqual(items, updatedState.items)\n\n    return changed ? { ...updatedState, items } : updatedState\n  }\n\n  if (isObject(json) && isObjectRecursiveState(updatedState) && recurse(updatedState)) {\n    const properties: ObjectDocumentState['properties'] = {}\n    Object.keys(json).forEach((key) => {\n      const propPath = path.concat(key)\n      const value = json[key]\n      const prop = updatedState.properties[key]\n      const updatedProp = _transformDocumentState(value, prop, propPath, callback, recurse)\n      if (updatedProp !== undefined) {\n        properties[key] = updatedProp\n      }\n    })\n\n    const changed = !strictShallowEqual(\n      Object.values(properties),\n      Object.values(updatedState.properties)\n    )\n\n    return changed ? { ...updatedState, properties } : updatedState\n  }\n\n  return updatedState\n}\n\n/**\n * Invoke a callback function for every visible item in the array\n */\nexport function forEachVisibleIndex(\n  jsonArray: Array<unknown>,\n  visibleSections: VisibleSection[],\n  callback: (index: number) => void\n) {\n  visibleSections.forEach(({ start, end }) => {\n    forEachIndex(start, Math.min(jsonArray.length, end), callback)\n  })\n}\n\nexport function expandVisibleSection(state: ArrayDocumentState, index: number): ArrayDocumentState {\n  if (inVisibleSection(state.visibleSections, index)) {\n    return state\n  }\n\n  const start = currentRoundNumber(index)\n  const end = nextRoundNumber(start)\n  const newVisibleSection = { start, end }\n\n  return {\n    ...state,\n    visibleSections: mergeSections(state.visibleSections.concat(newVisibleSection))\n  }\n}\n\nexport function toRecursiveStatePath(json: unknown, path: JSONPath): JSONPath {\n  let value = json\n  const recursiveStatePath: JSONPath = []\n\n  let i = 0\n  while (i < path.length) {\n    if (Array.isArray(value)) {\n      const index = path[i]\n      recursiveStatePath.push('items', index)\n      value = value[int(index)]\n    } else if (isObject(value)) {\n      const key = path[i]\n      recursiveStatePath.push('properties', key)\n      value = (value as Record<string, unknown>)[key]\n    } else {\n      throw new Error(`Cannot convert path: Object or Array expected at index ${i}`)\n    }\n\n    i++\n  }\n\n  return recursiveStatePath\n}\n\n/**\n * Expand all nodes along the given path, and expand invisible array sections if needed.\n * Then, optionally expand child nodes according to the provided callback.\n */\nexport function expandPath(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  let updatedState = documentState\n\n  // Step 1: expand all nodes along the path, and update visibleSections if needed\n  for (let i = 0; i < path.length; i++) {\n    const partialPath = path.slice(0, i)\n\n    updatedState = updateInDocumentState(json, updatedState, partialPath, (_, nestedState) => {\n      const updatedState =\n        isExpandableState(nestedState) && !nestedState.expanded\n          ? { ...nestedState, expanded: true }\n          : nestedState\n\n      if (isArrayRecursiveState(updatedState)) {\n        const index = int(path[i])\n        return expandVisibleSection(updatedState, index)\n      }\n\n      return updatedState\n    })\n  }\n\n  // Step 2: recursively expand child nodes tested with the callback\n  return updateInDocumentState(json, updatedState, path, (nestedValue, nestedState) => {\n    const relativePath: JSONPath = []\n    return _expandRecursively(nestedValue, nestedState, relativePath, callback)\n  })\n}\n\nfunction _expandRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState, nestedPath) => {\n      if (Array.isArray(nestedJson) && callback(nestedPath)) {\n        return isArrayRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createArrayDocumentState({ expanded: true })\n      }\n\n      if (isObject(nestedJson) && callback(nestedPath)) {\n        return isObjectRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createObjectDocumentState({ expanded: true })\n      }\n\n      return nestedState\n    },\n    (nestedState) => isExpandableState(nestedState) && nestedState.expanded\n  )\n}\n\nexport function collapsePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  recursive: boolean\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (nestedJson, nestedState) => {\n    return recursive ? _collapseRecursively(nestedJson, nestedState, path) : _collapse(nestedState)\n  })\n}\n\nfunction _collapse<T extends DocumentState | undefined>(documentState: T): T {\n  if (isArrayRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false, visibleSections: DEFAULT_VISIBLE_SECTIONS }\n  }\n\n  if (isObjectRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false }\n  }\n\n  return documentState\n}\n\nfunction _collapseRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (_, nestedState) => _collapse(nestedState),\n    () => true\n  )\n}\n\n/**\n * Expand a section of items in an array\n */\nexport function expandSection(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  section: Section\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (_value, state) => {\n    if (!isArrayRecursiveState(state)) {\n      return state\n    }\n\n    const visibleSections = mergeSections(state.visibleSections.concat(section))\n\n    return { ...state, visibleSections }\n  })\n}\n\nexport function syncKeys(actualKeys: string[], prevKeys?: string[]): string[] {\n  if (!prevKeys) {\n    return actualKeys\n  }\n\n  // copy the keys that still exist\n  const actualKeysSet = new Set(actualKeys)\n  const keys = prevKeys.filter((key) => actualKeysSet.has(key))\n\n  // add new keys\n  const keysSet = new Set(keys)\n  actualKeys.filter((key) => !keysSet.has(key)).forEach((key) => keys.push(key))\n\n  return keys\n}\n\n/**\n * Apply patch operations to both json and state\n */\nexport function documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operations: JSONPatchDocument\n): { json: unknown; documentState: DocumentState | undefined } {\n  const initial = { json, documentState }\n\n  const result = operations.reduce((current, operation) => {\n    return {\n      json: immutableJSONPatch(current.json, [operation]),\n      documentState: _documentStatePatch(current.json, current.documentState, operation)\n    }\n  }, initial)\n\n  return {\n    json: result.json,\n    documentState: syncDocumentState(result.json, result.documentState) // sync to clean up leftover state\n  }\n}\n\nfunction _documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchOperation\n): DocumentState | undefined {\n  if (isJSONPatchAdd(operation)) {\n    return documentStateAdd(json, documentState, operation, undefined)\n  }\n\n  if (isJSONPatchRemove(operation)) {\n    return documentStateRemove(json, documentState, operation)\n  }\n\n  if (isJSONPatchReplace(operation)) {\n    const path = parsePath(json, operation.path)\n    const enforceString = getEnforceString(json, documentState, path)\n    if (enforceString) {\n      // ensure the enforceString setting is not lost when for example changing \"123\"\n      // into \"abc\" and later back to \"123\", so we now make it explicit.\n      return setInDocumentState(json, documentState, path, { type: 'value', enforceString })\n    }\n\n    // nothing special to do (all is handled by syncDocumentState)\n    return documentState\n  }\n\n  if (isJSONPatchCopy(operation) || isJSONPatchMove(operation)) {\n    return documentStateMoveOrCopy(json, documentState, operation)\n  }\n\n  return documentState\n}\n\nexport function getInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  try {\n    return getIn(documentState, toRecursiveStatePath(json, path))\n  } catch {\n    return undefined\n  }\n}\n\nexport function setInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  recursiveState: T | undefined,\n  path: JSONPath,\n  value: unknown,\n  factory: RecursiveStateFactory\n): T | undefined {\n  const ensuredState = ensureRecursiveState(json, recursiveState, path, factory)\n  return setIn(ensuredState, toRecursiveStatePath(json, path), value)\n}\n\nexport function updateInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined,\n  factory: RecursiveStateFactory\n): T {\n  const ensuredState: T = ensureRecursiveState(json, documentState, path, factory)\n  return updateIn(ensuredState, toRecursiveStatePath(json, path), (nestedState: T) => {\n    const value = getIn(json, path)\n    return transform(value, nestedState)\n  })\n}\n\nexport function setInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  value: unknown\n): T | undefined {\n  return setInRecursiveState(json, documentState, path, value, documentStateFactory)\n}\n\nexport function updateInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined\n): T {\n  return updateInRecursiveState(json, documentState, path, transform, documentStateFactory)\n}\n\nexport function deleteInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  const recursivePath = toRecursiveStatePath(json, path)\n\n  return existsIn(documentState, recursivePath)\n    ? deleteIn(documentState, toRecursiveStatePath(json, path))\n    : documentState\n}\n\nexport function documentStateAdd(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchAdd,\n  stateValue: DocumentState | undefined\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n\n  let updatedState = documentState\n\n  updatedState = updateInDocumentState(json, updatedState, parentPath, (_parent, arrayState) => {\n    if (!isArrayRecursiveState(arrayState)) {\n      return arrayState\n    }\n\n    const index = int(last(path) as string)\n    const { items, visibleSections } = arrayState\n    return {\n      ...arrayState,\n      items:\n        index < items.length\n          ? insertItemsAt(items, index, stateValue !== undefined ? [stateValue] : Array(1))\n          : items,\n      visibleSections: shiftVisibleSections(visibleSections, index, 1)\n    }\n  })\n\n  // object property added, nothing to do\n  return setInDocumentState(json, updatedState, path, stateValue)\n}\n\nexport function documentStateRemove(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchRemove\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (Array.isArray(parent)) {\n    return updateInDocumentState(json, documentState, parentPath, (_parent, arrayState) => {\n      if (!isArrayRecursiveState(arrayState)) {\n        return arrayState\n      }\n\n      const index = int(last(path) as string)\n      const { items, visibleSections } = arrayState\n\n      return {\n        ...arrayState,\n        items: items.slice(0, index).concat(items.slice(index + 1)),\n        visibleSections: shiftVisibleSections(visibleSections, index, -1)\n      }\n    })\n  }\n\n  return deleteInDocumentState(json, documentState, path)\n}\n\nexport function documentStateMoveOrCopy(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchCopy | JSONPatchMove\n): DocumentState | undefined {\n  if (isJSONPatchMove(operation) && operation.from === operation.path) {\n    // nothing to do\n    return documentState\n  }\n\n  let updatedState = documentState\n\n  // get the state that we will move or copy\n  const from = parsePath(json, operation.from)\n  const stateValue = getInRecursiveState(json, updatedState, from)\n\n  if (isJSONPatchMove(operation)) {\n    updatedState = documentStateRemove(json, updatedState, {\n      op: 'remove',\n      path: operation.from\n    })\n  }\n\n  updatedState = documentStateAdd(\n    json,\n    updatedState,\n    {\n      op: 'add',\n      path: operation.path,\n      value: null // note that the value is not actually used, so we just use null instead of getting the actual value from the json\n    },\n    stateValue\n  )\n\n  return updatedState\n}\n\n/**\n * Shift visible sections in an Array with a specified offset\n */\nexport function shiftVisibleSections(\n  visibleSections: VisibleSection[],\n  index: number,\n  offset: number\n): VisibleSection[] {\n  const shiftedSections = visibleSections.map((section) => {\n    return {\n      start: section.start > index ? section.start + offset : section.start,\n      end: section.end > index ? section.end + offset : section.end\n    }\n  })\n\n  return mergeAdjacentSections(shiftedSections)\n}\n\n// merge adjacent sections like [{start:0, end:100}, {start:100, end:200}] into [{start:0, end:200}]\nfunction mergeAdjacentSections(visibleSections: VisibleSection[]): VisibleSection[] {\n  const merged = visibleSections.slice(0)\n\n  let i = 1\n  while (i < merged.length) {\n    if (merged[i - 1].end === merged[i].start) {\n      merged[i - 1] = {\n        start: merged[i - 1].start,\n        end: merged[i].end\n      }\n      merged.splice(i)\n    }\n    i++\n  }\n\n  return merged\n}\n\nexport function getEnforceString(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): boolean {\n  const value = getIn(json, path)\n  const nestedState = getInRecursiveState(json, documentState, path)\n  const enforceString = isValueRecursiveState(nestedState) ? nestedState.enforceString : undefined\n\n  if (typeof enforceString === 'boolean') {\n    return enforceString\n  }\n\n  return isStringContainingPrimitiveValue(value)\n}\n\nexport function getNextKeys(keys: string[], key: string, includeKey = false): string[] {\n  const index = keys.indexOf(key)\n  if (index !== -1) {\n    return includeKey ? keys.slice(index) : keys.slice(index + 1)\n  } else {\n    // a new key, that doesn't have next keys\n    return []\n  }\n}\n\n/**\n * Get all paths which are visible and rendered\n */\n// TODO: create memoized version of getVisiblePaths which remembers just the previous result if json and state are the same\nexport function getVisiblePaths(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function _recurse(value: unknown, state: DocumentState | undefined, path: JSONPath) {\n    paths.push(path)\n\n    if (isJSONArray(value) && isArrayRecursiveState(state) && state.expanded) {\n      forEachVisibleIndex(value, state.visibleSections, (index) => {\n        _recurse(value[index], state.items[index], path.concat(String(index)))\n      })\n    }\n\n    if (isJSONObject(value) && isObjectRecursiveState(state) && state.expanded) {\n      Object.keys(value).forEach((key) => {\n        _recurse(value[key], state.properties[key], path.concat(key))\n      })\n    }\n  }\n\n  _recurse(json, documentState, [])\n\n  return paths\n}\n\n/**\n * Get all caret position which are visible and rendered:\n * before a node, at a key, at a value, appending an object/array\n */\n// TODO: create memoized version of getVisibleCaretPositions which remembers just the previous result if json and state are the same\nexport function getVisibleCaretPositions(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  includeInside = true\n): CaretPosition[] {\n  const paths: CaretPosition[] = []\n\n  function _recurse(value: unknown, path: JSONPath) {\n    paths.push({ path, type: CaretType.value })\n\n    const valueState = getInRecursiveState(json, documentState, path)\n    if (value && isExpandableState(valueState) && valueState.expanded) {\n      if (includeInside) {\n        paths.push({ path, type: CaretType.inside })\n      }\n\n      if (isJSONArray(value)) {\n        const visibleSections = isArrayRecursiveState(valueState)\n          ? valueState.visibleSections\n          : DEFAULT_VISIBLE_SECTIONS\n        forEachVisibleIndex(value, visibleSections, (index) => {\n          const itemPath = path.concat(String(index))\n\n          _recurse(value[index], itemPath)\n\n          if (includeInside) {\n            paths.push({ path: itemPath, type: CaretType.after })\n          }\n        })\n      }\n\n      if (isJSONObject(value)) {\n        const keys = Object.keys(value)\n        keys.forEach((key) => {\n          const propertyPath = path.concat(key)\n\n          paths.push({ path: propertyPath, type: CaretType.key })\n\n          _recurse(value[key], propertyPath)\n\n          if (includeInside) {\n            paths.push({ path: propertyPath, type: CaretType.after })\n          }\n        })\n      }\n    }\n  }\n\n  _recurse(json, [])\n\n  return paths\n}\n\n/**\n * Find the previous visible path.\n * This can be the last child of the previous object or array, or the parent of a first entry.\n */\n// TODO: write tests for getPreviousVisiblePath\nexport function getPreviousVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const pathPointer = compileJSONPointer(path)\n  const index = visiblePathPointers.indexOf(pathPointer)\n\n  if (index !== -1 && index > 0) {\n    return visiblePaths[index - 1]\n  }\n\n  return undefined\n}\n\n/**\n * Find the next visible path.\n * This can be the next parent entry.\n */\n// TODO: write tests for getNextVisiblePath\nexport function getNextVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const index = visiblePathPointers.indexOf(compileJSONPointer(path))\n\n  if (index !== -1 && index < visiblePaths.length - 1) {\n    return visiblePaths[index + 1]\n  }\n\n  return undefined\n}\n\n/**\n * Expand recursively when the expanded contents is small enough,\n * else expand in a minimalistic way\n */\nexport function expandSmart(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  maxSize: number = MAX_DOCUMENT_SIZE_EXPAND_ALL\n): DocumentState | undefined {\n  const nestedJson = getIn(json, path)\n  const callback = isLargeContent({ json: nestedJson }, maxSize) ? expandMinimal : expandAll\n\n  return expandPath(json, documentState, path, callback)\n}\n\n/**\n * Expand the root array or object, and in case of an array, expand the first array item\n */\nexport function expandMinimal(relativePath: JSONPath): boolean {\n  // first item of an array\n  return relativePath.length === 0 ? true : relativePath.length === 1 && relativePath[0] === '0'\n}\n\n/**\n * Expand the root array or object\n */\nexport function expandSelf(relativePath: JSONPath): boolean {\n  return relativePath.length === 0\n}\n\nexport function expandAll(): boolean {\n  return true\n}\n\nexport function expandNone(): boolean {\n  return false\n}\n","import {\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport { isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport {\n  collapsePath,\n  getNextVisiblePath,\n  getPreviousVisiblePath,\n  getVisibleCaretPositions,\n  getVisiblePaths\n} from './documentState.js'\nimport type {\n  AfterSelection,\n  CaretPosition,\n  DocumentState,\n  EditKeySelection,\n  EditValueSelection,\n  InsideSelection,\n  JSONEditorSelection,\n  JSONParser,\n  JSONSelection,\n  KeySelection,\n  MultiSelection,\n  TextSelection,\n  ValueSelection\n} from '../types.js'\nimport { CaretType, SelectionType } from '$lib/types.js'\nimport { int } from '$lib/utils/numberUtils.js'\n\nexport function isAfterSelection(\n  selection: JSONEditorSelection | undefined\n): selection is AfterSelection {\n  return (selection && selection.type === SelectionType.after) || false\n}\n\nexport function isInsideSelection(\n  selection: JSONEditorSelection | undefined\n): selection is InsideSelection {\n  return (selection && selection.type === SelectionType.inside) || false\n}\n\nexport function isKeySelection(\n  selection: JSONEditorSelection | undefined\n): selection is KeySelection {\n  return (selection && selection.type === SelectionType.key) || false\n}\n\nexport function isValueSelection(\n  selection: JSONEditorSelection | undefined\n): selection is ValueSelection {\n  return (selection && selection.type === SelectionType.value) || false\n}\n\nexport function isMultiSelection(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return (selection && selection.type === SelectionType.multi) || false\n}\n\nexport function isMultiSelectionWithOneItem(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return isMultiSelection(selection) && isEqual(selection.focusPath, selection.anchorPath)\n}\n\nexport function isJSONSelection(\n  selection: JSONEditorSelection | undefined\n): selection is JSONSelection {\n  return (\n    isMultiSelection(selection) ||\n    isAfterSelection(selection) ||\n    isInsideSelection(selection) ||\n    isKeySelection(selection) ||\n    isValueSelection(selection)\n  )\n}\n\nexport function isTextSelection(\n  selection: JSONEditorSelection | undefined\n): selection is TextSelection {\n  return (selection && selection.type === SelectionType.text) || false\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end\n */\nexport function getSelectionPaths(json: unknown, selection: JSONSelection): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  iterateOverSelection(json, selection, (path) => {\n    paths.push(path)\n  })\n\n  return paths\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end.\n *\n * The function iterates always from start to end, independent of the order\n * of focusPath and anchorPath.\n *\n * When the callback returns something other than undefined, the iteration is\n * canceled and the value returned by the callback is returned by iterateOverSelection.\n */\nexport function iterateOverSelection<T>(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  callback: (path: JSONPath) => void | undefined | T\n): void | undefined | T {\n  if (!selection) {\n    return undefined\n  }\n\n  const anchorPath = getAnchorPath(selection)\n  const focusPath = getFocusPath(selection)\n\n  if (isEqual(anchorPath, focusPath)) {\n    // just a single node\n    return callback(anchorPath)\n  } else {\n    // multiple nodes\n    if (json === undefined) {\n      return undefined\n    }\n\n    const sharedPath = findSharedPath(anchorPath, focusPath)\n\n    if (anchorPath.length === sharedPath.length || focusPath.length === sharedPath.length) {\n      // a parent and a child, like ['arr', 1] and ['arr']\n      return callback(sharedPath)\n    }\n\n    const selection = createMultiSelection(anchorPath, focusPath)\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined\n    }\n\n    const value = getIn(json, sharedPath)\n\n    if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(keys[i]))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n\n    if (isJSONArray(value)) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(String(i)))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n  }\n\n  throw new Error('Failed to create selection')\n}\n\nexport function getParentPath(selection: JSONSelection): JSONPath {\n  if (isInsideSelection(selection)) {\n    return selection.path\n  } else {\n    return initial(getFocusPath(selection))\n  }\n}\n\nexport function getStartPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex < anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\nexport function getEndPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex > anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\n// TODO: write unit test\nexport function isSelectionInsidePath(selection: JSONSelection, path: JSONPath): boolean {\n  return (\n    pathStartsWith(getFocusPath(selection), path) &&\n    (getFocusPath(selection).length > path.length || isInsideSelection(selection))\n  )\n}\n\nexport function getSelectionUp(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getStartPath(json, selection)\n  const previousPath = getPreviousVisiblePath(json, documentState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection) || isAfterSelection(selection)) {\n      return previousPath !== undefined ? createMultiSelection(focusPath, focusPath) : undefined\n    }\n\n    return previousPath !== undefined\n      ? createMultiSelection(getAnchorPath(selection), previousPath)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    // select the node itself, not the previous node,\n    // FIXME: when after an expanded object/array, should go to the last item inside the object/array\n    return createValueSelection(focusPath)\n  }\n\n  if (isInsideSelection(selection)) {\n    // select the node itself, not the previous node,\n    return createValueSelection(focusPath)\n  }\n\n  if (isKeySelection(selection)) {\n    if (previousPath === undefined || previousPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(previousPath)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent) || isEmpty(previousPath)) {\n      // switch to value selection: array has no keys, and root object also not\n      return createValueSelection(previousPath)\n    } else {\n      return createKeySelection(previousPath)\n    }\n  }\n\n  if (isValueSelection(selection)) {\n    return previousPath !== undefined ? createValueSelection(previousPath) : undefined\n  }\n\n  if (previousPath !== undefined) {\n    return createValueSelection(previousPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionDown(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getEndPath(json, selection)\n\n  // if the focusPath is an Array or object, we must not step into it but\n  // over it, we pass state with this array/object collapsed\n  const collapsedState = isObjectOrArray(getIn(json, focusPath))\n    ? collapsePath(json, documentState, focusPath, true)\n    : documentState\n\n  const nextPath = getNextVisiblePath(json, documentState, focusPath)\n  const nextPathAfter = getNextVisiblePath(json, collapsedState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection)) {\n      return nextPath !== undefined ? createMultiSelection(nextPath, nextPath) : undefined\n    }\n\n    if (isAfterSelection(selection)) {\n      return nextPathAfter !== undefined\n        ? createMultiSelection(nextPathAfter, nextPathAfter)\n        : undefined\n    }\n\n    return nextPathAfter !== undefined\n      ? createMultiSelection(getAnchorPath(selection), nextPathAfter)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    return nextPathAfter !== undefined ? createValueSelection(nextPathAfter) : undefined\n  }\n\n  if (isInsideSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isValueSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isKeySelection(selection)) {\n    if (nextPath === undefined || nextPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(nextPath) // not nextPathAfter!\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      // switch to value selection: array has no keys\n      return createValueSelection(nextPath)\n    } else {\n      return createKeySelection(nextPath)\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    return nextPathAfter !== undefined\n      ? createValueSelection(nextPathAfter)\n      : nextPath !== undefined\n        ? createValueSelection(nextPath)\n        : undefined\n  }\n\n  return undefined\n}\n\n/**\n * Get the next selection for a value inside the current object/array\n * If there is no next value, select AFTER.\n * Only applicable for ValueSelection\n */\nexport function getSelectionNextInside(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  // TODO: write unit tests for getSelectionNextInside\n  const parentPath = initial(path)\n  const childPath = [last(path) as string]\n\n  const parent: unknown | undefined = getIn(json, parentPath)\n  const nextPathInside = parent ? getNextVisiblePath(parent, documentState, childPath) : undefined\n\n  if (nextPathInside) {\n    return createValueSelection(parentPath.concat(nextPathInside))\n  } else {\n    return createAfterSelection(path)\n  }\n}\n\n/**\n * Find the caret position and its siblings for a given selection\n */\n// TODO: unit test\nexport function findCaretAndSiblings(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  includeInside: boolean\n): {\n  next: CaretPosition | undefined\n  caret: CaretPosition | undefined\n  previous: CaretPosition | undefined\n} {\n  if (!selection) {\n    return { caret: undefined, previous: undefined, next: undefined }\n  }\n  const visibleCaretPositions = getVisibleCaretPositions(json, documentState, includeInside)\n\n  const index = visibleCaretPositions.findIndex((caret) => {\n    return (\n      isEqual(caret.path, getFocusPath(selection)) && String(caret.type) === String(selection.type)\n    )\n  })\n\n  return {\n    caret: index !== -1 ? visibleCaretPositions[index] : undefined,\n\n    previous: index !== -1 && index > 0 ? visibleCaretPositions[index - 1] : undefined,\n\n    next:\n      index !== -1 && index < visibleCaretPositions.length - 1\n        ? visibleCaretPositions[index + 1]\n        : undefined\n  }\n}\n\nexport function getSelectionLeft(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, previous } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && previous) {\n    return fromCaretPosition(previous)\n  }\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (isValueSelection(selection) && Array.isArray(parent)) {\n    return createMultiSelection(selection.path, selection.path)\n  }\n\n  if (isMultiSelection(selection) && !Array.isArray(parent)) {\n    return createKeySelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionRight(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, next } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && next) {\n    return fromCaretPosition(next)\n  }\n\n  if (isMultiSelection(selection)) {\n    return createValueSelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\n/**\n * Get a proper initial selection based on what is visible\n */\nexport function getInitialSelection(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONSelection {\n  const visiblePaths = getVisiblePaths(json, documentState)\n\n  // find the first, deepest nested entry (normally a value, not an Object/Array)\n  let index = 0\n  while (\n    index < visiblePaths.length - 1 &&\n    visiblePaths[index + 1].length > visiblePaths[index].length\n  ) {\n    index++\n  }\n\n  const path = visiblePaths[index]\n  return path === undefined || path.length === 0 || Array.isArray(getIn(json, initial(path)))\n    ? createValueSelection(path) // Array items and root object/array do not have a key, so select value in that case\n    : createKeySelection(path)\n}\n\nexport function createSelectionFromOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONSelection | undefined {\n  if (operations.length === 1) {\n    const operation = first(operations) as JSONPatchOperation\n    if (operation.op === 'replace') {\n      // a replaced value\n      const path = parsePath(json, operation.path)\n\n      return createValueSelection(path)\n    }\n  }\n\n  if (!isEmpty(operations) && operations.every((operation) => operation.op === 'move')) {\n    const firstOp = first(operations)\n    const otherOps = operations.slice(1)\n\n    if (\n      (isJSONPatchCopy(firstOp) || isJSONPatchMove(firstOp)) &&\n      firstOp.from !== firstOp.path &&\n      otherOps.every((op) => (isJSONPatchCopy(op) || isJSONPatchMove(op)) && op.from === op.path)\n    ) {\n      // a renamed key\n      const path = parsePath(json, firstOp.path)\n\n      return createKeySelection(path)\n    }\n  }\n\n  const paths = operations\n    .filter((operation) => {\n      return (\n        operation.op !== 'test' &&\n        operation.op !== 'remove' &&\n        (operation.op !== 'move' || operation.from !== operation.path) &&\n        typeof operation.path === 'string'\n      )\n    })\n    .map((operation) => parsePath(json, operation.path))\n\n  if (isEmpty(paths)) {\n    return undefined\n  }\n\n  // TODO: make this function robust against operations which do not have consecutive paths or have wrongly ordered paths\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: first(paths) as JSONPath,\n    focusPath: last(paths) as JSONPath\n  }\n}\n\n/**\n * Find the common path of two paths.\n * For example findCommonRoot(['arr', '1', 'name'], ['arr', '1', 'address', 'contact']) returns ['arr', '1']\n */\n// TODO: write unit tests for findSharedPath\nexport function findSharedPath(path1: JSONPath, path2: JSONPath): JSONPath {\n  let i = 0\n  while (i < path1.length && i < path2.length && path1[i] === path2[i]) {\n    i++\n  }\n\n  return path1.slice(0, i)\n}\n\nexport function singleItemSelected(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\nexport function findRootPath(json: unknown, selection: JSONSelection): JSONPath {\n  return singleItemSelected(selection) && isObjectOrArray(getIn(json, getFocusPath(selection)))\n    ? getFocusPath(selection)\n    : initial(getFocusPath(selection)) // the parent path of the paths\n}\n\nexport function pathStartsWith(path: JSONPath, parentPath: JSONPath): boolean {\n  if (path.length < parentPath.length) {\n    return false\n  }\n\n  for (let i = 0; i < parentPath.length; i++) {\n    if (path[i] !== parentPath[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// TODO: write unit tests\nexport function removeEditModeFromSelection(\n  selection: JSONSelection | undefined\n): JSONSelection | undefined {\n  if (isEditingSelection(selection)) {\n    const { type, path } = selection\n    return { type, path } as KeySelection | ValueSelection\n  }\n\n  return selection\n}\n\nexport function createKeySelection(path: JSONPath): KeySelection {\n  return { type: SelectionType.key, path }\n}\n\nexport function createEditKeySelection(path: JSONPath, initialValue?: string): EditKeySelection {\n  return { type: SelectionType.key, path, edit: true, initialValue }\n}\n\nexport function createValueSelection(path: JSONPath): ValueSelection {\n  return { type: SelectionType.value, path }\n}\n\nexport function createEditValueSelection(\n  path: JSONPath,\n  initialValue?: string\n): EditValueSelection {\n  return { type: SelectionType.value, path, edit: true, initialValue }\n}\n\nexport function createInsideSelection(path: JSONPath): InsideSelection {\n  return {\n    type: SelectionType.inside,\n    path\n  }\n}\n\nexport function createAfterSelection(path: JSONPath): AfterSelection {\n  return {\n    type: SelectionType.after,\n    path\n  }\n}\n\nexport function createMultiSelection(anchorPath: JSONPath, focusPath: JSONPath): MultiSelection {\n  // normalize the paths to both be a child of a shared parent\n  const sharedPath = findSharedPath(anchorPath, focusPath)\n  const isParent = anchorPath.length > sharedPath.length && focusPath.length > sharedPath.length\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: isParent ? sharedPath.concat(anchorPath[sharedPath.length]) : sharedPath,\n    focusPath: isParent ? sharedPath.concat(focusPath[sharedPath.length]) : sharedPath\n  }\n}\n\n/**\n * Turn selected contents into plain text partial JSON, usable for copying to\n * clipboard for example.\n */\nexport function selectionToPartialJson(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  indentation: number | string | undefined,\n  parser: JSONParser\n): string | undefined {\n  if (isKeySelection(selection)) {\n    return String(last(selection.path))\n  }\n\n  if (isValueSelection(selection)) {\n    const value = getIn(json, selection.path)\n    return typeof value === 'string' ? value : parser.stringify(value, null, indentation) // TODO: customizable indentation?\n  }\n\n  if (isMultiSelection(selection)) {\n    if (isEmpty(selection.focusPath)) {\n      // root object -> does not have a parent key/index\n      return parser.stringify(json, null, indentation)\n    }\n\n    const parentPath = getParentPath(selection)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      if (isMultiSelectionWithOneItem(selection)) {\n        // do not suffix a single selected array item with a comma\n        const item = getIn(json, selection.focusPath)\n        return parser.stringify(item, null, indentation)\n      } else {\n        return getSelectionPaths(json, selection)\n          .map((path) => {\n            const item = getIn(json, path)\n            return `${parser.stringify(item, null, indentation)},`\n          })\n          .join('\\n')\n      }\n    } else {\n      // parent is Object\n      return getSelectionPaths(json, selection)\n        .map((path) => {\n          const key = last(path)\n          const value = getIn(json, path)\n          return `${parser.stringify(key)}: ${parser.stringify(value, null, indentation)},`\n        })\n        .join('\\n')\n    }\n  }\n\n  return undefined\n}\n\nexport function isEditingSelection(\n  selection: JSONSelection | undefined\n): selection is EditKeySelection | EditValueSelection {\n  return (\n    (isKeySelection(selection) || isValueSelection(selection)) &&\n    (selection as Record<string, unknown>).edit === true\n  )\n}\n\n/**\n * Create a selection which selects the root of the document\n */\n// TODO: write unit tests\nexport function selectAll(): JSONSelection {\n  return createValueSelection([])\n}\n\n// TODO: write unit tests\nexport function hasSelectionContents(selection: JSONSelection | undefined): boolean {\n  return isKeySelection(selection) || isValueSelection(selection) || isMultiSelection(selection)\n}\n\n/**\n * Test whether the current selection can be converted.\n * That is the case when the selection is a key/value, or a multi selection with only one path\n */\nexport function canConvert(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromCaretPosition(caretPosition: CaretPosition): JSONSelection {\n  switch (caretPosition.type) {\n    case CaretType.key:\n      return createKeySelection(caretPosition.path)\n    case CaretType.value:\n      return createValueSelection(caretPosition.path)\n    case CaretType.after:\n      return createAfterSelection(caretPosition.path)\n    case CaretType.inside:\n      return createInsideSelection(caretPosition.path)\n  }\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromSelectionType(selectionType: SelectionType, path: JSONPath): JSONSelection {\n  switch (selectionType) {\n    case SelectionType.key:\n      return createKeySelection(path)\n    case SelectionType.value:\n      return createValueSelection(path)\n    case SelectionType.after:\n      return createAfterSelection(path)\n    case SelectionType.inside:\n      return createInsideSelection(path)\n    case SelectionType.multi:\n    case SelectionType.text: // type `text` is not applicable, but we need to handle all types\n      return createMultiSelection(path, path)\n  }\n}\n\nexport function selectionIfOverlapping(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  if (pathInSelection(json, selection, path)) {\n    return selection\n  }\n\n  const sharedPath = isMultiSelection(selection) ? initial(selection.focusPath) : selection.path\n  if (pathStartsWith(sharedPath, path)) {\n    return selection\n  }\n\n  return undefined\n}\n\nexport function pathInSelection(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): boolean {\n  if (json === undefined || !selection) {\n    return false\n  }\n\n  if (isKeySelection(selection) || isInsideSelection(selection) || isAfterSelection(selection)) {\n    return isEqual(selection.path, path)\n  }\n\n  if (isValueSelection(selection)) {\n    return pathStartsWith(path, selection.path)\n  }\n\n  if (isMultiSelection(selection)) {\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n    const parentPath = initial(selection.focusPath)\n\n    if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n      return false\n    }\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n    const pathIndex = getChildIndex(json, selection, path)\n    return pathIndex !== -1 && pathIndex >= startIndex && pathIndex <= endIndex\n  }\n\n  return false\n}\n\nfunction getChildIndex(json: unknown, selection: MultiSelection, path: JSONPath): number {\n  const parentPath = initial(selection.focusPath)\n  if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n    return -1\n  }\n\n  const key = path[parentPath.length]\n  const parent = getIn(json, parentPath)\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    return keys.indexOf(key)\n  }\n\n  if (isJSONArray(parent)) {\n    const index = int(key)\n    if (index < parent.length) {\n      return index\n    }\n  }\n\n  return -1\n}\n\n// TODO: write some unit tests\nexport function getFocusPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.focusPath : selection.path\n}\n\n// TODO: write some unit tests\nexport function getAnchorPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.anchorPath : selection.path\n}\n","/**\n * A simplified version of https://github.com/JedWatson/classnames\n *\n * Example usage:\n *\n *     classnames('primary-button', { selected: true }, 'left')\n *\n */\nexport function classnames(...args: Array<string | Record<string, boolean> | undefined>): string {\n  const classes = []\n\n  for (const arg of args) {\n    if (typeof arg === 'string') {\n      classes.push(arg)\n    }\n\n    if (arg && typeof arg === 'object') {\n      for (const key in arg) {\n        if (Object.hasOwnProperty.call(arg, key) && arg[key]) {\n          classes.push(key)\n        }\n      }\n    }\n  }\n\n  return classes.join(' ')\n}\n","import { isUrl, valueType } from '$lib/utils/typeUtils.js'\nimport { type JSONParser, Mode } from '$lib/types.js'\nimport { classnames } from '$lib/utils/cssUtils.js'\n\nexport function getValueClass(value: unknown, mode: Mode, parser: JSONParser): string {\n  const type = valueType(value, parser)\n\n  return classnames('jse-value', 'jse-' + type, {\n    'jse-url': isUrl(value),\n    'jse-empty': typeof value === 'string' && value.length === 0,\n    'jse-table-cell': mode === Mode.table\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n  import { addNewLineSuffix, removeNewLineSuffix, setCursorToEnd } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { noop } from 'lodash-es'\n  import type { OnFind, OnPaste } from '$lib/types'\n  import { UpdateSelectionAfterChange } from '$lib/types'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  const debug = createDebug('jsoneditor:EditableDiv')\n\n  export let value: string\n  export let initialValue: string | undefined\n  export let shortText = false\n  export let label: string\n  export let onChange: (newValue: string, updateSelection: UpdateSelectionAfterChange) => void\n  export let onCancel: () => void\n  export let onFind: OnFind\n  export let onPaste: OnPaste = noop\n  export let onValueClass: (value: string) => string = () => ''\n\n  let domValue: HTMLDivElement | undefined\n  let valueClass: string\n  $: valueClass = onValueClass(value)\n  let closed = false\n\n  onMount(() => {\n    debug('onMount', { value, initialValue })\n    setDomValue(initialValue !== undefined ? initialValue : value)\n\n    // focus\n    if (domValue) {\n      setCursorToEnd(domValue)\n    }\n  })\n\n  onDestroy(() => {\n    const newValue = getDomValue()\n\n    debug('onDestroy', { closed, value, newValue })\n\n    if (!closed && newValue !== value) {\n      onChange(newValue, UpdateSelectionAfterChange.no)\n    }\n  })\n\n  function getDomValue(): string {\n    if (!domValue) {\n      return ''\n    }\n    return removeNewLineSuffix(domValue.innerText)\n  }\n\n  function setDomValue(updatedValue: string) {\n    if (!domValue) {\n      return\n    }\n    domValue.innerText = addNewLineSuffix(updatedValue)\n  }\n\n  function handleValueInput() {\n    const newValue = getDomValue()\n\n    if (newValue === '') {\n      // immediately update to clean up any left over <br/>\n      setDomValue('')\n    }\n\n    // update class\n    valueClass = onValueClass(newValue)\n  }\n\n  function handleCancel() {\n    // cancel changes (needed to prevent triggering a change onDestroy)\n    closed = true\n\n    onCancel()\n  }\n\n  function handleValueKeyDown(event: KeyboardEvent) {\n    event.stopPropagation()\n\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      handleCancel()\n    }\n\n    if (combo === 'Enter' || combo === 'Tab') {\n      // apply changes\n      closed = true\n\n      const newValue = getDomValue()\n      onChange(newValue, UpdateSelectionAfterChange.nextInside)\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      onFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      onFind(true)\n    }\n  }\n\n  function handleValuePaste(event: ClipboardEvent) {\n    event.stopPropagation()\n\n    if (!onPaste || !event.clipboardData) {\n      return\n    }\n\n    const clipboardText = event.clipboardData.getData('text/plain')\n    onPaste(clipboardText)\n  }\n\n  function handleBlur() {\n    const hasFocus = document.hasFocus()\n    const newValue = getDomValue()\n\n    debug('handleBlur', { hasFocus, closed, value, newValue })\n\n    // we only want to close the editable div when the focus did go to another\n    // element on the same page, but not when the user switches to another\n    // application or browser tab to copy/paste something whilst still editing\n    // the value, hence the check for document.hasFocus()\n    if (document.hasFocus() && !closed) {\n      closed = true\n      if (newValue !== value) {\n        onChange(newValue, UpdateSelectionAfterChange.self)\n      } else {\n        // Note that we do not fire an onCancel here: a blur action\n        // is caused by the user clicking somewhere else. If we apply\n        // onCancel now, we would override the selection that the user\n        // wants by clicking somewhere else in the editor (since `blur`\n        // is occurring *after* `mousedown`).\n      }\n    }\n  }\n</script>\n\n<div\n  role=\"textbox\"\n  aria-label={label}\n  tabindex=\"0\"\n  class={classnames('jse-editable-div', valueClass, { 'jse-short-text': shortText })}\n  contenteditable=\"true\"\n  spellcheck=\"false\"\n  on:input={handleValueInput}\n  on:keydown={handleValueKeyDown}\n  on:paste={handleValuePaste}\n  on:blur={handleBlur}\n  bind:this={domValue}\n></div>\n\n<style src=\"./EditableDiv.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { isObjectOrArray, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createValueSelection, getFocusPath, isEditingSelection } from '$lib/logic/selection.js'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import EditableDiv from '../../../components/controls/EditableDiv.svelte'\n  import {\n    type FindNextInside,\n    type JSONParser,\n    type JSONSelection,\n    Mode,\n    type OnFind,\n    type OnJSONSelect,\n    type OnPasteJson,\n    type OnPatch,\n    UpdateSelectionAfterChange,\n    type ValueNormalization\n  } from '$lib/types.js'\n  import { isEqual } from 'lodash-es'\n  import { expandSmart } from '$lib/logic/documentState'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let selection: JSONSelection | undefined\n  export let mode: Mode\n  export let parser: JSONParser\n  export let normalization: ValueNormalization\n  export let enforceString: boolean\n  export let onPatch: OnPatch\n  export let onPasteJson: OnPasteJson\n  export let onSelect: OnJSONSelect\n  export let onFind: OnFind\n  export let focus: () => void\n  export let findNextInside: FindNextInside\n\n  function convert(value: string): unknown {\n    return enforceString ? value : stringConvert(value, parser)\n  }\n\n  function handleChangeValue(newValue: string, updateSelection: UpdateSelectionAfterChange) {\n    onPatch(\n      [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: convert(normalization.unescapeValue(newValue))\n        }\n      ],\n      (_, patchedState, patchedSelection) => {\n        // Leave the selection as is when it is no longer the path that we were editing here\n        // This happens for example when the user clicks or double-clicks on another value\n        // whilst editing a value\n        if (patchedSelection && !isEqual(path, getFocusPath(patchedSelection))) {\n          return undefined\n        }\n\n        const selection =\n          updateSelection === UpdateSelectionAfterChange.nextInside\n            ? findNextInside(path)\n            : createValueSelection(path)\n\n        return {\n          state: patchedState,\n          selection\n        }\n      }\n    )\n\n    focus()\n  }\n\n  function handleCancelChange() {\n    onSelect(createValueSelection(path))\n    focus()\n  }\n\n  function handlePaste(pastedText: string): void {\n    try {\n      const pastedJson = parser.parse(pastedText)\n      if (isObjectOrArray(pastedJson)) {\n        onPasteJson({\n          path,\n          contents: pastedJson,\n          onPasteAsJson: () => {\n            // exit edit mode\n            handleCancelChange()\n\n            // replace the value with the JSON object/array\n            const operations: JSONPatchDocument = [\n              {\n                op: 'replace',\n                path: compileJSONPointer(path),\n                value: pastedJson\n              }\n            ]\n\n            onPatch(operations, (patchedJson, patchedState) => ({\n              state: expandSmart(patchedJson, patchedState, path)\n            }))\n          }\n        })\n      }\n    } catch {\n      // silently ignore: thee pasted text is no valid JSON object or array,\n      // no need to do anything\n    }\n  }\n\n  function handleOnValueClass(value: string): string {\n    return getValueClass(convert(normalization.unescapeValue(value)), mode, parser)\n  }\n</script>\n\n<EditableDiv\n  value={normalization.escapeValue(value)}\n  initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n  label=\"Edit value\"\n  onChange={handleChangeValue}\n  onCancel={handleCancelChange}\n  onPaste={handlePaste}\n  {onFind}\n  onValueClass={handleOnValueClass}\n/>\n","import { cloneDeepWith, first, initial, isEmpty, last, times } from 'lodash-es'\nimport {\n  compileJSONPointer,\n  existsIn,\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parseJSONPointer,\n  revertJSONPatch\n} from 'immutable-json-patch'\nimport { parseAndRepair, parseAndRepairOrUndefined, parsePartialJson } from '../utils/jsonUtils.js'\nimport { findUniqueName } from '../utils/stringUtils.js'\nimport { isObject, isObjectOrArray } from '../utils/typeUtils.js'\nimport { getNextKeys } from './documentState.js'\nimport {\n  createAfterSelection,\n  createInsideSelection,\n  createSelectionFromOperations,\n  createValueSelection,\n  getEndPath,\n  getFocusPath,\n  getParentPath,\n  getSelectionPaths,\n  getStartPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  pathStartsWith\n} from './selection.js'\nimport type { ClipboardValues, DragInsideAction, JSONParser, JSONSelection } from '$lib/types'\nimport { int } from '../utils/numberUtils.js'\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\n// TODO: write tests\nexport function insertBefore(\n  json: unknown,\n  path: JSONPath,\n  values: ClipboardValues\n): JSONPatchDocument {\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    // the path is parsed from a JSONPatch operation,\n    // so array indices are a string which we have to parse into a number\n    const offset = int(last(path) as string)\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(parentPath.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const afterKey = last(path)\n    const keys = Object.keys(parent)\n    const nextKeys = afterKey !== undefined ? getNextKeys(keys, afterKey, true) : []\n\n    return [\n      // insert new values\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, keys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move all lower down keys so the inserted key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create insert operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an append operation. The values will be appended\n * to the end of the array or object.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function append(json: unknown, path: JSONPath, values: ClipboardValues): JSONPatchDocument {\n  const parent = getIn(json, path)\n\n  if (Array.isArray(parent)) {\n    const offset = parent.length\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(path.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else {\n    // 'object'\n    return values.map((entry) => {\n      const newProp = findUniqueName(entry.key, Object.keys(parent as Record<string, unknown>))\n      return {\n        op: 'add',\n        path: compileJSONPointer(path.concat(newProp)),\n        value: entry.value\n      }\n    })\n  }\n}\n\n/**\n * Rename an object key\n * Not applicable to arrays\n */\nexport function rename(\n  parentPath: JSONPath,\n  keys: string[],\n  oldKey: string,\n  newKey: string\n): JSONPatchDocument {\n  const filteredKeys = keys.filter((key) => key !== oldKey)\n  const newKeyUnique = findUniqueName(newKey, filteredKeys)\n  const nextKeys = getNextKeys(keys, oldKey, false)\n\n  return [\n    // rename a key\n    {\n      op: 'move',\n      from: compileJSONPointer(parentPath.concat(oldKey)),\n      path: compileJSONPointer(parentPath.concat(newKeyUnique))\n    },\n\n    // move all lower down keys so the renamed key will maintain it's position\n    ...nextKeys.map((key) => moveDown(parentPath, key))\n  ]\n}\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function replace(\n  json: unknown,\n  paths: JSONPath[],\n  values: ClipboardValues\n): JSONPatchDocument {\n  const firstPath = first(paths)\n  const parentPath = initial(firstPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const firstPath = first(paths)\n    const offset = firstPath ? int(last(firstPath) as string) : 0\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(String(index + offset))),\n          value: entry.value\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // parent is Object\n    // if we're going to replace an existing object with key \"a\" with a new\n    // key \"a\", we must not create a new unique name \"a (copy)\".\n    const lastPath = last(paths)\n    const parentPath = initial(lastPath)\n    const beforeKey = last(lastPath)\n    const keys: string[] = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n    const removeKeys = new Set(paths.map((path) => last(path)))\n    const filteredKeys = keys.filter((key) => !removeKeys.has(key))\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, filteredKeys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create replace operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for a duplicate action.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the duplicated node in case of duplicating\n * and object property\n */\nexport function duplicate(json: unknown, paths: JSONPath[]): JSONPatchDocument {\n  // FIXME: here we assume paths is sorted correctly, that's a dangerous assumption\n  const lastPath = last(paths)\n\n  if (isEmpty(lastPath)) {\n    throw new Error('Cannot duplicate root object')\n  }\n\n  const parentPath = initial(lastPath)\n  const beforeKey = last(lastPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const lastPath = last(paths)\n    const offset = lastPath ? int(last(lastPath) as string) + 1 : 0\n\n    return [\n      // copy operations\n      ...paths.map((path, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(String(index + offset)))\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const keys = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n\n    return [\n      // copy operations\n      ...paths.map((path) => {\n        const prop = last(path) as string\n        const newProp = findUniqueName(prop, keys)\n\n        return {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(newProp))\n        } as JSONPatchCopy\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain it's position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create duplicate operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an extract action.\n */\n// TODO: write unit tests\nexport function extract(json: unknown, selection: JSONSelection): JSONPatchDocument {\n  if (isValueSelection(selection)) {\n    return [\n      {\n        op: 'move',\n        from: compileJSONPointer(selection.path),\n        path: ''\n      }\n    ]\n  }\n\n  if (isMultiSelection(selection)) {\n    const parentPath = initial(selection.focusPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const value = getSelectionPaths(json, selection).map((path) => {\n        const index = int(last(path) as string)\n        return parent[index]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    } else if (isJSONObject(parent)) {\n      // object\n      const value: Record<string, unknown> = {}\n      getSelectionPaths(json, selection).forEach((path) => {\n        const key = String(last(path))\n        value[key] = parent[key]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    }\n  } else {\n    throw new Error('Cannot create extract operations: parent must be an Object or Array')\n  }\n\n  // this should never happen\n  throw new Error('Cannot extract: unsupported type of selection ' + JSON.stringify(selection))\n}\n\n// TODO: write unit tests\nexport function insert(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  clipboardText: string,\n  parser: JSONParser\n): JSONPatchDocument {\n  if (isKeySelection(selection)) {\n    // rename key\n    const clipboard = parseAndRepairOrUndefined(clipboardText, parser)\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = typeof clipboard === 'string' ? clipboard : clipboardText\n\n    return rename(parentPath, keys, oldKey, newKey)\n  }\n\n  if (\n    isValueSelection(selection) ||\n    (isMultiSelection(selection) && isEmpty(selection.focusPath)) // root selected\n  ) {\n    // replace selected value (new value can be primitive or an array/object with contents)\n    try {\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n        }\n      ]\n    } catch {\n      // parsing failed -> just paste the raw text as value\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: clipboardText\n        }\n      ]\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n\n    return replace(json, getSelectionPaths(json, selection), newValues)\n  }\n\n  if (isAfterSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const index = int(last(path) as string)\n      const nextItemPath = parentPath.concat(String(index + 1))\n\n      return insertBefore(json, nextItemPath, newValues)\n    } else if (isJSONObject(parent)) {\n      // value is an Object\n      const key = String(last(path))\n      const keys: string[] = Object.keys(parent)\n      if (isEmpty(keys) || last(keys) === key) {\n        return append(json, parentPath, newValues)\n      } else {\n        const index = keys.indexOf(key)\n        const nextKey = keys[index + 1]\n        const nextKeyPath = parentPath.concat(nextKey)\n\n        return insertBefore(json, nextKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  if (isInsideSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const value = getIn(json, path)\n\n    if (isJSONArray(value)) {\n      const firstItemPath = path.concat('0')\n      return insertBefore(json, firstItemPath, newValues)\n    } else if (isJSONObject(value)) {\n      // value is an Object\n      const keys = Object.keys(value)\n      if (isEmpty(keys)) {\n        return append(json, path, newValues)\n      } else {\n        const firstKey = first(keys) as string\n        const firstKeyPath = path.concat(firstKey)\n\n        return insertBefore(json, firstKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot insert: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function moveInsideParent(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  dragInsideAction: DragInsideAction\n): JSONPatchDocument {\n  if (!selection) {\n    return []\n  }\n\n  const beforePath = 'beforePath' in dragInsideAction ? dragInsideAction['beforePath'] : undefined\n  const append = 'append' in dragInsideAction ? dragInsideAction['append'] : undefined\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (\n    !append &&\n    !(beforePath && pathStartsWith(beforePath, parentPath) && beforePath.length > parentPath.length)\n  ) {\n    return []\n  }\n\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n  const startKey = last(startPath) as string\n  const endKey = last(endPath) as string\n  const toKey: string | undefined = beforePath ? beforePath[parentPath.length] : undefined\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const startIndex = keys.indexOf(startKey)\n    const endIndex = keys.indexOf(endKey)\n    const toIndex = append ? keys.length : toKey !== undefined ? keys.indexOf(toKey) : -1\n\n    if (startIndex !== -1 && endIndex !== -1 && toIndex !== -1) {\n      if (toIndex > startIndex) {\n        // moving down\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(startIndex, endIndex + 1), ...keys.slice(toIndex, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      } else {\n        // moving up\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(toIndex, startIndex), ...keys.slice(endIndex + 1, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      }\n    }\n  } else if (isJSONArray(parent)) {\n    // array\n    const startIndex = int(startKey)\n    const endIndex = int(endKey)\n    const toIndex = toKey !== undefined ? int(toKey) : parent.length\n    const count = endIndex - startIndex + 1\n\n    if (toIndex < startIndex) {\n      // move up\n      return times(count, (offset) => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex + offset))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex + offset)))\n        }\n      })\n    } else {\n      // move down\n      return times(count, () => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex)))\n        }\n      })\n    }\n  } else {\n    throw new Error('Cannot create move operations: parent must be an Object or Array')\n  }\n\n  return []\n}\n\nexport function createNewValue(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  valueType: 'object' | 'array' | 'structure' | 'value'\n): unknown {\n  if (valueType === 'object') {\n    return {}\n  }\n\n  if (valueType === 'array') {\n    return []\n  }\n\n  if (valueType === 'structure' && json !== undefined) {\n    const parentPath = selection ? getParentPath(selection) : []\n    const parent = getIn(json, parentPath)\n\n    if (Array.isArray(parent) && !isEmpty(parent)) {\n      const jsonExample = first(parent)\n      if (isObjectOrArray(jsonExample)) {\n        return cloneDeepWith(jsonExample, (value) => {\n          return Array.isArray(value)\n            ? []\n            : isObject(value)\n              ? undefined // leave object as is, will recurse into it\n              : ''\n        })\n      } else {\n        // just a primitive value\n        return ''\n      }\n    }\n  }\n\n  // type === value,\n  // or type === structure but the parent is no array or an array containing\n  // primitive values (and no objects having any structure).\n  return ''\n}\n\n/**\n * Create a JSONPatch for a remove operation\n */\nexport function remove(path: JSONPath): JSONPatchDocument {\n  return [\n    {\n      op: 'remove',\n      path: compileJSONPointer(path)\n    }\n  ]\n}\n\n/**\n * Create a JSONPatch for a multiple remove operation\n */\nexport function removeAll(paths: JSONPath[]): JSONPatchDocument {\n  return paths\n    .map((path) => {\n      const operation: JSONPatchOperation = {\n        op: 'remove',\n        path: compileJSONPointer(path)\n      }\n\n      return operation\n    })\n    .reverse() // reverse is needed for arrays: delete the last index first\n}\n\n// helper function to move a key down in an object,\n// so another key can get positioned before the moved down keys\nfunction moveDown(parentPath: JSONPath, key: string): JSONPatchOperation {\n  return {\n    op: 'move',\n    from: compileJSONPointer(parentPath.concat(key)),\n    path: compileJSONPointer(parentPath.concat(key))\n  }\n}\n\nexport function clipboardToValues(clipboardText: string, parser: JSONParser): ClipboardValues {\n  const textIsObject = /^\\s*{/.test(clipboardText)\n  const textIsArray = /^\\s*\\[/.test(clipboardText)\n\n  const clipboardOriginal = parseAndRepairOrUndefined(clipboardText, parser)\n  const clipboardRepaired =\n    clipboardOriginal !== undefined\n      ? clipboardOriginal\n      : parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n\n  if (\n    (textIsObject && isObject(clipboardRepaired)) ||\n    (textIsArray && Array.isArray(clipboardRepaired))\n  ) {\n    return [{ key: 'New item', value: clipboardRepaired }]\n  }\n\n  if (Array.isArray(clipboardRepaired)) {\n    return clipboardRepaired.map((value, index) => {\n      return { key: 'New item ' + index, value }\n    })\n  }\n\n  if (isObject(clipboardRepaired)) {\n    return Object.keys(clipboardRepaired).map((key) => {\n      return { key, value: clipboardRepaired[key] }\n    })\n  }\n\n  // regular value\n  return [{ key: 'New item', value: clipboardRepaired }]\n}\n\n// TODO: write unit tests\nexport function createRemoveOperations(\n  json: unknown,\n  selection: JSONSelection\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  if (isKeySelection(selection)) {\n    // FIXME: DOESN'T work yet\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = ''\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return { operations, newSelection }\n  }\n\n  if (isValueSelection(selection)) {\n    const operations: JSONPatchDocument = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(selection.path),\n        value: ''\n      }\n    ]\n\n    return { operations, newSelection: selection }\n  }\n\n  if (isMultiSelection(selection)) {\n    const paths = getSelectionPaths(json, selection)\n    const operations = removeAll(paths)\n    const lastPath = last(paths)\n\n    if (isEmpty(lastPath)) {\n      // there is no parent, this is the root document\n      const operations: JSONPatchDocument = [{ op: 'replace', path: '', value: '' }]\n\n      const newSelection = createValueSelection([])\n\n      return { operations, newSelection }\n    }\n\n    const parentPath = initial(lastPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const firstPath = first(paths)\n      const index = int(last(firstPath) as string)\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(String(index - 1)))\n\n      return { operations, newSelection }\n    } else if (isJSONObject(parent)) {\n      // parent is object\n      const keys = Object.keys(parent)\n      const firstPath = first(paths)\n      const key = last(firstPath) as string\n      const index = keys.indexOf(key)\n      const previousKey = keys[index - 1]\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(previousKey))\n\n      return { operations, newSelection }\n    } else {\n      throw new Error('Cannot create remove operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot remove: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function revertJSONPatchWithMoveOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONPatchDocument {\n  return revertJSONPatch(json, operations, {\n    before: (json, operation, revertOperations) => {\n      if (isJSONPatchRemove(operation)) {\n        const path = parseJSONPointer(operation.path)\n        return {\n          revertOperations: [...revertOperations, ...createRevertMoveOperations(json, path)]\n        }\n      }\n\n      if (isJSONPatchMove(operation)) {\n        const from = parseJSONPointer(operation.from)\n        return {\n          revertOperations: [...revertOperations, ...createRevertMoveOperations(json, from)]\n        }\n      }\n\n      return { document: json }\n    }\n  })\n}\n\nfunction createRevertMoveOperations(json: unknown, path: JSONPath): JSONPatchOperation[] {\n  const parentPath = initial(path)\n  const afterKey = last(path) as string\n  const parent = getIn(json, parentPath)\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const nextKeys = getNextKeys(keys, afterKey, false)\n\n    // move all lower down keys so the inserted key will maintain its position\n    return nextKeys.map((key) => moveDown(parentPath, key))\n  }\n\n  return []\n}\n\n/**\n * Add operations to create parent objects when missing before replacing a nested value\n */\nexport function createNestedValueOperations(operations: JSONPatchOperation[], json: unknown) {\n  return operations.flatMap((operation) => {\n    if (isJSONPatchReplace(operation)) {\n      const path = parseJSONPointer(operation.path)\n      if (path.length > 0) {\n        const extendedOperations: JSONPatchOperation[] = [operation]\n\n        let parentPath = initial(path)\n        while (parentPath.length > 0 && !existsIn(json, parentPath)) {\n          extendedOperations.unshift({\n            op: 'add',\n            path: compileJSONPointer(parentPath),\n            value: {}\n          })\n\n          parentPath = initial(parentPath)\n        }\n\n        return extendedOperations\n      }\n    }\n\n    return operation\n  })\n}\n","import type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\nimport { forEachRight, initial, isEqual, last } from 'lodash-es'\nimport { getEnforceString, updateInRecursiveState } from './documentState.js'\nimport { createSelectionFromOperations } from './selection.js'\nimport { rename } from './operations.js'\nimport { stringConvert } from '../utils/typeUtils.js'\nimport type {\n  DocumentState,\n  ExtendedSearchResultItem,\n  JSONParser,\n  JSONSelection,\n  SearchOptions,\n  SearchResultDetails,\n  SearchResultItem,\n  SearchResults,\n  RecursiveStateFactory\n} from '$lib/types'\nimport { SearchField } from '$lib/types.js'\nimport {\n  hasSearchResults,\n  isArrayRecursiveState,\n  isObjectRecursiveState\n} from 'svelte-jsoneditor/typeguards.js'\n\n// TODO: comment\n// TODO: unit test\nexport function updateSearchResult(\n  newResultItems: SearchResultItem[],\n  previousResult: SearchResultDetails | undefined\n): SearchResultDetails {\n  const activePath = previousResult?.activeItem\n    ? getSearchResultPath(previousResult.activeItem)\n    : undefined\n\n  const matchingActiveIndex = newResultItems.findIndex((item) => {\n    return isEqual(activePath, getSearchResultPath(item))\n  })\n\n  const activeIndex =\n    matchingActiveIndex !== -1\n      ? matchingActiveIndex\n      : previousResult?.activeIndex !== undefined &&\n          previousResult?.activeIndex < newResultItems.length\n        ? previousResult?.activeIndex\n        : newResultItems.length > 0\n          ? 0\n          : -1\n\n  const items: ExtendedSearchResultItem[] = newResultItems.map((item, index) => {\n    return { ...item, active: index === activeIndex }\n  })\n\n  const activeItem = items[activeIndex]\n\n  return {\n    items,\n    activeItem,\n    activeIndex\n  }\n}\n\n// TODO: unit test\nexport function searchNext(searchResult: SearchResultDetails): SearchResultDetails {\n  const nextActiveIndex =\n    searchResult.activeIndex < searchResult.items.length - 1\n      ? searchResult.activeIndex + 1\n      : searchResult.items.length > 0\n        ? 0\n        : -1\n\n  const nextActiveItem = searchResult.items[nextActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === nextActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: nextActiveItem,\n    activeIndex: nextActiveIndex\n  }\n}\n\n// TODO: unit test\nexport function searchPrevious(searchResult: SearchResultDetails): SearchResultDetails {\n  const previousActiveIndex =\n    searchResult.activeIndex > 0 ? searchResult.activeIndex - 1 : searchResult.items.length - 1\n\n  const previousActiveItem = searchResult.items[previousActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === previousActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: previousActiveItem,\n    activeIndex: previousActiveIndex\n  }\n}\n\n// TODO: comment\nexport function search(\n  searchText: string,\n  json: unknown,\n  options: SearchOptions = {}\n): SearchResultItem[] {\n  const searchTextLowerCase = searchText.toLowerCase()\n  const maxResults = options?.maxResults ?? Infinity\n  const columns = options?.columns\n  const results: SearchResultItem[] = []\n  const path: JSONPath = [] // we reuse the same Array recursively, this is *much* faster than creating a new path every time\n\n  function onMatch(match: SearchResultItem) {\n    if (results.length >= maxResults) {\n      return\n    }\n\n    results.push(match)\n  }\n\n  function searchRecursive(searchTextLowerCase: string, value: unknown) {\n    if (isJSONArray(value)) {\n      const level = path.length\n      path.push('0')\n\n      for (let i = 0; i < value.length; i++) {\n        path[level] = String(i)\n\n        searchRecursive(searchTextLowerCase, value[i])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n      const level = path.length\n\n      path.push('')\n\n      for (const key of keys) {\n        path[level] = key\n\n        findCaseInsensitiveMatches(key, searchTextLowerCase, path, SearchField.key, onMatch)\n\n        searchRecursive(searchTextLowerCase, value[key])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else {\n      // type is a value\n      findCaseInsensitiveMatches(\n        String(value),\n        searchTextLowerCase,\n        path,\n        SearchField.value,\n        onMatch\n      )\n    }\n  }\n\n  if (searchText === '') {\n    return []\n  } else if (columns) {\n    if (!Array.isArray(json)) {\n      throw new Error('json must be an Array when option columns is defined')\n    }\n\n    for (let i = 0; i < json.length; i++) {\n      path[0] = String(i)\n\n      const item = json[i]\n\n      for (let c = 0; c < columns.length; c++) {\n        const column = columns[c]\n\n        if (column.length === 1) {\n          path[1] = column[0]\n        } else {\n          for (let p = 0; p < column.length; p++) {\n            path[p + 1] = column[p]\n          }\n        }\n        while (path.length > column.length + 1) {\n          path.pop()\n        }\n\n        const value = getIn(item, column)\n\n        searchRecursive(searchTextLowerCase, value)\n      }\n\n      if (results.length >= maxResults) {\n        break\n      }\n    }\n\n    return results\n  } else {\n    searchRecursive(searchTextLowerCase, json)\n    return results\n  }\n}\n\n/**\n * Do a case-insensitive search for a search text in a text\n */\nexport function findCaseInsensitiveMatches(\n  text: string,\n  searchTextLowerCase: string,\n  path: JSONPath,\n  field: SearchField,\n  onMatch: (searchResultItem: SearchResultItem) => void\n): void {\n  const textLower = text.toLowerCase()\n\n  let fieldIndex = 0\n  let position = -1\n  let index = -1\n\n  do {\n    index = textLower.indexOf(searchTextLowerCase, position)\n\n    if (index !== -1) {\n      position = index + searchTextLowerCase.length\n\n      onMatch({\n        path: path.slice(0), // path may be mutated in a later stage, therefore we store a copy\n        field,\n        fieldIndex,\n        start: index,\n        end: position\n      })\n\n      fieldIndex++\n    }\n  } while (index !== -1)\n}\n\n/**\n * Replace a search result item with a replacement text\n */\nexport function replaceText(text: string, replacementText: string, start: number, end: number) {\n  return text.substring(0, start) + replacementText + text.substring(end)\n}\n\n/**\n * Replace all matches with a replacement text\n */\nexport function replaceAllText(\n  text: string,\n  replacementText: string,\n  occurrences: Array<{ start: number; end: number }>\n): string {\n  let updatedText = text\n\n  forEachRight(occurrences, (occurrence) => {\n    updatedText = replaceText(updatedText, replacementText, occurrence.start, occurrence.end)\n  })\n\n  return updatedText\n}\n\nexport function createSearchAndReplaceOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  replacementText: string,\n  searchResultItem: SearchResultItem,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  const { field, path, start, end } = searchResultItem\n\n  if (field === SearchField.key) {\n    // replace a key\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n    const oldKey = last(path) as string\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const newKey = replaceText(oldKey, replacementText, start, end)\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else if (field === SearchField.value) {\n    // replace a value\n    const currentValue: unknown | undefined = getIn(json, path)\n    if (currentValue === undefined) {\n      throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n    }\n    const currentValueText = typeof currentValue === 'string' ? currentValue : String(currentValue)\n\n    const enforceString = getEnforceString(json, documentState, path)\n    const value = replaceText(currentValueText, replacementText, start, end)\n\n    const operations: JSONPatchOperation[] = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: enforceString ? value : stringConvert(value, parser)\n      }\n    ]\n\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else {\n    throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n  }\n}\n\nexport function createSearchAndReplaceAllOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  searchText: string,\n  replacementText: string,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  // TODO: to improve performance, we could reuse existing search results (except when hitting a maxResult limit)\n  const searchResultItems = search(searchText, json, { maxResults: Infinity })\n\n  interface Match {\n    path: JSONPath\n    field: string\n    items: SearchResultItem[]\n  }\n\n  // step 1: deduplicate matches inside the same field/value\n  // (filter, map, and group)\n  const deduplicatedMatches: Match[] = []\n  for (let i = 0; i < searchResultItems.length; i++) {\n    const previousItem = searchResultItems[i - 1]\n    const item = searchResultItems[i]\n    if (i === 0 || item.field !== previousItem.field || !isEqual(item.path, previousItem.path)) {\n      deduplicatedMatches.push({\n        path: item.path,\n        field: item.field,\n        items: [item]\n      })\n    } else {\n      ;(last(deduplicatedMatches) as Match).items.push(item)\n    }\n  }\n\n  // step 2: sort from deepest nested to least nested\n  // this is needed to replace in that order because paths may change\n  // if there are replacements in keys\n  deduplicatedMatches.sort((a, b) => {\n    // sort values first, properties next\n    if (a.field !== b.field) {\n      if (a.field === SearchField.key) {\n        return 1\n      } else {\n        return -1\n      }\n    }\n\n    // sort longest paths first, shortest last\n    return b.path.length - a.path.length\n  })\n\n  // step 3: call createSearchAndReplaceOperations for each of the matches\n  let allOperations: JSONPatchDocument = []\n  let lastNewSelection: JSONSelection | undefined\n  deduplicatedMatches.forEach((match) => {\n    // TODO: there is overlap with the logic of createSearchAndReplaceOperations. Can we extract and reuse this logic?\n    const { field, path, items } = match\n\n    if (field === SearchField.key) {\n      // replace a key\n      const parentPath = initial(path)\n      const parent = getIn(json, parentPath)\n      const oldKey = last(path) as string\n      const keys = Object.keys(parent as Record<string, unknown>)\n      const newKey = replaceAllText(oldKey, replacementText, items)\n\n      const operations = rename(parentPath, keys, oldKey, newKey)\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else if (field === SearchField.value) {\n      // replace a value\n      const currentValue: unknown | undefined = getIn(json, path)\n      if (currentValue === undefined) {\n        throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n      }\n      const currentValueText =\n        typeof currentValue === 'string' ? currentValue : String(currentValue)\n      const enforceString = getEnforceString(json, documentState, path)\n      const value = replaceAllText(currentValueText, replacementText, items)\n\n      const operations: JSONPatchOperation[] = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: enforceString ? value : stringConvert(value, parser)\n        }\n      ]\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else {\n      throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n    }\n  })\n\n  return {\n    operations: allOperations,\n    newSelection: lastNewSelection\n  }\n}\n\nexport interface SplitValuePart {\n  text: string\n  type: 'normal' | 'highlight'\n  active: boolean\n}\n\n/**\n * Split the text into separate parts for each search result and the text\n * in between.\n */\nexport function splitValue(text: string, matches: ExtendedSearchResultItem[]): SplitValuePart[] {\n  const parts: SplitValuePart[] = []\n\n  let previousEnd = 0\n\n  for (const match of matches) {\n    const precedingText = text.slice(previousEnd, match.start)\n    if (precedingText !== '') {\n      parts.push({\n        type: 'normal',\n        text: precedingText,\n        active: false\n      })\n    }\n\n    const matchingText = text.slice(match.start, match.end)\n    parts.push({\n      type: 'highlight',\n      text: matchingText,\n      active: match.active\n    })\n\n    previousEnd = match.end\n  }\n\n  const lastMatch = last(matches)\n  if (lastMatch && lastMatch.end < text.length) {\n    parts.push({\n      type: 'normal',\n      text: text.slice(lastMatch.end),\n      active: false\n    })\n  }\n\n  return parts\n}\n\n/**\n * Get the path of the search result property on a nested search result\n */\nfunction getSearchResultPath(searchResultItem: SearchResultItem): JSONPath {\n  return searchResultItem.path.concat(searchResultItem.field, String(searchResultItem.fieldIndex))\n}\n\n/**\n * Filter key search results.\n * Returns a non-empty array, or undefined if there are no key search results\n */\nexport function filterKeySearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.key)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\n/**\n * Filter value search results.\n * Returns a non-empty array, or undefined if there are no value search results\n */\nexport function filterValueSearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.value)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\nexport const searchResultsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInSearchResults(\n  json: unknown,\n  searchResults: SearchResults | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: SearchResults) => SearchResults\n): SearchResults {\n  return updateInRecursiveState(json, searchResults, path, transform, searchResultsFactory)\n}\n\nexport function toRecursiveSearchResults(\n  json: unknown,\n  searchResultItems: ExtendedSearchResultItem[]\n): SearchResults | undefined {\n  return searchResultItems.reduce(\n    (recursiveState, searchResult) => {\n      return updateInSearchResults(json, recursiveState, searchResult.path, (_, nestedState) => ({\n        ...nestedState,\n        searchResults: nestedState.searchResults\n          ? nestedState.searchResults.concat(searchResult)\n          : [searchResult]\n      }))\n    },\n    undefined as SearchResults | undefined\n  )\n}\n\nexport function flattenSearchResults(node: SearchResults | undefined): ExtendedSearchResultItem[] {\n  const self = node?.searchResults ?? []\n\n  const nested = isObjectRecursiveState(node)\n    ? Object.values(node.properties).flatMap(flattenSearchResults)\n    : isArrayRecursiveState(node)\n      ? node.items.flatMap(flattenSearchResults)\n      : []\n\n  return self.concat(nested)\n}\n","<script lang=\"ts\">\n  import { splitValue } from '$lib/logic/search.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem } from '$lib/types'\n\n  export let text: string\n  export let searchResultItems: ExtendedSearchResultItem[]\n\n  $: parts = splitValue(String(text), searchResultItems)\n</script>\n\n{#each parts as part}\n  {#if part.type === 'normal'}\n    {part.text}\n  {:else}\n    <span class=\"jse-highlight\" class:jse-active={part.active}>{addNewLineSuffix(part.text)}</span>\n  {/if}\n{/each}\n\n<style src=\"./SearchResultHighlighter.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isUrl } from '$lib/utils/typeUtils.js'\n  import { createEditValueSelection } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from '../../../components/modes/treemode/highlight/SearchResultHighlighter.svelte'\n  import { getValueClass } from './utils/getValueClass.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import {\n    type ExtendedSearchResultItem,\n    type JSONParser,\n    type Mode,\n    type OnJSONSelect,\n    type ValueNormalization\n  } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let mode: Mode\n  export let readOnly: boolean\n  export let normalization: ValueNormalization\n  export let parser: JSONParser\n  export let onSelect: OnJSONSelect\n\n  export let searchResultItems: ExtendedSearchResultItem[] | undefined\n\n  $: valueIsUrl = isUrl(value)\n\n  function handleValueClick(event: MouseEvent) {\n    if (typeof value === 'string' && valueIsUrl && isCtrlKeyDown(event)) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      window.open(value, '_blank')\n    }\n  }\n\n  function handleValueDoubleClick(event: MouseEvent) {\n    if (!readOnly) {\n      event.preventDefault()\n      onSelect(createEditValueSelection(path))\n    }\n  }\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<div\n  role=\"button\"\n  tabindex=\"-1\"\n  data-type=\"selectable-value\"\n  class={getValueClass(value, mode, parser)}\n  on:click={handleValueClick}\n  on:dblclick={handleValueDoubleClick}\n  title={valueIsUrl ? 'Ctrl+Click or Ctrl+Enter to open url in new window' : undefined}\n>\n  {#if searchResultItems}\n    <SearchResultHighlighter text={normalization.escapeValue(value)} {searchResultItems} />\n  {:else}\n    {addNewLineSuffix(normalization.escapeValue(value))}\n  {/if}\n</div>\n\n<style src=\"./ReadonlyValue.scss\"></style>\n","<script lang=\"ts\">\n  export let text: string\n</script>\n\n<div class=\"jse-tooltip\">\n  {text}\n</div>\n\n<style src=\"./Tooltip.scss\"></style>\n","import Tooltip from './Tooltip.svelte'\nimport type { SvelteComponent } from 'svelte'\nimport type { AbsolutePopupOptions } from '$lib/types'\n\nexport interface TooltipOptions {\n  text: string\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport function tooltip(\n  node: Element,\n  { text, openAbsolutePopup, closeAbsolutePopup }: TooltipOptions\n) {\n  let popupId: number | undefined\n\n  function handleMouseEnter() {\n    const props = {\n      text\n    }\n\n    // opening popup will fail if there is already a popup open\n    popupId = openAbsolutePopup(Tooltip, props, {\n      position: 'top',\n      width: 10 * text.length, // rough estimate of the width of the message\n      offsetTop: 3,\n      anchor: node,\n      closeOnOuterClick: true\n    })\n  }\n\n  function handleMouseLeave() {\n    closeAbsolutePopup(popupId)\n  }\n\n  node.addEventListener('mouseenter', handleMouseEnter)\n  node.addEventListener('mouseleave', handleMouseLeave)\n\n  return {\n    destroy() {\n      node.removeEventListener('mouseenter', handleMouseEnter)\n      node.removeEventListener('mouseleave', handleMouseLeave)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faClock } from '@fortawesome/free-regular-svg-icons'\n  import { getContext } from 'svelte'\n  import { tooltip } from '$lib/components/controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let value: number\n\n  $: text = `Time: ${new Date(value).toString()}`\n</script>\n\n<div class=\"jse-timestamp\" use:tooltip={{ text, ...absolutePopupContext }}>\n  <Icon data={faClock} />\n</div>\n\n<style src=\"./TimestampTag.scss\"></style>\n","import { isBoolean, isColor, isTimestamp } from '$lib/utils/typeUtils.js'\nimport type { RenderValueComponentDescription, RenderValueProps } from '$lib/types'\nimport BooleanToggle from './components/BooleanToggle.svelte'\nimport ColorPicker from './components/ColorPicker.svelte'\nimport EditableValue from './components/EditableValue.svelte'\nimport ReadonlyValue from './components/ReadonlyValue.svelte'\nimport TimestampTag from './components/TimestampTag.svelte'\n\nexport function renderValue({\n  path,\n  value,\n  mode,\n  readOnly,\n  selection,\n  enforceString,\n  searchResultItems,\n  isEditing,\n  parser,\n  normalization,\n  onPatch,\n  onPasteJson,\n  onSelect,\n  onFind,\n  findNextInside,\n  focus\n}: RenderValueProps): RenderValueComponentDescription[] {\n  const renderers: RenderValueComponentDescription[] = []\n\n  if (!isEditing && isBoolean(value)) {\n    renderers.push({\n      component: BooleanToggle,\n      props: { path, value, readOnly, onPatch, focus }\n    })\n  }\n\n  if (!isEditing && isColor(value)) {\n    renderers.push({\n      component: ColorPicker,\n      props: { path, value, readOnly, onPatch, focus }\n    })\n  }\n\n  if (isEditing) {\n    renderers.push({\n      component: EditableValue,\n      props: {\n        path,\n        value,\n        selection,\n        mode,\n        enforceString,\n        parser,\n        normalization,\n        onPatch,\n        onPasteJson,\n        onSelect,\n        onFind,\n        findNextInside,\n        focus\n      }\n    })\n  }\n\n  if (!isEditing) {\n    renderers.push({\n      component: ReadonlyValue,\n      props: { path, value, mode, readOnly, parser, normalization, searchResultItems, onSelect }\n    })\n  }\n\n  if (!isEditing && isTimestamp(value)) {\n    renderers.push({\n      component: TimestampTag,\n      props: { value }\n    })\n  }\n\n  return renderers\n}\n","import { isEmpty } from 'lodash-es'\nimport type { JSONPath } from 'immutable-json-patch'\nimport type { PathOption } from '$lib/types.js'\n\n/**\n **\n * Stringify an array with a path like ['items', '3', 'name'] into string like 'items[3].name'\n * Note that we allow all characters in a property name, like \"item with spaces[3].name\",\n * so this path is not usable as-is in JavaScript.\n */\nexport function stringifyJSONPath(path: JSONPath): string {\n  return path\n    .map((p, index) => {\n      return integerNumberRegex.test(p)\n        ? '[' + p + ']'\n        : /[.[\\]]/.test(p) || p === '' // match any character . or [ or ] and handle an empty string\n          ? '[\"' + escapeQuotes(p) + '\"]'\n          : (index > 0 ? '.' : '') + p\n    })\n    .join('')\n}\n\nfunction escapeQuotes(prop: string): string {\n  return prop.replace(/\"/g, '\\\\\"')\n}\n\n/**\n * Parse a JSON path like 'items[3].name' into a path like ['items', '3', 'name']\n */\nexport function parseJSONPath(pathStr: string): JSONPath {\n  const path: JSONPath = []\n  let i = 0\n\n  while (i < pathStr.length) {\n    if (pathStr[i] === '.') {\n      i++\n    }\n\n    if (pathStr[i] === '[') {\n      i++\n\n      if (pathStr[i] === '\"') {\n        i++\n        path.push(parseProp((c) => c === '\"', true))\n        eatCharacter('\"')\n      } else {\n        path.push(parseProp((c) => c === ']'))\n      }\n\n      eatCharacter(']')\n    } else {\n      path.push(parseProp((c) => c === '.' || c === '['))\n    }\n  }\n\n  function parseProp(isEnd: (char: string) => boolean, unescape = false) {\n    let prop = ''\n\n    while (i < pathStr.length && !isEnd(pathStr[i])) {\n      if (unescape && pathStr[i] === '\\\\' && pathStr[i + 1] === '\"') {\n        // escaped double quote\n        prop += '\"'\n        i += 2\n      } else {\n        prop += pathStr[i]\n        i++\n      }\n    }\n\n    return prop\n  }\n\n  function eatCharacter(char: string) {\n    if (pathStr[i] !== char) {\n      throw new SyntaxError(`Invalid JSON path: ${char} expected at position ${i}`)\n    }\n    i++\n  }\n\n  return path\n}\n\n/**\n * Convert a JSONPath into an option for use in a select box\n */\nexport function pathToOption(path: JSONPath): PathOption {\n  return {\n    value: path,\n    label: isEmpty(path) ? '(item root)' : stringifyJSONPath(path)\n  }\n}\n\n/**\n * Stringify a JSON path into a lodash path like:\n *\n *     [\"data\", 2, \"nested property\", \"name\"]\n *\n * into a lodash path like:\n *\n *     \"data[2].nested.name\"\n *\n */\nexport function createLodashPropertySelector(path: JSONPath): string {\n  return path.length === 0\n    ? ''\n    : path.every((prop) => integerNumberRegex.test(prop) || javaScriptPropertyRegex.test(prop))\n      ? \"'\" + path.map(stringifyLodashProperty).join('').replace(/^\\./, '') + \"'\"\n      : JSON.stringify(path)\n}\n\n/**\n * Stringify a single property of a JSON path. See also createLodashPropertySelector\n */\nfunction stringifyLodashProperty(prop: string): string {\n  if (integerNumberRegex.test(prop)) {\n    return '[' + prop + ']'\n  } else if (javaScriptPropertyRegex.test(prop)) {\n    return '.' + prop\n  } else {\n    const propStr = JSON.stringify(prop)\n    // remove enclosing double quotes, and unescape escaped double quotes \\\"\n    const jsonPathStr = propStr.substring(1, propStr.length - 1).replace(/\\\\\"/g, '\"')\n    return \"['\" + jsonPathStr + \"']\"\n  }\n}\n\n/**\n * Create a JavaScript property selector\n *\n * Turn a paths like:\n *\n *   ['location', 'latitude']\n *   ['address', 'full name']\n *\n * into a JavaScript selector (string) like:\n *\n *   '?.location?.latitude'\n *   '?.address?.[\"full name\"]'\n */\nexport function createPropertySelector(path: JSONPath): string {\n  return path\n    .map((prop) => {\n      if (integerNumberRegex.test(prop)) {\n        // an index\n        return `?.[${prop}]`\n      } else if (javaScriptPropertyRegex.test(prop)) {\n        // a key without special characters\n        return `?.${prop}`\n      } else {\n        // a key that may have special characters (like spaces or so)\n        return `?.[${JSON.stringify(prop)}]`\n      }\n    })\n    .join('')\n}\n\n// https://developer.mozilla.org/en-US/docs/Glossary/Identifier\n// Note: We can extend this regex to allow unicode characters too.\n// I'm too lazy to figure that out right now\nconst javaScriptPropertyRegex = /^[a-zA-Z$_][a-zA-Z$_\\d]*$/\nconst integerNumberRegex = /^\\d+$/\n","import type { QueryLanguageOptions } from '$lib/types.js'\n\nexport interface TransformModalState {\n  queryLanguageId: string\n  queryOptions: QueryLanguageOptions\n  query: string\n  isManual: boolean\n}\n\nexport const transformModalStates: Record<string, TransformModalState> = {}\n\nexport interface TransformModalStateShared {\n  showWizard: boolean\n  showOriginal: boolean\n}\n\nexport const transformModalStateShared: TransformModalStateShared = {\n  showWizard: true,\n  showOriginal: true\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","export default function filter({\n    loadOptions,\n    filterText,\n    items,\n    multiple,\n    value,\n    itemId,\n    groupBy,\n    filterSelectedItems,\n    itemFilter,\n    convertStringItemsToObjects,\n    filterGroupedItems,\n    label,\n}) {\n    if (items && loadOptions) return items;\n    if (!items) return [];\n\n    if (items && items.length > 0 && typeof items[0] !== 'object') {\n        items = convertStringItemsToObjects(items);\n    }\n\n    let filterResults = items.filter((item) => {\n        let matchesFilter = itemFilter(item[label], filterText, item);\n        if (matchesFilter && multiple && value?.length) {\n            matchesFilter = !value.some((x) => {\n                return filterSelectedItems ? x[itemId] === item[itemId] : false;\n            });\n        }\n\n        return matchesFilter;\n    });\n\n    if (groupBy) {\n        filterResults = filterGroupedItems(filterResults);\n    }\n\n    return filterResults;\n}\n","export default async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {\n    let res = await loadOptions(filterText).catch((err) => {\n        console.warn('svelte-select loadOptions error :>> ', err);\n        dispatch('error', { type: 'loadOptions', details: err });\n    });\n\n    if (res && !res.cancelled) {        \n        if (res) {\n            if (res && res.length > 0 && typeof res[0] !== 'object') {\n                res = convertStringItemsToObjects(res);\n            }\n            \n            dispatch('loaded', { items: res });\n        } else {\n            res = [];\n        }\n\n        return {\n            filteredItems: res,\n            loading: false,\n            focused: true,\n            listOpen: true,\n        };\n    }\n}\n","<svg\n    width=\"100%\"\n    height=\"100%\"\n    viewBox=\"0 0 20 20\"\n    focusable=\"false\"\n    aria-hidden=\"true\">\n    <path\n    fill=\"currentColor\"\n        d=\"M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z\" />\n</svg>\n\n<style>\n  svg {\n      width: var(--chevron-icon-width, 20px);\n      height: var(--chevron-icon-width, 20px);\n      color: var(--chevron-icon-colour, currentColor);\n  }\n</style>","<svg\n    width=\"100%\"\n    height=\"100%\"\n    viewBox=\"-2 -2 50 50\"\n    focusable=\"false\"\n    aria-hidden=\"true\"\n    role=\"presentation\"\n>\n    <path\n        fill=\"currentColor\"\n        d=\"M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z\"\n    />\n</svg>\n\n<style>\n    svg {\n        width: var(--clear-icon-width, 20px);\n        height: var(--clear-icon-width, 20px);\n        color: var(--clear-icon-color, currentColor);\n    }\n</style>","<svg class=\"loading\" viewBox=\"25 25 50 50\">\n    <circle\n        class=\"circle_path\"\n        cx=\"50\"\n        cy=\"50\"\n        r=\"20\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        stroke-width=\"5\"\n        stroke-miterlimit=\"10\" />\n</svg>\n\n<style>\n    .loading {\n        width: var(--spinner-width, 20px);\n        height: var(--spinner-height, 20px);\n        color: var(--spinner-color, var(--icons-color));\n        animation: rotate 0.75s linear infinite;\n        transform-origin: center center;\n        transform: none;\n    }\n\n    .circle_path {\n        stroke-dasharray: 90;\n        stroke-linecap: round;\n    }\n\n    @keyframes rotate {\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n</style>","<script>\n    import { beforeUpdate, createEventDispatcher, onDestroy, onMount } from 'svelte';\n    import { offset, flip, shift } from 'svelte-floating-ui/dom';\n    import { createFloatingActions } from 'svelte-floating-ui';\n\n    const dispatch = createEventDispatcher();\n\n    import _filter from './filter';\n    import _getItems from './get-items';\n\n    import ChevronIcon from './ChevronIcon.svelte';\n    import ClearIcon from './ClearIcon.svelte';\n    import LoadingIcon from './LoadingIcon.svelte';\n\n    export let justValue = null; // read-only\n\n    export let filter = _filter;\n    export let getItems = _getItems;\n\n    export let id = null;\n    export let name = null;\n    export let container = undefined;\n    export let input = undefined;\n    export let multiple = false;\n    export let multiFullItemClearable = false;\n    export let disabled = false;\n    export let focused = false;\n    export let value = null;\n    export let filterText = '';\n    export let placeholder = 'Please select';\n    export let placeholderAlwaysShow = false;\n    export let items = null;\n    export let label = 'label';\n    export let itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase());\n    export let groupBy = undefined;\n    export let groupFilter = (groups) => groups;\n    export let groupHeaderSelectable = false;\n    export let itemId = 'value';\n    export let loadOptions = undefined;\n    export let containerStyles = '';\n    export let hasError = false;\n    export let filterSelectedItems = true;\n    export let required = false;\n    export let closeListOnChange = true;\n    export let clearFilterTextOnBlur = true;\n\n    export let createGroupHeaderItem = (groupValue, item) => {\n        return {\n            value: groupValue,\n            [label]: groupValue,\n        };\n    };\n\n    export const getFilteredItems = () => {\n        return filteredItems;\n    };\n\n    export let searchable = true;\n    export let inputStyles = '';\n    export let clearable = true;\n    export let loading = false;\n    export let listOpen = false;\n\n    let timeout;\n    export let debounce = (fn, wait = 1) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    };\n\n    export let debounceWait = 300;\n    export let hideEmptyState = false;\n    export let inputAttributes = {};\n    export let listAutoWidth = true;\n    export let showChevron = false;\n    export let listOffset = 5;\n    export let hoverItemIndex = 0;\n    export let floatingConfig = {};\n\n    export { containerClasses as class };\n\n    let containerClasses = '';\n    let activeValue;\n    let prev_value;\n    let prev_filterText;\n    let prev_multiple;\n\n    function setValue() {\n        if (typeof value === 'string') {\n            let item = (items || []).find((item) => item[itemId] === value);\n            value = item || {\n                [itemId]: value,\n                label: value,\n            };\n        } else if (multiple && Array.isArray(value) && value.length > 0) {\n            value = value.map((item) => (typeof item === 'string' ? { value: item, label: item } : item));\n        }\n    }\n\n    let _inputAttributes;\n    function assignInputAttributes() {\n        _inputAttributes = Object.assign(\n            {\n                autocapitalize: 'none',\n                autocomplete: 'off',\n                autocorrect: 'off',\n                spellcheck: false,\n                tabindex: 0,\n                type: 'text',\n                'aria-autocomplete': 'list',\n            },\n            inputAttributes\n        );\n\n        if (id) {\n            _inputAttributes['id'] = id;\n        }\n\n        if (!searchable) {\n            _inputAttributes['readonly'] = true;\n        }\n    }\n\n    function convertStringItemsToObjects(_items) {\n        return _items.map((item, index) => {\n            return {\n                index,\n                value: item,\n                label: `${item}`,\n            };\n        });\n    }\n\n    function filterGroupedItems(_items) {\n        const groupValues = [];\n        const groups = {};\n\n        _items.forEach((item) => {\n            const groupValue = groupBy(item);\n\n            if (!groupValues.includes(groupValue)) {\n                groupValues.push(groupValue);\n                groups[groupValue] = [];\n\n                if (groupValue) {\n                    groups[groupValue].push(\n                        Object.assign(createGroupHeaderItem(groupValue, item), {\n                            id: groupValue,\n                            groupHeader: true,\n                            selectable: groupHeaderSelectable,\n                        })\n                    );\n                }\n            }\n\n            groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));\n        });\n\n        const sortedGroupedItems = [];\n\n        groupFilter(groupValues).forEach((groupValue) => {\n            if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);\n        });\n\n        return sortedGroupedItems;\n    }\n\n    function dispatchSelectedItem() {\n        if (multiple) {\n            if (JSON.stringify(value) !== JSON.stringify(prev_value)) {\n                if (checkValueForDuplicates()) {\n                    dispatch('input', value);\n                }\n            }\n            return;\n        }\n\n        if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {\n            dispatch('input', value);\n        }\n    }\n\n    function setupMulti() {\n        if (value) {\n            if (Array.isArray(value)) {\n                value = [...value];\n            } else {\n                value = [value];\n            }\n        }\n    }\n\n    function setupSingle() {\n        if (value) value = null;\n    }\n\n    $: if ((items, value)) setValue();\n    $: if (inputAttributes || !searchable) assignInputAttributes();\n    $: if (multiple) setupMulti();\n    $: if (prev_multiple && !multiple) setupSingle();\n    $: if (multiple && value && value.length > 1) checkValueForDuplicates();\n    $: if (value) dispatchSelectedItem();\n    $: if (!value && multiple && prev_value) dispatch('input', value);\n    $: if (!focused && input) closeList();\n    $: if (filterText !== prev_filterText) setupFilterText();\n    $: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();\n    $: dispatchHover(hoverItemIndex);\n\n    function setValueIndexAsHoverIndex() {\n        const valueIndex = filteredItems.findIndex((i) => {\n            return i[itemId] === value[itemId];\n        });\n\n        checkHoverSelectable(valueIndex, true);\n    }\n\n    function dispatchHover(i) {\n        dispatch('hoverItem', i);\n    }\n\n    function checkHoverSelectable(startingIndex = 0, ignoreGroup) {\n        hoverItemIndex = startingIndex < 0 ? 0 : startingIndex;\n        if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {\n            setHoverIndex(1);\n        }\n    }\n\n    function setupFilterText() {\n        if (!loadOptions && filterText.length === 0) return;\n\n        if (loadOptions) {\n            debounce(async function () {\n                loading = true;\n                let res = await getItems({\n                    dispatch,\n                    loadOptions,\n                    convertStringItemsToObjects,\n                    filterText,\n                });\n\n                if (res) {\n                    loading = res.loading;\n                    listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false;\n                    focused = listOpen && res.focused;\n                    items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems;\n                } else {\n                    loading = false;\n                    focused = true;\n                    listOpen = true;\n                }\n            }, debounceWait);\n        } else {\n            listOpen = true;\n\n            if (multiple) {\n                activeValue = undefined;\n            }\n        }\n    }\n\n    $: hasValue = multiple ? value && value.length > 0 : value;\n    $: hideSelectedItem = hasValue && filterText.length > 0;\n    $: showClear = hasValue && clearable && !disabled && !loading;\n    $: placeholderText =\n        placeholderAlwaysShow && multiple\n            ? placeholder\n            : multiple && value?.length === 0\n            ? placeholder\n            : value\n            ? ''\n            : placeholder;\n    $: ariaSelection = value ? handleAriaSelection(multiple) : '';\n    $: ariaContext = handleAriaContent({ filteredItems, hoverItemIndex, focused, listOpen });\n    $: updateValueDisplay(items);\n    $: justValue = computeJustValue(multiple, value, itemId);\n    $: if (!multiple && prev_value && !value) dispatch('input', value);\n    $: filteredItems = filter({\n        loadOptions,\n        filterText,\n        items,\n        multiple,\n        value,\n        itemId,\n        groupBy,\n        label,\n        filterSelectedItems,\n        itemFilter,\n        convertStringItemsToObjects,\n        filterGroupedItems,\n    });\n    $: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();\n    $: handleFilterEvent(filteredItems);\n    $: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));\n    $: listDom = !!list;\n    $: listMounted(list, listOpen);\n    $: if (listOpen && container && list) setListWidth();\n    $: scrollToHoverItem = hoverItemIndex;\n    $: if (listOpen && multiple) hoverItemIndex = 0;\n    $: if (input && listOpen && !focused) handleFocus();\n    $: if (filterText) hoverItemIndex = 0;\n\n    function handleFilterEvent(items) {\n        if (listOpen) dispatch('filter', items);\n    }\n\n    beforeUpdate(async () => {\n        prev_value = value;\n        prev_filterText = filterText;\n        prev_multiple = multiple;\n    });\n\n    function computeJustValue() {\n        if (multiple) return value ? value.map((item) => item[itemId]) : null;\n        return value ? value[itemId] : value;\n    }\n\n    function checkValueForDuplicates() {\n        let noDuplicates = true;\n        if (value) {\n            const ids = [];\n            const uniqueValues = [];\n\n            value.forEach((val) => {\n                if (!ids.includes(val[itemId])) {\n                    ids.push(val[itemId]);\n                    uniqueValues.push(val);\n                } else {\n                    noDuplicates = false;\n                }\n            });\n\n            if (!noDuplicates) value = uniqueValues;\n        }\n        return noDuplicates;\n    }\n\n    function findItem(selection) {\n        let matchTo = selection ? selection[itemId] : value[itemId];\n        return items.find((item) => item[itemId] === matchTo);\n    }\n\n    function updateValueDisplay(items) {\n        if (!items || items.length === 0 || items.some((item) => typeof item !== 'object')) return;\n        if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId])) return;\n\n        if (Array.isArray(value)) {\n            value = value.map((selection) => findItem(selection) || selection);\n        } else {\n            value = findItem() || value;\n        }\n    }\n\n    async function handleMultiItemClear(i) {\n        const itemToRemove = value[i];\n\n        if (value.length === 1) {\n            value = undefined;\n        } else {\n            value = value.filter((item) => {\n                return item !== itemToRemove;\n            });\n        }\n\n        dispatch('clear', itemToRemove);\n    }\n\n    function handleKeyDown(e) {\n        if (!focused) return;\n        e.stopPropagation();\n        switch (e.key) {\n            case 'Escape':\n                e.preventDefault();\n                closeList();\n                break;\n            case 'Enter':\n                e.preventDefault();\n\n                if (listOpen) {\n                    if (filteredItems.length === 0) break;\n                    const hoverItem = filteredItems[hoverItemIndex];\n\n                    if (value && !multiple && value[itemId] === hoverItem[itemId]) {\n                        closeList();\n                        break;\n                    } else {\n                        handleSelect(filteredItems[hoverItemIndex]);\n                    }\n                }\n\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(-1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'Tab':\n                if (listOpen && focused) {\n                    if (\n                        filteredItems.length === 0 ||\n                        (value && value[itemId] === filteredItems[hoverItemIndex][itemId])\n                    )\n                        return closeList();\n\n                    e.preventDefault();\n                    handleSelect(filteredItems[hoverItemIndex]);\n                    closeList();\n                }\n\n                break;\n            case 'Backspace':\n                if (!multiple || filterText.length > 0) return;\n\n                if (multiple && value && value.length > 0) {\n                    handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);\n                    if (activeValue === 0 || activeValue === undefined) break;\n                    activeValue = value.length > activeValue ? activeValue - 1 : undefined;\n                }\n\n                break;\n            case 'ArrowLeft':\n                if (!value || !multiple || filterText.length > 0) return;\n                if (activeValue === undefined) {\n                    activeValue = value.length - 1;\n                } else if (value.length > activeValue && activeValue !== 0) {\n                    activeValue -= 1;\n                }\n                break;\n            case 'ArrowRight':\n                if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;\n                if (activeValue === value.length - 1) {\n                    activeValue = undefined;\n                } else if (activeValue < value.length - 1) {\n                    activeValue += 1;\n                }\n                break;\n        }\n    }\n\n    function handleFocus(e) {\n        if (focused && input === document?.activeElement) return;\n        if (e) dispatch('focus', e);\n        input?.focus();\n        focused = true;\n    }\n\n    async function handleBlur(e) {\n        if (isScrolling) return;\n        if (listOpen || focused) {\n            dispatch('blur', e);\n            closeList();\n            focused = false;\n            activeValue = undefined;\n            input?.blur();\n        }\n    }\n\n    function handleClick() {\n        if (disabled) return;\n        if (filterText.length > 0) return listOpen = true;\n        listOpen = !listOpen;\n    }\n\n    export function handleClear() {\n        dispatch('clear', value);\n        value = undefined;\n        closeList();\n        handleFocus();\n    }\n\n    onMount(() => {\n        if (listOpen) focused = true;\n        if (focused && input) input.focus();\n    });\n\n    function itemSelected(selection) {\n        if (selection) {\n            filterText = '';\n            const item = Object.assign({}, selection);\n\n            if (item.groupHeader && !item.selectable) return;\n            value = multiple ? (value ? value.concat([item]) : [item]) : (value = item);\n\n            setTimeout(() => {\n                if (closeListOnChange) closeList();\n                activeValue = undefined;\n                dispatch('change', value);\n                dispatch('select', selection);\n            });\n        }\n    }\n\n    function closeList() {\n        if (clearFilterTextOnBlur) {\n            filterText = '';\n        }\n        listOpen = false;\n    }\n\n    export let ariaValues = (values) => {\n        return `Option ${values}, selected.`;\n    };\n\n    export let ariaListOpen = (label, count) => {\n        return `You are currently focused on option ${label}. There are ${count} results available.`;\n    };\n\n    export let ariaFocused = () => {\n        return `Select is focused, type to refine list, press down to open the menu.`;\n    };\n\n    function handleAriaSelection(_multiple) {\n        let selected = undefined;\n\n        if (_multiple && value.length > 0) {\n            selected = value.map((v) => v[label]).join(', ');\n        } else {\n            selected = value[label];\n        }\n\n        return ariaValues(selected);\n    }\n\n    function handleAriaContent() {\n        if (!filteredItems || filteredItems.length === 0) return '';\n        let _item = filteredItems[hoverItemIndex];\n        if (listOpen && _item) {\n            let count = filteredItems ? filteredItems.length : 0;\n            return ariaListOpen(_item[label], count);\n        } else {\n            return ariaFocused();\n        }\n    }\n\n    let list = null;\n\n    let isScrollingTimer;\n    function handleListScroll() {\n        clearTimeout(isScrollingTimer);\n        isScrollingTimer = setTimeout(() => {\n            isScrolling = false;\n        }, 100);\n    }\n\n    function handleClickOutside(event) {\n        if (!listOpen && !focused && container && !container.contains(event.target) && !list?.contains(event.target)) {\n            handleBlur();\n        }\n    }\n\n    onDestroy(() => {\n        list?.remove();\n    });\n\n    let isScrolling = false;\n\n    function handleSelect(item) {\n        if (!item || item.selectable === false) return;\n        itemSelected(item);\n    }\n\n    function handleHover(i) {\n        if (isScrolling) return;\n        hoverItemIndex = i;\n    }\n\n    function handleItemClick(args) {\n        const { item, i } = args;\n        if (item?.selectable === false) return;\n        if (value && !multiple && value[itemId] === item[itemId]) return closeList();\n        if (isItemSelectable(item)) {\n            hoverItemIndex = i;\n            handleSelect(item);\n        }\n    }\n\n    function setHoverIndex(increment) {\n        let selectableFilteredItems = filteredItems.filter(\n            (item) => !Object.hasOwn(item, 'selectable') || item.selectable === true\n        );\n\n        if (selectableFilteredItems.length === 0) {\n            return (hoverItemIndex = 0);\n        }\n\n        if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {\n            hoverItemIndex = 0;\n        } else if (increment < 0 && hoverItemIndex === 0) {\n            hoverItemIndex = filteredItems.length - 1;\n        } else {\n            hoverItemIndex = hoverItemIndex + increment;\n        }\n\n        const hover = filteredItems[hoverItemIndex];\n\n        if (hover && hover.selectable === false) {\n            if (increment === 1 || increment === -1) setHoverIndex(increment);\n            return;\n        }\n    }\n\n    function isItemActive(item, value, itemId) {\n        if (multiple) return;\n        return value && value[itemId] === item[itemId];\n    }\n\n    function isItemFirst(itemIndex) {\n        return itemIndex === 0;\n    }\n\n    function isItemSelectable(item) {\n        return (item.groupHeader && item.selectable) || item.selectable || !item.hasOwnProperty('selectable');\n    }\n\n    const activeScroll = scrollAction;\n    const hoverScroll = scrollAction;\n\n    function scrollAction(node) {\n        return {\n            update(args) {\n                if (args.scroll) {\n                    handleListScroll();\n                    node.scrollIntoView({ behavior: 'auto', block: 'nearest' });\n                }\n            },\n        };\n    }\n\n    function setListWidth() {\n        const { width } = container.getBoundingClientRect();\n        list.style.width = listAutoWidth ? width + 'px' : 'auto';\n    }\n\n    let _floatingConfig = {\n        strategy: 'absolute',\n        placement: 'bottom-start',\n        middleware: [offset(listOffset), flip(), shift()],\n        autoUpdate: false,\n    };\n\n    const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);\n\n    $: if (container && floatingConfig?.autoUpdate === undefined) {\n        _floatingConfig.autoUpdate = true;\n    }\n\n    let prefloat = true;\n    function listMounted(list, listOpen) {\n        if (!list || !listOpen) return (prefloat = true);\n        setTimeout(() => {\n            prefloat = false;\n        }, 0);\n    }\n</script>\n\n<svelte:window on:click={handleClickOutside} on:keydown={handleKeyDown} />\n\n<div\n    class=\"svelte-select {containerClasses}\"\n    class:multi={multiple}\n    class:disabled\n    class:focused\n    class:list-open={listOpen}\n    class:show-chevron={showChevron}\n    class:error={hasError}\n    style={containerStyles}\n    on:pointerup|preventDefault={handleClick}\n    bind:this={container}\n    use:floatingRef\n    role=\"none\">\n    {#if listOpen}\n        <div\n            use:floatingContent\n            bind:this={list}\n            class=\"svelte-select-list\"\n            class:prefloat\n            on:scroll={handleListScroll}\n            on:pointerup|preventDefault|stopPropagation\n            on:mousedown|preventDefault|stopPropagation\n\t\t\trole=\"none\">\n            {#if $$slots['list-prepend']}<slot name=\"list-prepend\" />{/if}\n            {#if $$slots.list}<slot name=\"list\" {filteredItems} />\n            {:else if filteredItems.length > 0}\n                {#each filteredItems as item, i}\n                    <div\n                        on:mouseover={() => handleHover(i)}\n                        on:focus={() => handleHover(i)}\n                        on:click|stopPropagation={() => handleItemClick({ item, i })}\n                        on:keydown|preventDefault|stopPropagation\n                        class=\"list-item\"\n                        tabindex=\"-1\"\n                        role=\"none\">\n                        <div\n                            use:activeScroll={{ scroll: isItemActive(item, value, itemId), listDom }}\n                            use:hoverScroll={{ scroll: scrollToHoverItem === i, listDom }}\n                            class=\"item\"\n                            class:list-group-title={item.groupHeader}\n                            class:active={isItemActive(item, value, itemId)}\n                            class:first={isItemFirst(i)}\n                            class:hover={hoverItemIndex === i}\n                            class:group-item={item.groupItem}\n                            class:not-selectable={item?.selectable === false}>\n                            <slot name=\"item\" {item} index={i}>\n                                {item?.[label]}\n                            </slot>\n                        </div>\n                    </div>\n                {/each}\n            {:else if !hideEmptyState}\n                <slot name=\"empty\">\n                    <div class=\"empty\">No options</div>\n                </slot>\n            {/if}\n            {#if $$slots['list-append']}<slot name=\"list-append\" />{/if}\n        </div>\n    {/if}\n\n    <span aria-live=\"polite\" aria-atomic=\"false\" aria-relevant=\"additions text\" class=\"a11y-text\">\n        {#if focused}\n            <span id=\"aria-selection\">{ariaSelection}</span>\n            <span id=\"aria-context\">\n                {ariaContext}\n            </span>\n        {/if}\n    </span>\n\n    <div class=\"prepend\">\n        <slot name=\"prepend\" />\n    </div>\n\n    <div class=\"value-container\">\n        {#if hasValue}\n            {#if multiple}\n                {#each value as item, i}\n                    <div\n                        class=\"multi-item\"\n                        class:active={activeValue === i}\n                        class:disabled\n                        on:click|preventDefault={() => (multiFullItemClearable ? handleMultiItemClear(i) : {})}\n                        on:keydown|preventDefault|stopPropagation\n                        role=\"none\">\n                        <span class=\"multi-item-text\">\n                            <slot name=\"selection\" selection={item} index={i}>\n                                {item[label]}\n                            </slot>\n                        </span>\n\n                        {#if !disabled && !multiFullItemClearable && ClearIcon}\n                            <div\n                                class=\"multi-item-clear\"\n                                on:pointerup|preventDefault|stopPropagation={() => handleMultiItemClear(i)}>\n                                <slot name=\"multi-clear-icon\">\n                                    <ClearIcon />\n                                </slot>\n                            </div>\n                        {/if}\n                    </div>\n                {/each}\n            {:else}\n                <div class=\"selected-item\" class:hide-selected-item={hideSelectedItem}>\n                    <slot name=\"selection\" selection={value}>\n                        {value[label]}\n                    </slot>\n                </div>\n            {/if}\n        {/if}\n\n        <input\n            on:keydown={handleKeyDown}\n            on:blur={handleBlur}\n            on:focus={handleFocus}\n            readOnly={!searchable}\n            {..._inputAttributes}\n            bind:this={input}\n            bind:value={filterText}\n            placeholder={placeholderText}\n            style={inputStyles}\n            {disabled} />\n    </div>\n\n    <div class=\"indicators\">\n        {#if loading}\n            <div class=\"icon loading\" aria-hidden=\"true\">\n                <slot name=\"loading-icon\">\n                    <LoadingIcon />\n                </slot>\n            </div>\n        {/if}\n\n        {#if showClear}\n            <button type=\"button\" class=\"icon clear-select\" on:click={handleClear}>\n                <slot name=\"clear-icon\">\n                    <ClearIcon />\n                </slot>\n            </button>\n        {/if}\n\n        {#if showChevron}\n            <div class=\"icon chevron\" aria-hidden=\"true\">\n                <slot name=\"chevron-icon\" {listOpen}>\n                    <ChevronIcon />\n                </slot>\n            </div>\n        {/if}\n    </div>\n\n    <slot name=\"input-hidden\" {value}>\n        <input {name} type=\"hidden\" value={value ? JSON.stringify(value) : null} />\n    </slot>\n\n    {#if required && (!value || value.length === 0)}\n        <slot name=\"required\" {value}>\n            <select class=\"required\" required tabindex=\"-1\" aria-hidden=\"true\" />\n        </slot>\n    {/if}\n</div>\n\n<style>\n    .svelte-select {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    * {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend,\n    .indicators {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    :not(.multi) > .value-container > input {\n        width: 100%;\n        height: 100%;\n    }\n\n    input::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled input::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi .selected-item {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item:focus {\n        outline: none;\n    }\n\n    .hide-selected-item {\n        opacity: 0;\n    }\n\n    .icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi input {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable,\n    .item.hover.item.not-selectable,\n    .item.active.item.not-selectable,\n    .item.not-selectable:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n</style>\n","//@ts-ignore\nimport { arrow as arrowCore } from \"./core\";\nimport { autoUpdate as _autoUpdate, computePosition } from \"./dom/index.js\";\nimport { get } from \"svelte/store\";\nimport { onDestroy, tick } from 'svelte';\nexport function createFloatingActions(initOptions) {\n    let referenceElement;\n    let floatingElement;\n    const defaultOptions = {\n        autoUpdate: true\n    };\n    let options = initOptions;\n    const getOptions = (mixin) => {\n        return { ...defaultOptions, ...(initOptions || {}), ...(mixin || {}) };\n    };\n    const updatePosition = (updateOptions) => {\n        if (referenceElement && floatingElement) {\n            options = getOptions(updateOptions);\n            computePosition(referenceElement, floatingElement, options)\n                .then(v => {\n                Object.assign(floatingElement.style, {\n                    position: v.strategy,\n                    left: `${v.x}px`,\n                    top: `${v.y}px`,\n                });\n                options?.onComputed && options.onComputed(v);\n            });\n        }\n    };\n    const referenceAction = node => {\n        if ('subscribe' in node) {\n            setupVirtualElementObserver(node);\n            return {};\n        }\n        else {\n            referenceElement = node;\n            updatePosition();\n        }\n    };\n    const contentAction = (node, contentOptions) => {\n        let autoUpdateDestroy;\n        floatingElement = node;\n        options = getOptions(contentOptions);\n        setTimeout(() => updatePosition(contentOptions), 0); //tick doesn't work\n        updatePosition(contentOptions);\n        const destroyAutoUpdate = () => {\n            if (autoUpdateDestroy) {\n                autoUpdateDestroy();\n                autoUpdateDestroy = undefined;\n            }\n        };\n        const initAutoUpdate = ({ autoUpdate } = options || {}) => {\n            destroyAutoUpdate();\n            if (autoUpdate !== false) {\n                tick().then(() => {\n                    return _autoUpdate(referenceElement, floatingElement, () => updatePosition(options), (autoUpdate === true ? {} : autoUpdate));\n                });\n            }\n            return;\n        };\n        autoUpdateDestroy = initAutoUpdate();\n        return {\n            update(contentOptions) {\n                updatePosition(contentOptions);\n                autoUpdateDestroy = initAutoUpdate(contentOptions);\n            },\n            destroy() {\n                destroyAutoUpdate();\n            }\n        };\n    };\n    const setupVirtualElementObserver = (node) => {\n        const unsubscribe = node.subscribe(($node) => {\n            if (referenceElement === undefined) {\n                referenceElement = $node;\n                updatePosition();\n            }\n            else {\n                // Preserve the reference to the virtual element.\n                Object.assign(referenceElement, $node);\n                updatePosition();\n            }\n        });\n        onDestroy(unsubscribe);\n    };\n    return [\n        referenceAction,\n        contentAction,\n        updatePosition\n    ];\n}\nexport function arrow(options) {\n    return {\n        name: \"arrow\",\n        options,\n        fn(args) {\n            const element = get(options.element);\n            if (element) {\n                return arrowCore({\n                    element,\n                    padding: options.padding\n                }).fn(args);\n            }\n            return {};\n        }\n    };\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Select from 'svelte-select'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption } from '$lib/utils/pathUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { isEqual } from 'lodash-es'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { setIn } from 'immutable-json-patch'\n  import type { PathOption, QueryLanguageOptions } from '$lib/types.js'\n\n  const debug = createDebug('jsoneditor:TransformWizard')\n\n  export let json: unknown\n  export let queryOptions: QueryLanguageOptions = {}\n  export let onChange: (queryOptions: QueryLanguageOptions) => void\n\n  // options\n  $: jsonIsArray = Array.isArray(json)\n  $: paths = jsonIsArray ? getNestedPaths(json) : []\n  $: pathsIncludingObjects = jsonIsArray ? getNestedPaths(json, true) : []\n  $: fieldOptions = paths.map(pathToOption)\n  $: projectionOptions = pathsIncludingObjects ? pathsIncludingObjects.map(pathToOption) : []\n\n  const filterRelationOptions = ['==', '!=', '<', '<=', '>', '>='].map((relation) => ({\n    value: relation,\n    label: relation\n  }))\n\n  const sortDirectionOptions = [\n    { value: 'asc', label: 'ascending' },\n    { value: 'desc', label: 'descending' }\n  ]\n\n  // TODO: the binding with the select boxes is very cumbersome. Can we simplify this?\n  let filterPath = queryOptions?.filter?.path ? pathToOption(queryOptions.filter.path) : undefined\n  let filterRelation =\n    filterRelationOptions.find((option) => option.value === queryOptions.filter?.relation) ??\n    filterRelationOptions[0]\n  let filterValue = queryOptions?.filter?.value || ''\n  let sortPath = queryOptions?.sort?.path ? pathToOption(queryOptions.sort.path) : undefined\n  let sortDirection =\n    sortDirectionOptions.find((option) => option.value === queryOptions.sort?.direction) ??\n    sortDirectionOptions[0]\n\n  $: projectionPaths =\n    queryOptions?.projection?.paths && projectionOptions\n      ? (queryOptions.projection.paths\n          .map((path) => projectionOptions.find((option) => isEqual(option.value, path)))\n          .filter((option) => !!option) as PathOption[])\n      : undefined\n\n  function changeFilterPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.filter?.path, path)) {\n      debug('changeFilterPath', path)\n      queryOptions = setIn(queryOptions, ['filter', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterRelation(relation: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.relation, relation)) {\n      debug('changeFilterRelation', relation)\n      queryOptions = setIn(queryOptions, ['filter', 'relation'], relation, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterValue(value: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.value, value)) {\n      debug('changeFilterValue', value)\n      queryOptions = setIn(queryOptions, ['filter', 'value'], value, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.sort?.path, path)) {\n      debug('changeSortPath', path)\n      queryOptions = setIn(queryOptions, ['sort', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortDirection(direction: string | undefined) {\n    if (!isEqual(queryOptions?.sort?.direction, direction)) {\n      debug('changeSortDirection', direction)\n      queryOptions = setIn(queryOptions, ['sort', 'direction'], direction, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeProjectionPaths(paths: JSONPath[] | unknown) {\n    if (!isEqual(queryOptions?.projection?.paths, paths)) {\n      debug('changeProjectionPaths', paths)\n      queryOptions = setIn(queryOptions, ['projection', 'paths'], paths, true)\n      onChange(queryOptions)\n    }\n  }\n\n  $: changeFilterPath(filterPath?.value)\n  $: changeFilterRelation(filterRelation?.value)\n  $: changeFilterValue(filterValue)\n  $: changeSortPath(sortPath?.value)\n  $: changeSortDirection(sortDirection?.value)\n  $: changeProjectionPaths(projectionPaths ? projectionPaths.map((item) => item.value) : undefined)\n</script>\n\n<table class=\"jse-transform-wizard\">\n  <tbody>\n    <tr>\n      <th>Filter</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-filter-path\"\n            showChevron\n            items={fieldOptions}\n            bind:value={filterPath}\n          />\n          <Select\n            class=\"jse-filter-relation\"\n            showChevron\n            clearable={false}\n            items={filterRelationOptions}\n            bind:value={filterRelation}\n          />\n          <input class=\"jse-filter-value\" bind:value={filterValue} />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Sort</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select class=\"jse-sort-path\" showChevron items={fieldOptions} bind:value={sortPath} />\n          <Select\n            class=\"jse-sort-direction\"\n            showChevron\n            clearable={false}\n            items={sortDirectionOptions}\n            bind:value={sortDirection}\n          />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Pick</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-projection-paths\"\n            multiple\n            showChevron\n            items={projectionOptions}\n            bind:value={projectionPaths}\n          />\n        </div>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<style src=\"./TransformWizard.scss\"></style>\n","<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { QueryLanguage, OnChangeQueryLanguage } from '$lib/types.js'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n</script>\n\n<div class=\"jse-select-query-language\">\n  <div class=\"jse-select-query-language-container\">\n    {#each queryLanguages as queryLanguage}\n      <button\n        type=\"button\"\n        on:click={() => handleChangeQueryLanguage(queryLanguage.id)}\n        class=\"jse-query-language\"\n        class:selected={queryLanguage.id === queryLanguageId}\n        title={`Select ${queryLanguage.name} as query language`}\n      >\n        {#if queryLanguage.id === queryLanguageId}\n          <Icon data={faCheckSquare} />\n        {:else}\n          <Icon data={faSquare} />\n        {/if}\n        {queryLanguage.name}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./SelectQueryLanguage.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import {\n    faDownLeftAndUpRightToCenter,\n    faTimes,\n    faUpRightAndDownLeftFromCenter\n  } from '@fortawesome/free-solid-svg-icons'\n\n  export let title = 'Modal'\n  export let fullScreenButton: boolean = false\n  export let fullscreen: boolean = false\n  export let onClose: (() => void) | undefined = undefined\n</script>\n\n<div class=\"jse-header\">\n  <div class=\"jse-title\">\n    {title}\n  </div>\n  <slot name=\"actions\" />\n  {#if fullScreenButton}\n    <button\n      type=\"button\"\n      class=\"jse-fullscreen\"\n      title=\"Toggle full screen\"\n      on:click={() => (fullscreen = !fullscreen)}\n    >\n      <Icon data={fullscreen ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter} />\n    </button>\n  {/if}\n  <button type=\"button\" class=\"jse-close\" on:click={() => onClose?.()}>\n    <Icon data={faTimes} />\n  </button>\n</div>\n\n<style src=\"./Header.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getContext } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { faCog } from '@fortawesome/free-solid-svg-icons'\n  import SelectQueryLanguage from '../controls/selectQueryLanguage/SelectQueryLanguage.svelte'\n  import type { AbsolutePopupContext, OnChangeQueryLanguage, QueryLanguage } from '$lib/types.js'\n  import Header from './Header.svelte'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let fullscreen: boolean\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n  export let onClose: () => void\n\n  let refConfigButton: HTMLButtonElement | undefined\n  let popupId: number | undefined\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  function openConfig() {\n    const props = {\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: (queryLanguageId: string) => {\n        closeAbsolutePopup(popupId)\n        onChangeQueryLanguage(queryLanguageId)\n      }\n    }\n\n    popupId = openAbsolutePopup(SelectQueryLanguage, props, {\n      offsetTop: -2,\n      offsetLeft: 0,\n      anchor: refConfigButton,\n      closeOnOuterClick: true\n    })\n  }\n</script>\n\n<Header title=\"Transform\" fullScreenButton={true} bind:fullscreen {onClose}>\n  <button\n    slot=\"actions\"\n    type=\"button\"\n    bind:this={refConfigButton}\n    class=\"jse-config\"\n    class:hide={queryLanguages.length <= 1}\n    on:click={openConfig}\n    title=\"Select a query language\"\n  >\n    <Icon data={faCog} />\n  </button>\n</Header>\n\n<style src=\"./TransformModalHeader.scss\"></style>\n","import { createDebug } from '$lib/utils/debug.js'\nimport {\n  AUTO_SCROLL_INTERVAL,\n  AUTO_SCROLL_SPEED_FAST,\n  AUTO_SCROLL_SPEED_NORMAL,\n  AUTO_SCROLL_SPEED_SLOW\n} from '$lib/constants.js'\n\nconst debug = createDebug('jsoneditor:AutoScrollHandler')\n\nexport function createAutoScrollHandler(scrollableElement: Element) {\n  debug('createAutoScrollHandler', scrollableElement)\n\n  let autoScrollSpeed: number | undefined // pixels per second\n  let autoScrollTimer: number | undefined\n\n  function calculateSpeed(diff: number) {\n    return diff < 20\n      ? AUTO_SCROLL_SPEED_SLOW\n      : diff < 50\n        ? AUTO_SCROLL_SPEED_NORMAL\n        : AUTO_SCROLL_SPEED_FAST\n  }\n\n  function autoScrollCallback() {\n    if (scrollableElement) {\n      // debug('auto scroll...')\n      const diff = (autoScrollSpeed || 0) * (AUTO_SCROLL_INTERVAL / 1000)\n\n      scrollableElement.scrollTop += diff\n    }\n  }\n\n  function startAutoScroll(speed: number) {\n    if (!autoScrollTimer || speed !== autoScrollSpeed) {\n      stopAutoScroll()\n\n      debug('startAutoScroll', speed)\n      autoScrollSpeed = speed\n      autoScrollTimer = setInterval(autoScrollCallback, AUTO_SCROLL_INTERVAL) as unknown as number\n    }\n  }\n\n  function stopAutoScroll() {\n    if (autoScrollTimer) {\n      debug('stopAutoScroll')\n\n      clearInterval(autoScrollTimer)\n      autoScrollTimer = undefined\n      autoScrollSpeed = undefined\n    }\n  }\n\n  function onDrag(event: MouseEvent) {\n    if (scrollableElement) {\n      const y = event.clientY\n      const { top, bottom } = scrollableElement.getBoundingClientRect()\n\n      if (y < top) {\n        const speed = calculateSpeed(top - y)\n        startAutoScroll(-speed)\n      } else if (y > bottom) {\n        const speed = calculateSpeed(y - bottom)\n        startAutoScroll(speed)\n      } else {\n        stopAutoScroll()\n      }\n    }\n  }\n\n  function onDragEnd() {\n    stopAutoScroll()\n  }\n\n  return {\n    onDrag,\n    onDragEnd\n  }\n}\n","// Robert Penner's easeInOutQuad\n\n// find the rest of his easing functions here: http://robertpenner.com/easing/\n// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\nexport default (t: number, b: number, c: number, d: number): number => {\n  t /= d / 2\n  if (t < 1) {\n    return (c / 2) * t * t + b\n  }\n  t--\n  return (-c / 2) * (t * (t - 2) - 1) + b\n}\n","import easeInOutQuad from './easing.js'\n\ntype Easing = (t: number, b: number, c: number, d: number) => number\ntype Duration = number | ((distance: number) => number)\n\ninterface JumpOptions {\n  duration?: Duration\n  offset?: number\n  callback?: () => void\n  easing?: Easing\n  a11y?: boolean\n  container?: Element | string\n}\n\nexport const createJump = () => {\n  // private variable cache\n  // no variables are created during a jump, preventing memory leaks\n\n  let container: Element // container element to be scrolled       (node)\n  let element: Element | undefined // element to scroll to                   (node)\n\n  let start: number // where scroll starts                    (px)\n  let stop: number // where scroll stops                     (px)\n\n  let offset // adjustment from the stop position      (px)\n  let easing: Easing // easing function                        (function)\n  let a11y: boolean // accessibility support flag             (boolean)\n\n  let distance: number // distance of scroll                     (px)\n  let duration: number // scroll duration                        (ms)\n\n  let timeStart: number // time scroll started                    (ms)\n  let timeElapsed: number // time spent scrolling thus far          (ms)\n\n  let next: number // next scroll position                   (px)\n\n  let callback: (() => void) | undefined // to call when done scrolling            (function)\n\n  let scrolling: boolean // true whilst scrolling                  (boolean)\n\n  // scroll position helper\n\n  function location() {\n    return container.scrollTop\n  }\n\n  // element offset helper\n\n  function top(element: Element) {\n    const elementTop = element.getBoundingClientRect().top\n    const containerTop = container.getBoundingClientRect ? container.getBoundingClientRect().top : 0\n\n    return elementTop - containerTop + start\n  }\n\n  // scrollTo helper\n\n  function scrollTo(top: number) {\n    if (container.scrollTo) {\n      container.scrollTo(container.scrollLeft, top) // window\n    } else {\n      container.scrollTop = top // custom container\n    }\n  }\n\n  // rAF loop helper\n\n  function loop(timeCurrent: number) {\n    // store time scroll started, if not started already\n    if (!timeStart) {\n      timeStart = timeCurrent\n    }\n\n    // determine time spent scrolling so far\n    timeElapsed = timeCurrent - timeStart\n\n    // calculate next scroll position\n    next = easing(timeElapsed, start, distance, duration)\n\n    // scroll to it\n    scrollTo(next)\n\n    scrolling = true\n\n    // check progress\n    if (timeElapsed < duration) {\n      requestAnimationFrame(loop) // continue scroll loop\n    } else {\n      done() // scrolling is done\n    }\n  }\n\n  // scroll finished helper\n\n  function done() {\n    // account for rAF time rounding inaccuracies\n    scrollTo(start + distance)\n\n    // if scrolling to an element, and accessibility is enabled\n    if (element && a11y) {\n      // add tabindex indicating programmatic focus\n      element.setAttribute('tabindex', '-1')\n\n      // focus the element\n      const htmlElement = element as HTMLElement\n      htmlElement.focus()\n    }\n\n    // if it exists, fire the callback\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    // reset time for next jump\n    timeStart = 0\n\n    // we're done scrolling\n    scrolling = false\n  }\n\n  // API\n\n  function jump(target: Element | number | string, options: JumpOptions = {}) {\n    // resolve options, or use defaults\n    duration = 1000\n    offset = options.offset || 0\n    callback = options.callback // \"undefined\" is a suitable default, and won't be called\n    easing = options.easing || easeInOutQuad\n    a11y = options.a11y || false\n\n    // resolve container\n    switch (typeof options.container) {\n      case 'object':\n        // we assume container is an HTML element (Node)\n        container = options.container\n        break\n\n      case 'string':\n        container = document.querySelector(options.container) as Element\n        break\n\n      default:\n        container = window.document.documentElement\n    }\n\n    // cache starting position\n    start = location()\n\n    // resolve target\n    switch (typeof target) {\n      // scroll from current position\n      case 'number':\n        element = undefined // no element to scroll to\n        a11y = false // make sure accessibility is off\n        stop = start + target\n        break\n\n      // scroll to element (node)\n      // bounding rect is relative to the viewport\n      case 'object':\n        element = target\n        stop = top(element)\n        break\n\n      // scroll to element (selector)\n      // bounding rect is relative to the viewport\n      case 'string':\n        element = document.querySelector(target) as unknown as Element\n        stop = top(element)\n        break\n\n      default:\n    }\n\n    // resolve scroll distance, accounting for offset\n    distance = stop - start + offset\n\n    // resolve duration\n    switch (typeof options.duration) {\n      // number in ms\n      case 'number':\n        duration = options.duration\n        break\n\n      // function passed the distance of the scroll\n      case 'function':\n        duration = options.duration(distance)\n        break\n\n      default:\n    }\n\n    // start the loop if we're not already scrolling\n    if (!scrolling) {\n      requestAnimationFrame(loop)\n    } else {\n      // reset time for next jump\n      timeStart = 0\n    }\n  }\n\n  // expose only the jump method\n  return jump\n}\n\n// export singleton\n\nconst singleton = createJump()\n\nexport default singleton\n","import { createDebug } from '../utils/debug.js'\n\nconst MAX_HISTORY_ITEMS = 1000\n\nconst debug = createDebug('jsoneditor:History')\n\n/**\n * @typedef {*} HistoryItem\n * @property {Object} undo\n * @property {Object} redo\n */\n\nexport interface HistoryOptions {\n  maxItems?: number\n  onChange?: (props: { canUndo: boolean; canRedo: boolean; length: number }) => void\n}\n\nexport interface HistoryState {\n  canUndo: boolean\n  canRedo: boolean\n  length: number\n}\n\nexport interface History<T> {\n  add: (item: T) => void\n  clear: () => void\n  getState: () => HistoryState\n  undo: () => T | undefined\n  redo: () => T | undefined\n}\n\nexport function createHistory<T>(options: HistoryOptions = {}): History<T> {\n  const maxItems = options.maxItems || MAX_HISTORY_ITEMS\n\n  /**\n   * items in history are sorted from newest first to oldest last\n   */\n  let items: T[] = []\n\n  let index = 0\n\n  function canUndo(): boolean {\n    return index < items.length\n  }\n\n  function canRedo(): boolean {\n    return index > 0\n  }\n\n  function getState(): HistoryState {\n    return {\n      canUndo: canUndo(),\n      canRedo: canRedo(),\n      length: items.length\n    }\n  }\n\n  function handleChange() {\n    if (options.onChange) {\n      options.onChange(getState())\n    }\n  }\n\n  function add(item: T) {\n    debug('add', item)\n\n    items = [item].concat(items.slice(index)).slice(0, maxItems)\n\n    index = 0\n\n    handleChange()\n  }\n\n  function clear() {\n    debug('clear')\n\n    items = []\n    index = 0\n\n    handleChange()\n  }\n\n  function undo(): T | undefined {\n    if (canUndo()) {\n      const item = items[index]\n      index += 1\n\n      debug('undo', item)\n\n      handleChange()\n\n      return item\n    }\n\n    return undefined\n  }\n\n  function redo(): T | undefined {\n    if (canRedo()) {\n      index -= 1\n\n      debug('redo', items[index])\n\n      handleChange()\n\n      return items[index]\n    }\n\n    return undefined\n  }\n\n  return {\n    add,\n    clear,\n    getState,\n    undo,\n    redo\n  }\n}\n","/**\n * Measure how long a callback takes to execute.\n * Returns the response from the callback\n * The measured duration is returned via the onDuration callback\n */\nexport function measure<T>(callback: () => T, onDuration: (duration: number) => void): T {\n  const start = Date.now()\n  const result = callback()\n  const end = Date.now()\n\n  onDuration(end - start)\n\n  return result\n}\n","import { initial, isEmpty } from 'lodash-es'\nimport type {\n  ContentErrors,\n  JSONParser,\n  RecursiveStateFactory,\n  ValidationErrors,\n  ValidationError,\n  Validator\n} from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { MAX_AUTO_REPAIRABLE_SIZE, MAX_VALIDATABLE_SIZE } from '../constants.js'\nimport { measure } from '../utils/timeUtils.js'\nimport { normalizeJsonParseError } from '../utils/jsonUtils.js'\nimport { createDebug } from '../utils/debug.js'\nimport { jsonrepair } from 'jsonrepair'\nimport { updateInRecursiveState } from './documentState.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst debug = createDebug('validation')\n\nexport const validationErrorsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInValidationErrors(\n  json: unknown,\n  errors: ValidationErrors | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: ValidationErrors) => ValidationErrors\n): ValidationErrors {\n  return updateInRecursiveState(json, errors, path, transform, validationErrorsFactory)\n}\n\n/**\n * Create a flat map with validation errors, where the key is the stringified path\n * and also create error messages for the parent nodes of the nodes having an error.\n *\n * Returns a nested object containing the validation errors\n */\nexport function toRecursiveValidationErrors(\n  json: unknown,\n  validationErrors: ValidationError[]\n): ValidationErrors | undefined {\n  let output: ValidationErrors | undefined\n\n  // first generate the errors themselves\n  validationErrors.forEach((validationError) => {\n    output = updateInValidationErrors(json, output, validationError.path, (_, state) => ({\n      ...state,\n      validationError\n    }))\n  })\n\n  // create error entries for all parent nodes (displayed when the node is collapsed)\n  validationErrors.forEach((validationError) => {\n    let parentPath = validationError.path\n\n    while (parentPath.length > 0) {\n      parentPath = initial(parentPath)\n\n      output = updateInValidationErrors(json, output, parentPath, (_, state) => {\n        return state.validationError\n          ? state\n          : {\n              ...state,\n              validationError: {\n                isChildError: true,\n                path: parentPath,\n                message: 'Contains invalid data',\n                severity: ValidationSeverity.warning\n              }\n            }\n      })\n    }\n  })\n\n  return output\n}\n\nexport function validateJSON(\n  json: unknown,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ValidationError[] {\n  debug('validateJSON')\n\n  if (!validator) {\n    return []\n  }\n\n  if (parser !== validationParser) {\n    // if needed, convert for example Lossless JSON to native JSON\n    // (like replace bigint or LosslessNumber into regular numbers)\n    const text = parser.stringify(json)\n    const convertedJSON = text !== undefined ? validationParser.parse(text) : undefined\n    return validator(convertedJSON)\n  } else {\n    return validator(json)\n  }\n}\n\nexport function validateText(\n  text: string,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ContentErrors | undefined {\n  debug('validateText')\n\n  if (text.length > MAX_VALIDATABLE_SIZE) {\n    const validationError: ValidationError = {\n      path: [],\n      message: 'Validation turned off: the document is too large',\n      severity: ValidationSeverity.info\n    }\n\n    return {\n      validationErrors: [validationError]\n    }\n  }\n\n  if (text.length === 0) {\n    // new, empty document, do not try to parse\n    return undefined\n  }\n\n  try {\n    // parse with the \"main\" parser (not the validation parser) to get parse errors\n    // (like syntax errors and duplicate keys errors)\n    const json = measure(\n      () => parser.parse(text),\n      (duration) => debug(`validate: parsed json in ${duration} ms`)\n    )\n\n    if (!validator) {\n      return undefined\n    }\n\n    // if needed, parse with the validationParser to be able to feed the json to the validator\n    const convertedJSON =\n      parser === validationParser\n        ? json\n        : measure(\n            () => validationParser.parse(text),\n            (duration) => debug(`validate: parsed json with the validationParser in ${duration} ms`)\n          )\n\n    // actually validate the json\n    const validationErrors = measure(\n      () => validator(convertedJSON),\n      (duration) => debug(`validate: validated json in ${duration} ms`)\n    )\n\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  } catch (err) {\n    const isRepairable = measure(\n      () => canAutoRepair(text, parser),\n      (duration) => debug(`validate: checked whether repairable in ${duration} ms`)\n    )\n\n    const parseError = normalizeJsonParseError(\n      text,\n      (err as Error).message || (err as Error).toString()\n    )\n\n    return {\n      parseError,\n      isRepairable\n    }\n  }\n}\n\nfunction canAutoRepair(text: string, parser: JSONParser): boolean {\n  if (text.length > MAX_AUTO_REPAIRABLE_SIZE) {\n    return false\n  }\n\n  try {\n    parser.parse(jsonrepair(text))\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { createDebug } from '$lib/utils/debug.js'\n\nconst debug = createDebug('jsoneditor:FocusTracker')\n\nexport interface FocusTrackerProps {\n  onMount: (callback: () => void) => void\n  onDestroy: (callback: () => void) => void\n  getWindow: () => Window | undefined\n  hasFocus: () => boolean\n  onFocus: () => void\n  onBlur: () => void\n}\n\nexport function createFocusTracker({\n  onMount,\n  onDestroy,\n  getWindow,\n  hasFocus,\n  onFocus,\n  onBlur\n}: FocusTrackerProps) {\n  let blurTimeoutHandle: number | undefined\n  let focus = false\n\n  function handleFocusIn() {\n    const newFocus = hasFocus()\n\n    if (newFocus) {\n      clearTimeout(blurTimeoutHandle)\n      if (!focus) {\n        debug('focus')\n        onFocus()\n        focus = newFocus\n      }\n    }\n  }\n\n  function handleFocusOut() {\n    if (focus) {\n      // We set focus to false after timeout. Often, you get a blur and directly\n      // another focus when moving focus from one button to another.\n      // The focusIn handler will cancel any pending blur timer in those cases\n      clearTimeout(blurTimeoutHandle)\n      blurTimeoutHandle = setTimeout(() => {\n        if (!hasFocus()) {\n          debug('blur')\n          focus = false\n          onBlur()\n        }\n      }) as unknown as number\n    }\n  }\n\n  onMount(() => {\n    debug('mount FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.addEventListener('focusin', handleFocusIn, true)\n      window.addEventListener('focusout', handleFocusOut, true)\n    }\n  })\n\n  onDestroy(() => {\n    debug('destroy FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.removeEventListener('focusin', handleFocusIn, true)\n      window.removeEventListener('focusout', handleFocusOut, true)\n    }\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MessageAction } from '$lib/types'\n  import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy } from 'svelte'\n\n  export let type: 'success' | 'error' | 'warning' | 'info' = 'success'\n  export let icon: IconDefinition | undefined = undefined\n  export let message: string | undefined = undefined\n  export let actions: MessageAction[] = []\n  export let onClick: (() => void) | undefined = undefined\n  export let onClose: (() => void) | undefined = undefined\n\n  if (onClose) {\n    onDestroy(onClose)\n  }\n\n  function handleClick() {\n    if (onClick) {\n      onClick()\n    }\n  }\n</script>\n\n<div class=\"jse-message jse-{type}\">\n  <!-- svelte-ignore a11y-click-events-have-key-events -->\n  <div\n    role=\"button\"\n    tabindex=\"-1\"\n    class=\"jse-text\"\n    class:jse-clickable={!!onClick}\n    on:click={handleClick}\n  >\n    <div class=\"jse-text-centered\">\n      {#if icon}\n        <Icon data={icon} />\n      {/if}\n      {message}\n    </div>\n  </div>\n  <div class=\"jse-actions\">\n    {#each actions as action}\n      <button\n        type=\"button\"\n        on:click={() => {\n          if (action.onClick) {\n            action.onClick()\n          }\n        }}\n        on:mousedown={() => {\n          if (action.onMouseDown) {\n            action.onMouseDown()\n          }\n        }}\n        class=\"jse-button jse-action jse-primary\"\n        title={action.title}\n        disabled={action.disabled}\n      >\n        {#if action.icon}\n          <Icon data={action.icon} />\n        {/if}\n        {action.text}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./Message.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faAngleDown,\n    faAngleRight,\n    faExclamationTriangle\n  } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { ValidationSeverity, type ValidationError } from '$lib/types.js'\n  import { MAX_VALIDATION_ERRORS } from '$lib/constants.js'\n  import { limit } from '$lib/utils/arrayUtils.js'\n\n  export let validationErrors: ValidationError[]\n  export let selectError: (error: ValidationError) => void\n\n  $: count = validationErrors.length\n\n  let expanded = true\n\n  function collapse() {\n    expanded = false\n  }\n\n  function expand() {\n    expanded = true\n  }\n\n  function getMaxSeverity(errors: ValidationError[]): ValidationSeverity | undefined {\n    const severities = [\n      ValidationSeverity.error,\n      ValidationSeverity.warning,\n      ValidationSeverity.info\n    ]\n\n    return severities.find((severity) => errors.some((error) => error.severity === severity))\n  }\n</script>\n\n{#if !isEmpty(validationErrors)}\n  <div class=\"jse-validation-errors-overview\">\n    {#if expanded || count === 1}\n      <table class=\"jse-validation-errors-overview-expanded\">\n        <tbody>\n          {#each limit(validationErrors, MAX_VALIDATION_ERRORS) as validationError, index}\n            <tr\n              class=\"jse-validation-{validationError.severity}\"\n              tabindex=\"0\"\n              on:click={() => {\n                // trigger on the next tick to prevent the editor not getting focus\n                setTimeout(() => selectError(validationError))\n              }}\n            >\n              <td class=\"jse-validation-error-icon\">\n                <Icon data={faExclamationTriangle} />\n              </td>\n              <td class=\"jse-validation-error-path\">\n                {stringifyJSONPath(validationError.path)}\n              </td>\n              <td class=\"jse-validation-error-message\">\n                {validationError.message}\n              </td>\n              <td class=\"jse-validation-error-action\">\n                {#if index === 0 && validationErrors.length > 1}\n                  <button\n                    type=\"button\"\n                    class=\"jse-validation-errors-collapse\"\n                    on:click|stopPropagation={collapse}\n                    title=\"Collapse validation errors\"\n                  >\n                    <Icon data={faAngleDown} />\n                  </button>\n                {/if}\n              </td>\n            </tr>\n          {/each}\n\n          {#if count > MAX_VALIDATION_ERRORS}\n            <tr class=\"jse-validation-error\">\n              <td></td>\n              <td></td>\n              <td>(and {count - MAX_VALIDATION_ERRORS} more errors)</td>\n              <td></td>\n            </tr>\n          {/if}\n        </tbody>\n      </table>\n    {:else}\n      <table class=\"jse-validation-errors-overview-collapsed\">\n        <tbody>\n          <tr class=\"jse-validation-{getMaxSeverity(validationErrors)}\" on:click={expand}>\n            <td class=\"jse-validation-error-icon\">\n              <Icon data={faExclamationTriangle} />\n            </td>\n            <td class=\"jse-validation-error-count\">\n              {count} validation errors\n              <div class=\"jse-validation-errors-expand\">\n                <Icon data={faAngleRight} />\n              </div>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    {/if}\n  </div>\n{/if}\n\n<style src=\"./ValidationErrorsOverview.scss\"></style>\n","type Callback = () => void\n\n/**\n * The provided callback is invoked when the user presses Escape, and then stops propagation of the event.\n */\nexport function onEscape(element: HTMLElement | undefined, callback: Callback) {\n  if (!element) {\n    return undefined\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      callback()\n    }\n  }\n\n  element.addEventListener('keydown', handleKeyDown)\n\n  return {\n    destroy() {\n      element.removeEventListener('keydown', handleKeyDown)\n    }\n  }\n}\n","<script lang=\"ts\">\n  // code based on: https://svelte.dev/examples/modal\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { onDestroy, onMount } from 'svelte'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let className: string | undefined = undefined\n  export let fullscreen = false\n  export let onClose: () => void\n\n  let dialog: HTMLDialogElement\n\n  onMount(() => dialog.showModal())\n  onDestroy(() => dialog.close())\n\n  function close() {\n    onClose()\n  }\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events a11y-no-noninteractive-element-interactions -->\n<dialog\n  bind:this={dialog}\n  on:close={close}\n  on:click|self={close}\n  on:cancel|preventDefault\n  use:onEscape={close}\n  class={classnames('jse-modal', className)}\n  class:jse-fullscreen={fullscreen}\n>\n  <div class=\"jse-modal-inner\">\n    <slot />\n  </div>\n</dialog>\n\n<style lang=\"scss\">\n  @use '../../themes/defaults.scss';\n  @use '../../styles.scss';\n\n  dialog.jse-modal {\n    border-radius: styles.$border-radius;\n    font-size: defaults.$padding; // for some reason that I don't understand, the font-size of the dialog is used as margin around the dialog\n    border: none;\n    padding: 0;\n    display: flex;\n    min-width: 0;\n    margin: auto;\n    overflow: visible;\n    transition:\n      width 0.1s ease-in-out,\n      height 0.1s ease-in-out;\n\n    &.jse-sort-modal {\n      width: 400px;\n    }\n\n    &.jse-repair-modal {\n      width: 600px;\n      height: 500px;\n    }\n\n    &.jse-jsoneditor-modal {\n      width: 800px;\n      height: 600px;\n    }\n\n    &.jse-transform-modal {\n      width: 1200px;\n      height: 800px;\n    }\n\n    &.jse-fullscreen {\n      width: 100%;\n      height: 100%;\n    }\n\n    &::backdrop {\n      background: defaults.$modal-overlay-background;\n    }\n\n    &[open] {\n      animation: zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n    }\n\n    &[open]::backdrop {\n      animation: fade 0.2s ease-out;\n    }\n\n    & .jse-modal-inner {\n      @include styles.jse-modal-style;\n    }\n\n    @keyframes zoom {\n      from {\n        transform: scale(0.95);\n      }\n      to {\n        transform: scale(1);\n      }\n    }\n\n    @keyframes fade {\n      from {\n        opacity: 0;\n      }\n      to {\n        opacity: 1;\n      }\n    }\n\n    // styling for the select box, svelte-select\n    // see docs: https://github.com/rob-balfre/svelte-select#css-custom-properties-variables\n    :global(.svelte-select) {\n      --border: #{defaults.$svelte-select-border};\n      --item-is-active-bg: #{defaults.$svelte-select-item-is-active-bg};\n      --border-radius: #{defaults.$svelte-select-border-radius};\n      --background: #{defaults.$svelte-select-background};\n      --padding: #{defaults.$svelte-select-padding};\n      --multi-select-padding: #{defaults.$svelte-select-multi-select-padding};\n      --font-size: #{defaults.$svelte-select-font-size};\n      --height: 36px;\n      --multi-item-height: 28px;\n      --multi-item-margin: 2px;\n      --multi-item-padding: 2px 8px;\n      --multi-item-border-radius: 6px;\n      --indicator-top: 8px;\n    }\n  }\n</style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isMacDevice } from '$lib/utils/navigatorUtils.js'\n  import Header from './Header.svelte'\n  import Modal from './Modal.svelte'\n\n  export let onClose: () => void\n\n  const ctrl = isMacDevice() ? '⌘' : 'Ctrl'\n</script>\n\n<Modal {onClose} className=\"jse-copy-paste\">\n  <Header title=\"Copying and pasting\" {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <div>These actions are unavailable via the menu. Please use:</div>\n\n    <div class=\"jse-shortcuts\">\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+C\n        </div>\n        for copy\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+X\n        </div>\n        for cut\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+V\n        </div>\n        for paste\n      </div>\n    </div>\n\n    <div class=\"jse-actions\">\n      <button type=\"button\" class=\"jse-primary\" on:click={onClose}> Close </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./CopyPasteModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MenuItem } from '$lib/types'\n  import { isMenuButton, isMenuSeparator, isMenuSpace } from '$lib/typeguards.js'\n\n  export let items: MenuItem[] = []\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of menu item', item)\n    return '???'\n  }\n</script>\n\n<div class=\"jse-menu\">\n  <slot name=\"left\" />\n\n  {#each items as item}\n    {#if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else if isMenuSpace(item)}\n      <div class=\"jse-space\"></div>\n    {:else if isMenuButton(item)}\n      <button\n        type=\"button\"\n        class=\"jse-button {item.className}\"\n        on:click={item.onClick}\n        title={item.title}\n        disabled={item.disabled || false}\n      >\n        {#if item.icon}\n          <Icon data={item.icon} />\n        {/if}\n        {#if item.text}\n          {item.text}\n        {/if}\n      </button>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  <slot name=\"right\" />\n</div>\n\n<style src=\"./Menu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faArrowDown,\n    faCheck,\n    faExclamationTriangle,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import Message from '../../controls/Message.svelte'\n  import { normalizeJsonParseError } from '$lib/utils/jsonUtils.js'\n  import Menu from '../../controls/Menu.svelte'\n  import type { MenuItem, ParseError } from '$lib/types.js'\n\n  export let text = ''\n  export let readOnly = false\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onChange: ((updatedText: string) => void) | undefined = undefined\n  export let onApply: (repairedText: string) => void\n  export let onCancel: () => void\n\n  const debug = createDebug('jsoneditor:JSONRepair')\n\n  let domTextArea: HTMLTextAreaElement\n\n  $: error = getErrorMessage(text)\n  $: repairable = isRepairable(text)\n\n  $: debug('error', error)\n\n  function getErrorMessage(jsonText: string): ParseError | undefined {\n    try {\n      onParse(jsonText)\n      return undefined\n    } catch (err) {\n      return normalizeJsonParseError(jsonText, (err as Error).message)\n    }\n  }\n\n  function isRepairable(jsonText: string) {\n    try {\n      onRepair(jsonText)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  function goToError() {\n    if (domTextArea && error) {\n      const position = error.position !== undefined ? error.position : 0\n      domTextArea.setSelectionRange(position, position)\n      domTextArea.focus()\n    }\n  }\n\n  function handleChange(event: Event & { currentTarget: EventTarget & HTMLTextAreaElement }) {\n    debug('handleChange')\n\n    const value = (event.target as HTMLTextAreaElement).value\n\n    if (text === value) {\n      return\n    }\n\n    text = value\n\n    if (onChange) {\n      onChange(text)\n    }\n  }\n\n  function handleApply() {\n    onApply(text)\n  }\n\n  function handleRepair() {\n    try {\n      // TODO: simpleJsonRepair should also partially apply fixes. Now it's all or nothing\n      text = onRepair(text)\n\n      if (onChange) {\n        onChange(text)\n      }\n    } catch {\n      // no need to do something with the error\n    }\n  }\n\n  let items: MenuItem[]\n  $: items = [\n    {\n      type: 'space'\n    },\n    {\n      type: 'button',\n      icon: faTimes,\n      title: 'Cancel repair',\n      className: 'jse-cancel',\n      onClick: onCancel\n    }\n  ]\n\n  $: gotoAction = {\n    icon: faArrowDown,\n    text: 'Show me',\n    title: 'Scroll to the error location',\n    onClick: goToError\n  }\n\n  $: repairAction = {\n    icon: faWrench,\n    text: 'Auto repair',\n    title: 'Automatically repair JSON',\n    onClick: handleRepair\n  }\n\n  $: errorActions = repairable ? [gotoAction, repairAction] : [gotoAction]\n\n  $: successActions = [\n    {\n      icon: faCheck,\n      text: 'Apply',\n      title: 'Apply fixed JSON',\n      disabled: readOnly,\n      onClick: handleApply\n    }\n  ]\n</script>\n\n<div class=\"jse-json-repair-component\">\n  <Menu {items}>\n    <div slot=\"left\" class=\"jse-info\">Repair invalid JSON, then click apply</div>\n  </Menu>\n\n  {#if error}\n    <Message\n      type=\"error\"\n      icon={faExclamationTriangle}\n      message={`Cannot parse JSON: ${error.message}`}\n      actions={errorActions}\n    />\n  {:else}\n    <Message\n      type=\"success\"\n      message=\"JSON is valid now and can be parsed.\"\n      actions={successActions}\n    />\n  {/if}\n  <textarea\n    bind:this={domTextArea}\n    on:input={handleChange}\n    readonly={readOnly}\n    class=\"jse-json-text\"\n    autocomplete=\"off\"\n    autocapitalize=\"off\"\n    spellcheck=\"false\">{text}</textarea\n  >\n</div>\n\n<style src=\"./JSONRepairComponent.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import JSONRepairComponent from './repair/JSONRepairComponent.svelte'\n  import Modal from './Modal.svelte'\n\n  export let text: string\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onApply: (repairedText: string) => void\n  export let onClose: () => void\n\n  function handleApply(repairedText: string) {\n    onApply(repairedText)\n    onClose()\n  }\n\n  function handleCancel() {\n    onClose()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-repair-modal\">\n  <JSONRepairComponent\n    bind:text\n    {onParse}\n    {onRepair}\n    onApply={handleApply}\n    onCancel={handleCancel}\n  />\n</Modal>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getExpandItemsSections } from '$lib/logic/expandItemsSections.js'\n  import type { JSONSelection, Section, VisibleSection, JSONEditorContext } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { pathInSelection } from '$lib/logic/selection.js'\n\n  export let visibleSections: VisibleSection[]\n  export let sectionIndex: number\n  export let total: number\n  export let path: JSONPath\n  export let selection: JSONSelection | undefined\n  export let onExpandSection: (path: JSONPath, section: Section) => void\n  export let context: JSONEditorContext\n\n  $: visibleSection = visibleSections[sectionIndex]\n\n  $: startIndex = visibleSection.end\n  $: endIndex = visibleSections[sectionIndex + 1] ? visibleSections[sectionIndex + 1].start : total\n\n  $: selected = pathInSelection(context.getJson(), selection, path.concat(String(startIndex)))\n\n  $: expandItemsSections = getExpandItemsSections(startIndex, endIndex)\n\n  function handleMouseMove(event: MouseEvent) {\n    // prevent the whole array from being selected whilst dragging over\n    // a section with collapsed items\n    event.stopPropagation()\n  }\n</script>\n\n<div\n  role=\"none\"\n  class=\"jse-collapsed-items\"\n  class:jse-selected={selected}\n  on:mousemove={handleMouseMove}\n  style:--level={path.length + 2}\n>\n  <div>\n    <div class=\"jse-text\">Items {startIndex}-{endIndex}</div>\n    {#each expandItemsSections as expandItemsSection}<button\n        type=\"button\"\n        class=\"jse-expand-items\"\n        on:click={() => onExpandSection(path, expandItemsSection)}\n      >\n        show {expandItemsSection.start}-{expandItemsSection.end}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./CollapsedItems.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import {\n    CONTEXT_MENU_EXPLANATION,\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH\n  } from '$lib/constants.js'\n  import type { OnContextMenu } from '$lib/types'\n\n  export let root: boolean = false\n  export let insert: boolean = false\n  export let selected: boolean\n  export let onContextMenu: OnContextMenu\n\n  function handleClick(event: MouseEvent & { currentTarget: EventTarget & HTMLButtonElement }) {\n    let buttonElem: Element | undefined = event.target as HTMLButtonElement\n    while (buttonElem && buttonElem.nodeName !== 'BUTTON') {\n      buttonElem = buttonElem.parentNode as Element\n    }\n\n    if (buttonElem) {\n      onContextMenu({\n        anchor: buttonElem,\n        left: 0,\n        top: 0,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        offsetTop: 2,\n        offsetLeft: 0,\n        showTip: true\n      })\n    }\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-context-menu-pointer\"\n  class:jse-root={root}\n  class:jse-insert={insert}\n  class:jse-selected={selected}\n  title={CONTEXT_MENU_EXPLANATION}\n  on:click={handleClick}\n>\n  <Icon data={faCaretDown} />\n</button>\n\n<style src=\"./ContextMenuPointer.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { initial, isEqual } from 'lodash-es'\n  import {\n    createEditKeySelection,\n    createKeySelection,\n    createValueSelection,\n    isEditingSelection,\n    isKeySelection\n  } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from './highlight/SearchResultHighlighter.svelte'\n  import EditableDiv from '../../controls/EditableDiv.svelte'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem, JSONSelection, TreeModeContext } from '$lib/types.js'\n  import { UpdateSelectionAfterChange } from '$lib/types.js'\n  import { type JSONPath, type JSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n\n  export let pointer: JSONPointer\n  export let key: string\n  export let selection: JSONSelection | undefined\n  export let searchResultItems: ExtendedSearchResultItem[] | undefined\n  export let onUpdateKey: (oldKey: string, newKey: string) => string\n\n  export let context: TreeModeContext\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n\n  $: isKeySelected = isKeySelection(selection) && isEqual(selection.path, path)\n  $: isEditingKey = isKeySelected && isEditingSelection(selection)\n\n  function handleKeyDoubleClick(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (!isEditingKey && !context.readOnly) {\n      event.preventDefault()\n      context.onSelect(createEditKeySelection(path))\n    }\n  }\n\n  function handleChangeValue(newKey: string, updateSelection: UpdateSelectionAfterChange) {\n    const updatedKey = onUpdateKey(key, context.normalization.unescapeValue(newKey))\n    const updatedPath = initial(path).concat(updatedKey)\n\n    context.onSelect(\n      updateSelection === UpdateSelectionAfterChange.nextInside\n        ? createValueSelection(updatedPath)\n        : createKeySelection(updatedPath)\n    )\n\n    if (updateSelection !== UpdateSelectionAfterChange.self) {\n      context.focus()\n    }\n  }\n\n  function handleCancelChange() {\n    context.onSelect(createKeySelection(path))\n    context.focus()\n  }\n</script>\n\n{#if !context.readOnly && isEditingKey}\n  <EditableDiv\n    value={context.normalization.escapeValue(key)}\n    initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n    label=\"Edit key\"\n    shortText\n    onChange={handleChangeValue}\n    onCancel={handleCancelChange}\n    onFind={context.onFind}\n  />\n{:else}\n  <div\n    role=\"none\"\n    data-type=\"selectable-key\"\n    class=\"jse-key\"\n    class:jse-empty={key === ''}\n    on:dblclick={handleKeyDoubleClick}\n  >\n    {#if searchResultItems}\n      <SearchResultHighlighter text={context.normalization.escapeValue(key)} {searchResultItems} />\n    {:else}\n      {addNewLineSuffix(context.normalization.escapeValue(key))}\n    {/if}\n  </div>\n{/if}\n{#if !context.readOnly && isKeySelected && !isEditingKey}\n  <ContextMenuPointer selected={true} onContextMenu={context.onContextMenu} />\n{/if}\n\n<style src=\"./JSONKey.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONEditorContext, JSONSelection, SearchResultItem } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { isEditingSelection, isValueSelection } from '$lib/logic/selection.js'\n  import { isSvelteActionRenderer } from '$lib/typeguards.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let context: JSONEditorContext\n  export let enforceString: boolean\n  export let selection: JSONSelection | undefined\n  export let searchResultItems: SearchResultItem[] | undefined\n\n  $: isEditing = isValueSelection(selection) && isEditingSelection(selection)\n\n  $: renderers = context.onRenderValue({\n    path,\n    value,\n    mode: context.mode,\n    readOnly: context.readOnly,\n    enforceString,\n    isEditing,\n    parser: context.parser,\n    normalization: context.normalization,\n    selection,\n    searchResultItems,\n    onPatch: context.onPatch,\n    onPasteJson: context.onPasteJson,\n    onSelect: context.onSelect,\n    onFind: context.onFind,\n    findNextInside: context.findNextInside,\n    focus: context.focus\n  })\n</script>\n\n{#each renderers as renderer}\n  {#if isSvelteActionRenderer(renderer)}\n    {@const action = renderer.action}\n    {#key renderer.action}\n      <div\n        role=\"button\"\n        tabindex=\"-1\"\n        class=\"jse-value\"\n        data-type=\"selectable-value\"\n        use:action={renderer.props}\n      ></div>\n    {/key}\n  {:else}\n    {#key renderer.component}\n      <svelte:component this={renderer.component} {...renderer.props} />\n    {/key}\n  {/if}\n{/each}\n","// used by JSONNode during dragging\nimport type { JSONPath } from 'immutable-json-patch'\n\nexport const singleton: Singleton = {\n  selecting: false,\n  selectionAnchor: undefined, // Path\n  selectionAnchorType: undefined, // Selection type\n  selectionFocus: undefined, // Path\n\n  dragging: false\n}\n\ninterface Singleton {\n  selecting: boolean\n  selectionAnchor: JSONPath | undefined\n  selectionAnchorType: string | undefined\n  selectionFocus: JSONPath | undefined\n\n  dragging: boolean\n}\n","import { createMultiSelection, getEndPath, getStartPath } from './selection.js'\nimport { initial, isEqual } from 'lodash-es'\nimport type { JSONPatchDocument } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { moveInsideParent } from './operations.js'\nimport type {\n  DragInsideAction,\n  DragInsideProps,\n  JSONSelection,\n  MultiSelection,\n  RenderedItem\n} from '$lib/types'\n\nexport interface MoveSelectionProps {\n  json: unknown\n  selection: JSONSelection | undefined\n  deltaY: number\n  items: RenderedItem[]\n}\n\nexport interface MoveSelectionResult {\n  operations: JSONPatchDocument | undefined\n  updatedSelection: JSONSelection | undefined\n  offset: number\n}\n\nexport function onMoveSelection({\n  json,\n  selection,\n  deltaY,\n  items\n}: MoveSelectionProps): MoveSelectionResult {\n  if (!selection) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const dragInsideAction =\n    deltaY < 0\n      ? findSwapPathUp({ json, selection, deltaY, items })\n      : findSwapPathDown({ json, selection, deltaY, items })\n\n  if (!dragInsideAction || dragInsideAction.offset === 0) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const operations = moveInsideParent(json, selection, dragInsideAction)\n\n  const path = initial(getStartPath(json, selection))\n  const value = getIn(json, path)\n  if (Array.isArray(value)) {\n    const updatedSelection = createUpdatedArraySelection({\n      items,\n      json,\n      selection,\n      offset: dragInsideAction.offset\n    })\n\n    return {\n      operations,\n      updatedSelection,\n      offset: dragInsideAction.offset\n    }\n  } else {\n    // object\n    return {\n      operations,\n      updatedSelection: undefined,\n      offset: dragInsideAction.offset\n    }\n  }\n}\n\nfunction findSwapPathUp({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getStartPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  const prevHeight = () => items[index - 1]?.height\n\n  let index = initialIndex\n  let cumulativeHeight = 0\n\n  while (prevHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + prevHeight() / 2) {\n    cumulativeHeight += prevHeight()\n    index -= 1\n  }\n\n  const beforePath = items[index].path\n  const offset = index - initialIndex\n\n  return index !== initialIndex && items[index] !== undefined ? { beforePath, offset } : undefined\n}\n\nfunction findSwapPathDown({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getEndPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  let cumulativeHeight = 0\n  let index = initialIndex\n\n  const nextHeight = () => items[index + 1]?.height\n\n  while (nextHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + nextHeight() / 2) {\n    cumulativeHeight += nextHeight()\n    index += 1\n  }\n\n  const parentPath = initial(initialPath)\n  const parent = getIn(json, parentPath)\n  const isArray = Array.isArray(parent)\n  const beforeIndex = isArray ? index : index + 1\n  const beforePath = items[beforeIndex]?.path\n  const offset = index - initialIndex\n\n  return beforePath ? { beforePath, offset } : { append: true, offset }\n}\n\ninterface UpdatedArraySelectionProps {\n  items: RenderedItem[]\n  json: unknown\n  selection: JSONSelection\n  offset: number\n}\n\nfunction createUpdatedArraySelection({\n  items,\n  json,\n  selection,\n  offset\n}: UpdatedArraySelectionProps): MultiSelection {\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n\n  const startIndex = items.findIndex((item) => isEqual(item.path, startPath))\n  const endIndex = items.findIndex((item) => isEqual(item.path, endPath))\n\n  const anchorPath = items[startIndex + offset]?.path\n  const focusPath = items[endIndex + offset]?.path\n\n  return createMultiSelection(anchorPath, focusPath)\n}\n","<script lang=\"ts\">\n  import { faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { getContext } from 'svelte'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, NestedValidationError, ValidationError } from '$lib/types.js'\n  import { isNestedValidationError } from '$lib/typeguards.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let validationError: NestedValidationError | ValidationError\n  export let onExpand: (event: MouseEvent) => void\n\n  $: text =\n    isNestedValidationError(validationError) && validationError.isChildError\n      ? 'Contains invalid data'\n      : validationError.message\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-validation-{validationError.severity}\"\n  on:click={onExpand}\n  use:tooltip={{ text, ...absolutePopupContext }}\n>\n  <Icon data={faExclamationTriangle} />\n</button>\n\n<style src=\"./ValidationErrorIcon.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import type { JSONPath, JSONPointer } from 'immutable-json-patch'\n  import { appendToJSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import { initial, isEqual, last, range } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    DEFAULT_VISIBLE_SECTIONS,\n    HOVER_COLLECTION,\n    HOVER_INSERT_AFTER,\n    HOVER_INSERT_INSIDE,\n    INSERT_EXPLANATION\n  } from '$lib/constants.js'\n  import { getEnforceString, getVisibleCaretPositions } from '$lib/logic/documentState.js'\n  import { rename } from '$lib/logic/operations.js'\n  import {\n    createAfterSelection,\n    createInsideSelection,\n    createMultiSelection,\n    fromCaretPosition,\n    fromSelectionType,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getSelectionPaths,\n    getStartPath,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isKeySelection,\n    isMultiSelection,\n    isValueSelection,\n    pathInSelection,\n    selectionIfOverlapping\n  } from '$lib/logic/selection.js'\n  import {\n    getDataPathFromTarget,\n    getSelectionTypeFromTarget,\n    isChildOfAttribute,\n    isChildOfNodeName,\n    isContentEditableDiv\n  } from '$lib/utils/domUtils.js'\n  import CollapsedItems from './CollapsedItems.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import JSONKey from './JSONKey.svelte'\n  import JSONValue from './JSONValue.svelte'\n  import { singleton } from './singleton.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { onMoveSelection } from '$lib/logic/dragging.js'\n  import { forEachIndex, moveItems } from '$lib/utils/arrayUtils.js'\n  import type {\n    AbsolutePopupOptions,\n    CaretPosition,\n    DocumentState,\n    DraggingState,\n    JSONSelection,\n    NestedValidationError,\n    SearchResults,\n    ValidationErrors,\n    RenderedItem,\n    TreeModeContext,\n    VisibleSection\n  } from '$lib/types'\n  import { SelectionType } from '$lib/types.js'\n  import {\n    isArrayRecursiveState,\n    isExpandableState,\n    isObjectRecursiveState\n  } from '$lib/typeguards.js'\n  import { filterKeySearchResults, filterValueSearchResults } from '$lib/logic/search.js'\n  import ValidationErrorIcon from './ValidationErrorIcon.svelte'\n  import { isObject } from '$lib/utils/typeUtils.js'\n  import { classnames } from '$lib/utils/cssUtils.js'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n\n  // We pass `pointer` instead of `path` because pointer (a string) is immutable.\n  // Without it, *all* nodes would re-render on *every* change in JSON or DocumentState,\n  // because the path changes every time by re-creating it.\n  export let pointer: JSONPointer\n  export let value: unknown\n  export let state: DocumentState | undefined\n  export let validationErrors: ValidationErrors | undefined\n  export let searchResults: SearchResults | undefined\n  export let selection: JSONSelection | undefined\n  export let context: TreeModeContext\n  export let onDragSelectionStart: (\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) => void\n\n  const debug = createDebug('jsoneditor:JSONNode')\n\n  let hover: string | undefined = undefined\n  let hoverTimer: number | undefined = undefined\n  let dragging: DraggingState | undefined = undefined\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n  $: dataPath = encodeURIComponent(pointer) // This is the same as encodeDataPath(path) but faster\n\n  let expanded: boolean\n  $: expanded = isExpandableState(state) ? state.expanded : false\n\n  let enforceString: boolean\n  $: enforceString = getEnforceString(value, state, [])\n\n  let visibleSections: VisibleSection[] | undefined\n  $: visibleSections = isArrayRecursiveState(state) ? state.visibleSections : undefined\n\n  let validationError: NestedValidationError | undefined\n  $: validationError = validationErrors?.validationError\n\n  let isNodeSelected: boolean\n  $: isNodeSelected = pathInSelection(context.getJson(), selection, path)\n\n  $: root = path.length === 0\n\n  /**\n   * Get sorted keys, applying dragging order\n   */\n  function getKeys(object: Record<string, unknown>, dragging: DraggingState | undefined): string[] {\n    const keys = Object.keys(object)\n\n    // reorder the keys whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        keys,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      )\n    }\n\n    return keys\n  }\n\n  interface ItemIndex {\n    index: number\n    gutterIndex: number\n  }\n\n  function getItems(\n    array: Array<unknown>,\n    visibleSection: VisibleSection,\n    dragging: DraggingState | undefined\n  ): ItemIndex[] {\n    const start = visibleSection.start\n    const end = Math.min(visibleSection.end, array.length)\n    const indices = range(start, end)\n\n    // reorder the items whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        indices,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      ).map((index, gutterIndex) => ({ index, gutterIndex }))\n    }\n\n    return indices.map((index) => ({ index, gutterIndex: index }))\n  }\n\n  function toggleExpand(event: MouseEvent) {\n    event.stopPropagation()\n\n    const recursive = isCtrlKeyDown(event)\n    context.onExpand(path, !expanded, recursive)\n  }\n\n  function handleExpand(event: MouseEvent) {\n    event.stopPropagation()\n\n    context.onExpand(path, true)\n  }\n\n  function handleUpdateKey(oldKey: string, newKey: string): string {\n    const operations = rename(path, Object.keys(value as Record<string, unknown>), oldKey, newKey)\n    context.onPatch(operations)\n\n    // It is possible that the applied key differs from newKey,\n    // to prevent duplicate keys. Here we figure out the actually applied key\n    return last(parseJSONPointer(operations[0].path)) as string\n  }\n\n  function handleMouseDown(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    // check if the mouse down is not happening in the key or value input fields or on a button\n    if (\n      isContentEditableDiv(event.target as HTMLElement) ||\n      (event.buttons === 1 && isChildOfNodeName(event.target as Element, 'BUTTON')) // left mouse on a button\n    ) {\n      return\n    }\n\n    event.stopPropagation()\n    event.preventDefault()\n\n    // due to event.stopPropagation here and there, the focus tracker does not receive this mouse event.\n    // make sure the editor has focus\n    context.focus()\n\n    // we attach the mousemove and mouseup event listeners to the global document,\n    // so we will not miss if the mouse events happen outside the editor\n    document.addEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.addEventListener('mouseup', handleMouseUpGlobal)\n\n    const anchorType = getSelectionTypeFromTarget(event.target as Element)\n    const json = context.getJson()\n    const documentState = context.getDocumentState()\n\n    if (\n      selection &&\n      anchorType !== SelectionType.after &&\n      anchorType !== SelectionType.inside &&\n      (selection.type === anchorType || selection.type === SelectionType.multi) &&\n      pathInSelection(json, selection, path)\n    ) {\n      // when right-clicking inside the current selection, do nothing: context menu will open\n      // when left-clicking inside the current selection, do nothing: it can be the start of dragging\n      if (event.button === 0) {\n        onDragSelectionStart(event)\n      }\n\n      return\n    }\n\n    // TODO: refactor dragging, there are now two separate mechanisms handling mouse movement: with dragging.* and with singleton.*\n    singleton.selecting = true\n    singleton.selectionAnchor = path\n    singleton.selectionAnchorType = anchorType\n    singleton.selectionFocus = path\n\n    if (event.shiftKey) {\n      // Shift+Click will select multiple entries\n      const fullSelection = context.getSelection()\n      if (fullSelection) {\n        context.onSelect(createMultiSelection(getAnchorPath(fullSelection), path))\n      }\n    } else {\n      if (anchorType === SelectionType.multi) {\n        if (root && (event.target as Element).hasAttribute('data-path')) {\n          const lastCaretPosition = last(\n            getVisibleCaretPositions(value, documentState)\n          ) as CaretPosition\n          context.onSelect(fromCaretPosition(lastCaretPosition))\n        } else {\n          context.onSelect(createMultiSelection(path, path))\n        }\n      } else if (json !== undefined) {\n        context.onSelect(fromSelectionType(anchorType, path))\n      }\n    }\n  }\n\n  function handleMouseMove(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (singleton.selectionFocus === undefined) {\n        // First move event, no selection yet.\n        // Clear the default selection of the browser\n        if (window.getSelection) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          window.getSelection().empty()\n        }\n      }\n\n      const selectionType = getSelectionTypeFromTarget(event.target as Element)\n\n      if (\n        !isEqual(path, singleton.selectionFocus) ||\n        selectionType !== singleton.selectionAnchorType\n      ) {\n        singleton.selectionFocus = path\n        singleton.selectionAnchorType = selectionType // TODO: this is a bit ugly\n\n        context.onSelect(\n          createMultiSelection(\n            singleton.selectionAnchor || singleton.selectionFocus,\n            singleton.selectionFocus\n          )\n        )\n      }\n    }\n  }\n\n  function handleMouseMoveGlobal(event: MouseEvent) {\n    context.onDrag(event)\n  }\n\n  function handleMouseUpGlobal(event: Event) {\n    if (singleton.selecting) {\n      singleton.selecting = false\n\n      event.stopPropagation()\n    }\n\n    context.onDragEnd()\n\n    document.removeEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.removeEventListener('mouseup', handleMouseUpGlobal)\n  }\n\n  function findContentTop() {\n    return context.findElement([])?.getBoundingClientRect()?.top || 0\n  }\n\n  function calculateDeltaY(dragging: DraggingState, event: MouseEvent) {\n    // calculate the contentOffset, this changes when scrolling\n    const contentTop = findContentTop()\n    const contentOffset = contentTop - dragging.initialContentTop\n\n    // calculate the vertical mouse movement\n    const clientOffset = event.clientY - dragging.initialClientY\n\n    return clientOffset - contentOffset\n  }\n\n  function handleDragSelectionStart(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (context.readOnly || !selection) {\n      return\n    }\n\n    const selectionParentPath = initial(getFocusPath(selection))\n    if (!isEqual(path, selectionParentPath)) {\n      // pass to parent\n      onDragSelectionStart(event)\n\n      return\n    }\n\n    // note that the returned items will be of one section only,\n    // and when the selection is spread over multiple sections,\n    // no items will be returned: this is not (yet) supported\n    const items = getVisibleItemsWithHeights(selection, visibleSections || DEFAULT_VISIBLE_SECTIONS)\n\n    debug('dragSelectionStart', { selection, items })\n\n    if (!items) {\n      debug('Cannot drag the current selection (probably spread over multiple sections)')\n      return\n    }\n\n    const json = context.getJson()\n    if (json === undefined) {\n      return\n    }\n    const initialPath = getStartPath(json, selection)\n    const selectionStartIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n    const { offset } = onMoveSelection({\n      json,\n      selection: context.getSelection(),\n      deltaY: 0,\n      items\n    })\n\n    dragging = {\n      initialTarget: event.target as Element,\n      initialClientY: event.clientY,\n      initialContentTop: findContentTop(),\n      selectionStartIndex,\n      selectionItemsCount: getSelectionPaths(json, selection).length,\n      items,\n      offset,\n      didMoveItems: false // whether items have been moved during dragging or not\n    }\n    singleton.dragging = true\n\n    document.addEventListener('mousemove', handleDragSelection, true)\n    document.addEventListener('mouseup', handleDragSelectionEnd)\n  }\n\n  function handleDragSelection(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n\n      const deltaY = calculateDeltaY(dragging, event)\n      const { offset } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (offset !== dragging.offset) {\n        debug('drag selection', offset, deltaY)\n\n        dragging = {\n          ...dragging,\n          offset,\n          didMoveItems: true\n        }\n      }\n    }\n  }\n\n  function handleDragSelectionEnd(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n      const deltaY = calculateDeltaY(dragging, event)\n      const { operations, updatedSelection } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (operations) {\n        context.onPatch(operations, (_, patchedState) => ({\n          state: patchedState,\n          selection: updatedSelection ?? selection\n        }))\n      } else {\n        // the user did click inside the selection and no contents have been dragged,\n        // select the clicked item\n        if (event.target === dragging.initialTarget && !dragging.didMoveItems) {\n          const selectionType = getSelectionTypeFromTarget(event.target as Element)\n          const path = getDataPathFromTarget(event.target as Element)\n          if (path) {\n            context.onSelect(fromSelectionType(selectionType, path))\n          }\n        }\n      }\n\n      dragging = undefined\n      singleton.dragging = false\n\n      document.removeEventListener('mousemove', handleDragSelection, true)\n      document.removeEventListener('mouseup', handleDragSelectionEnd)\n    }\n  }\n\n  /**\n   * Get a list with all visible items and their rendered heights inside\n   * this object or array\n   */\n  // TODO: extract and unit test getVisibleItemsWithHeights\n  function getVisibleItemsWithHeights(\n    selection: JSONSelection,\n    visibleSections: VisibleSection[]\n  ): RenderedItem[] | undefined {\n    const items: RenderedItem[] = []\n\n    function addHeight(prop: string) {\n      const itemPath = path.concat(prop)\n      const element = context.findElement(itemPath)\n      if (element !== undefined) {\n        items.push({\n          path: itemPath,\n          height: element.clientHeight\n        })\n      }\n    }\n\n    if (Array.isArray(value)) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return undefined\n      }\n      const startPath = getStartPath(json, selection)\n      const endPath = getEndPath(json, selection)\n      const startIndex = parseInt(last(startPath) as string, 10)\n      const endIndex = parseInt(last(endPath) as string, 10)\n\n      // find the section where the selection is\n      // if the selection is spread over multiple visible sections,\n      // we will not return any items, so dragging will not work there.\n      // We do this to keep things simple for now.\n      const currentSection = visibleSections.find((visibleSection) => {\n        return startIndex >= visibleSection.start && endIndex <= visibleSection.end\n      })\n\n      if (!currentSection) {\n        return undefined\n      }\n\n      const { start, end } = currentSection\n      forEachIndex(start, Math.min(value.length, end), (index) => addHeight(String(index)))\n    } else {\n      // value is Object\n      Object.keys(value as Record<string, unknown>).forEach(addHeight)\n    }\n\n    return items\n  }\n\n  function handleMouseOver(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting || singleton.dragging) {\n      return\n    }\n\n    event.stopPropagation()\n\n    if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-value')) {\n      hover = HOVER_COLLECTION\n    } else if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-key')) {\n      hover = undefined\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-inside')\n    ) {\n      hover = HOVER_INSERT_INSIDE\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-after')\n    ) {\n      hover = HOVER_INSERT_AFTER\n    }\n\n    clearTimeout(hoverTimer)\n  }\n\n  function handleMouseOut(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    event.stopPropagation()\n\n    // to prevent \"flickering\" in the hovering state when hovering on the edge\n    // of the insert area context menu button: it's visibility toggles when\n    // `hover` toggles, which will alternating mouseout and mouseover events\n    hoverTimer = window.setTimeout(() => (hover = undefined))\n  }\n\n  function handleInsertInside(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createInsideSelection(path))\n    }\n  }\n\n  function handleInsertAfter(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createAfterSelection(path))\n    }\n  }\n\n  function handleInsertInsideOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createInsideSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n\n  function handleInsertAfterOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createAfterSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n</script>\n\n<!-- svelte-ignore a11y-mouse-events-have-key-events -->\n<div\n  role=\"treeitem\"\n  tabindex=\"-1\"\n  class={classnames(\n    'jse-json-node',\n    { 'jse-expanded': expanded },\n    context.onClassName(path, value)\n  )}\n  data-path={dataPath}\n  aria-selected={isNodeSelected}\n  style:--level={path.length}\n  class:jse-root={root}\n  class:jse-selected={isNodeSelected && isMultiSelection(selection)}\n  class:jse-selected-value={isNodeSelected && isValueSelection(selection)}\n  class:jse-readonly={context.readOnly}\n  class:jse-hovered={hover === HOVER_COLLECTION}\n  on:mousedown={handleMouseDown}\n  on:mousemove={handleMouseMove}\n  on:mouseover={handleMouseOver}\n  on:mouseout={handleMouseOut}\n>\n  {#if Array.isArray(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this array (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\">\n          <div class=\"jse-meta-inner\" data-type=\"selectable-value\">\n            {#if expanded}\n              <div class=\"jse-bracket\">[</div>\n              <span class=\"jse-tag jse-expanded\">\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </span>\n              &nbsp;\n            {:else}\n              <div class=\"jse-bracket\">[</div>\n              <button type=\"button\" class=\"jse-tag\" on:click={handleExpand}>\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </button>\n              <div class=\"jse-bracket\">]</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-items\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each visibleSections || DEFAULT_VISIBLE_SECTIONS as visibleSection, sectionIndex (sectionIndex)}\n          {#each getItems(value, visibleSection, dragging) as item (item.index)}\n            {@const nestedValidationErrors = isArrayRecursiveState(validationErrors)\n              ? validationErrors.items[item.index]\n              : undefined}\n\n            {@const nestedSelection = selectionIfOverlapping(\n              context.getJson(),\n              selection,\n              path.concat(String(item.index))\n            )}\n\n            <svelte:self\n              value={value[item.index]}\n              pointer={appendToJSONPointer(pointer, item.index)}\n              state={isArrayRecursiveState(state) ? state.items[item.index] : undefined}\n              validationErrors={nestedValidationErrors}\n              searchResults={isArrayRecursiveState(searchResults)\n                ? searchResults.items[item.index]\n                : undefined}\n              selection={nestedSelection}\n              {context}\n              onDragSelectionStart={handleDragSelectionStart}\n            >\n              <div slot=\"identifier\" class=\"jse-identifier\">\n                <div class=\"jse-index\">{item.gutterIndex}</div>\n              </div>\n            </svelte:self>\n          {/each}\n          {#if visibleSection.end < value.length}\n            <CollapsedItems\n              visibleSections={visibleSections || DEFAULT_VISIBLE_SECTIONS}\n              {sectionIndex}\n              total={value.length}\n              {path}\n              onExpandSection={context.onExpandSection}\n              {selection}\n              {context}\n            />\n          {/if}\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <span class=\"jse-bracket\">]</span>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else if isObject(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this object (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\" data-type=\"selectable-value\">\n          <div class=\"jse-meta-inner\">\n            {#if expanded}\n              <div class=\"jse-bracket jse-expanded\">&lbrace;</div>\n            {:else}\n              <div class=\"jse-bracket\">&lbrace;</div>\n              <button type=\"button\" class=\"jse-tag\" on:click={handleExpand}>\n                {Object.keys(value).length}\n                {Object.keys(value).length === 1 ? 'prop' : 'props'}\n              </button>\n              <div class=\"jse-bracket\">&rbrace;</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-props\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each getKeys(value, dragging) as key}\n          {@const propPointer = appendToJSONPointer(pointer, key)}\n\n          {@const nestedSearchResults = isObjectRecursiveState(searchResults)\n            ? searchResults.properties[key]\n            : undefined}\n\n          {@const nestedValidationErrors = isObjectRecursiveState(validationErrors)\n            ? validationErrors.properties[key]\n            : undefined}\n\n          {@const nestedPath = path.concat(key)}\n\n          {@const nestedSelection = selectionIfOverlapping(\n            context.getJson(),\n            selection,\n            nestedPath\n          )}\n\n          <svelte:self\n            value={value[key]}\n            pointer={propPointer}\n            state={isObjectRecursiveState(state) ? state.properties[key] : undefined}\n            validationErrors={nestedValidationErrors}\n            searchResults={nestedSearchResults}\n            selection={nestedSelection}\n            {context}\n            onDragSelectionStart={handleDragSelectionStart}\n          >\n            <div\n              slot=\"identifier\"\n              class=\"jse-key-outer\"\n              class:jse-selected-key={isKeySelection(nestedSelection) &&\n                isEqual(nestedSelection.path, nestedPath)}\n            >\n              <JSONKey\n                pointer={propPointer}\n                {key}\n                selection={nestedSelection}\n                searchResultItems={filterKeySearchResults(nestedSearchResults)}\n                {context}\n                onUpdateKey={handleUpdateKey}\n              />\n            </div>\n          </svelte:self>\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <div class=\"jse-bracket\">&rbrace;</div>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else}\n    <div class=\"jse-contents-outer\">\n      <div class=\"jse-contents\">\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-value-outer\">\n          <JSONValue\n            {path}\n            {value}\n            {enforceString}\n            selection={isNodeSelected ? selection : undefined}\n            searchResultItems={filterValueSearchResults(searchResults)}\n            {context}\n          />\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n  {/if}\n  {#if !context.readOnly && (hover === HOVER_INSERT_AFTER || (isNodeSelected && isAfterSelection(selection)))}\n    <div\n      class=\"jse-insert-area jse-after\"\n      class:jse-hovered={hover === HOVER_INSERT_AFTER}\n      class:jse-selected={isNodeSelected && isAfterSelection(selection)}\n      data-type=\"insert-selection-area-after\"\n      title={INSERT_EXPLANATION}\n    >\n      <ContextMenuPointer\n        insert={true}\n        selected={isNodeSelected && isAfterSelection(selection)}\n        onContextMenu={handleInsertAfterOpenContextMenu}\n      />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./JSONNode.scss\"></style>\n","import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { IconName } from '@fortawesome/fontawesome-common-types'\n\nexport const faJSONEditorExpand: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-expand' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,448 V 512 h 512 v -64 z ' +\n      'M 0,0 V 64 H 512 V 0 Z ' +\n      'M 256,96 128,224 h 256 z ' +\n      'M 256,416 384,288 H 128 Z'\n  ]\n}\n\nexport const faJSONEditorCollapse: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-collapse' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'm 0,224 v 64 h 512 v -64 z ' + 'M 256,192 384,64 H 128 Z ' + 'M 256,320 128,448 h 256 z'\n  ]\n}\n\nexport const faJSONEditorFormat: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-format' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 416 v -64 z ' +\n      'M 160,160 v 64 h 352 v -64 z ' +\n      'M 160,288 v 64 h 288 v -64 z ' +\n      'M 0,416 v 64 h 320 v -64 z'\n  ]\n}\n\nexport const faJSONEditorCompact: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-compact' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 512 v -64 z ' + 'M 0,160 v 64 h 512 v -64 z ' + 'M 0,288 v 64 h 352 v -64 z'\n  ]\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faCopy,\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n  import { faJSONEditorCollapse, faJSONEditorExpand } from '$lib/img/customFontawesomeIcons.js'\n  import { isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type { JSONSelection, MenuItem, OnRenderMenuInternal } from '$lib/types'\n  import { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection.js'\n  import type { HistoryState } from '$lib/logic/history.js'\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n\n  export let readOnly: boolean\n  export let showSearch = false\n  export let historyState: HistoryState\n\n  export let onExpandAll: () => void\n  export let onCollapseAll: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onCopy: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  $: hasJson = json !== undefined\n  $: hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  let expandMenuItem: MenuItem\n  $: expandMenuItem = {\n    type: 'button',\n    icon: faJSONEditorExpand,\n    title: 'Expand all',\n    className: 'jse-expand-all',\n    onClick: onExpandAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let collapseMenuItem: MenuItem\n  $: collapseMenuItem = {\n    type: 'button',\n    icon: faJSONEditorCollapse,\n    title: 'Collapse all',\n    className: 'jse-collapse-all',\n    onClick: onCollapseAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let searchMenuItem: MenuItem\n  $: searchMenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: handleToggleSearch,\n    disabled: json === undefined\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || json === undefined\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || json === undefined\n        },\n        searchMenuItem,\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !historyState.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !historyState.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faCopy,\n          title: 'Copy (Ctrl+C)',\n          className: 'jse-copy',\n          onClick: onCopy,\n          disabled: !hasSelectionContents\n        },\n        {\n          type: 'separator'\n        },\n        searchMenuItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  export let readOnly: boolean\n  export let onCreateArray: () => void\n  export let onCreateObject: () => void\n  export let onClick: () => void\n</script>\n\n<div class=\"jse-welcome\" on:click={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n  <div class=\"jse-contents\">\n    <div class=\"jse-welcome-title\">Empty document</div>\n    {#if !readOnly}\n      <div class=\"jse-welcome-info\">\n        You can paste clipboard data using <b>Ctrl+V</b>, or use the following options:\n      </div>\n      <button\n        title={\"Create an empty JSON object (press '{')\"}\n        on:click|stopPropagation={() => onCreateObject()}>Create object</button\n      >\n      <button\n        title={\"Create an empty JSON array (press '[')\"}\n        on:click|stopPropagation={() => onCreateArray()}>Create array</button\n      >\n    {/if}\n  </div>\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./Welcome.scss\"></style>\n","import diffSequence from '../generated/diffSequence.js'\nimport type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  getIn,\n  isJSONArray,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  parseFrom,\n  parsePath,\n  setIn\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport naturalCompare from 'natural-compare-lite'\nimport { int } from '../utils/numberUtils.js'\nimport { isObject } from '../utils/typeUtils.js'\n\nexport function caseInsensitiveNaturalCompare(a: unknown, b: unknown) {\n  const aLower = typeof a === 'string' ? a.toLowerCase() : a\n  const bLower = typeof b === 'string' ? b.toLowerCase() : b\n\n  return naturalCompare(aLower, bLower)\n}\n\n/**\n * Sort a JSON object or array\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [itemPath=[]]  Item path by which to sort items in case of an array\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with move operation\n *                       to get the array sorted.\n */\nexport function sortJson(\n  json: unknown,\n  rootPath: JSONPath = [],\n  itemPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  if (isJSONArray(getIn(json, rootPath))) {\n    if (itemPath === undefined) {\n      throw new Error('Cannot sort: no property selected by which to sort the array')\n    }\n\n    return sortArray(json, rootPath, itemPath, direction)\n  }\n\n  if (isObject(json)) {\n    return sortObjectKeys(json, rootPath, direction)\n  }\n\n  throw new Error('Cannot sort: no array or object')\n}\n\n/**\n * Sort the keys of an object\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with move operation\n *                       to get the array sorted.\n */\nexport function sortObjectKeys(\n  json: unknown,\n  rootPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const object = getIn(json, rootPath)\n  const keys = Object.keys(object as unknown as Record<string, unknown>)\n  const sortedKeys = keys.slice()\n\n  sortedKeys.sort((keyA, keyB) => {\n    return direction * caseInsensitiveNaturalCompare(keyA, keyB)\n  })\n\n  // TODO: can we make this more efficient? check if the first couple of keys are already in order and if so ignore them\n  const operations: JSONPatchDocument = []\n  for (let i = 0; i < sortedKeys.length; i++) {\n    const key = sortedKeys[i]\n    const path = compileJSONPointer(rootPath.concat(key))\n    operations.push({\n      op: 'move',\n      from: path,\n      path\n    })\n  }\n\n  return operations\n}\n\n/**\n * Sort the items of an array\n * @param json               The document containing (optionally nested)\n *                           the array to be sorted.\n * @param [rootPath=[]]      Relative path when the array was located\n * @param [propertyPath=[]]  Nested path to the property on which to sort the contents\n * @param [direction=1]      Pass 1 to sort ascending, -1 to sort descending\n * @return                   Returns a JSONPatch document with move operation\n *                           to get the array sorted.\n */\nexport function sortArray(\n  json: unknown,\n  rootPath: JSONPath = [],\n  propertyPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const comparator = createObjectComparator(propertyPath, direction)\n\n  // TODO: make the mechanism to sort configurable? Like use sortOperationsMove and sortOperationsMoveAdvanced\n  const array = getIn(json, rootPath) as Array<unknown>\n  return [\n    {\n      op: 'replace',\n      path: compileJSONPointer(rootPath),\n      value: array.slice(0).sort(comparator)\n    }\n  ]\n}\n\n/**\n * Create a comparator function to compare nested properties in an array\n */\nfunction createObjectComparator(propertyPath: JSONPath, direction: 1 | -1) {\n  return function comparator(a: unknown, b: unknown) {\n    const valueA = getIn(a, propertyPath)\n    const valueB = getIn(b, propertyPath)\n\n    if (valueA === undefined) {\n      return direction\n    }\n    if (valueB === undefined) {\n      return -direction\n    }\n\n    if (typeof valueA !== 'string' && typeof valueB !== 'string') {\n      // both values are a number, boolean, or null -> use simple, fast sorting\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return valueA > valueB ? direction : valueA < valueB ? -direction : 0\n    }\n\n    return direction * caseInsensitiveNaturalCompare(valueA, valueB)\n  }\n}\n\n/**\n * Create a list with JSON Patch move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMove<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const operations: JSONPatchOperation[] = []\n  const sorted = []\n\n  // TODO: rewrite the function to pass a callback instead of returning an array?\n  for (let i = 0; i < array.length; i++) {\n    // TODO: can we simplify the following code?\n    const item = array[i]\n    if (i > 0 && comparator(sorted[i - 1], item) > 0) {\n      let j = i - 1\n      while (j > 0 && comparator(sorted[j - 1], item) > 0) {\n        j--\n      }\n\n      operations.push({\n        op: 'move',\n        from: '/' + i,\n        path: '/' + j\n      })\n\n      sorted.splice(j, 0, item)\n    } else {\n      sorted.push(item)\n    }\n  }\n\n  return operations\n}\n\n/**\n * Create an array containing all move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMoveAdvanced<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const moves: { from: number; to: number }[] = []\n\n  const sortedIndices = array\n    .map((item, index) => ({ item, index }))\n    .sort((a, b) => comparator(a.item, b.item))\n    .map((entry) => entry.index)\n\n  let bIndex = 0\n\n  function foundSubsequence(nCommon: number, aCommon: number, bCommon: number) {\n    for (let b = bIndex; b < bCommon; b++) {\n      moves.push({\n        from: sortedIndices[b],\n        to: aCommon\n      })\n    }\n\n    bIndex = bCommon + nCommon\n  }\n\n  const size = array.length\n\n  function isCommon(aIndex: number, bIndex: number) {\n    return aIndex === sortedIndices[bIndex]\n  }\n\n  diffSequence(size, size, isCommon, foundSubsequence)\n  foundSubsequence(0, size, size)\n\n  // every move will change the actual indices, so we've to adjust for that\n  // in all moves that still have to be executed\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i].to > moves[i].from) {\n      moves[i].to--\n    }\n\n    const { from, to } = moves[i]\n\n    for (let j = i + 1; j < moves.length; j++) {\n      const other = moves[j]\n      if (other.from >= from) {\n        other.from--\n      }\n      if (other.to >= from) {\n        other.to--\n      }\n      if (other.from >= to) {\n        other.from++\n      }\n      if (other.to >= to) {\n        other.to++\n      }\n    }\n  }\n\n  return moves.map(({ from, to }) => {\n    return {\n      op: 'move',\n      from: '/' + from,\n      path: '/' + to\n    }\n  })\n}\n\n/**\n * Fast solution to apply many JSON patch move operations inside a single array,\n * like applying all moves needed to sort an array.\n *\n * Throws an error when not all operations are move operation inside the same\n * array.\n */\n// TODO: write unit tests\nexport function fastPatchSort(json: unknown, operations: JSONPatchDocument): unknown {\n  if (isEmpty(operations)) {\n    // nothing to do :)\n    return json\n  }\n\n  // validate whether all operations are \"move\" operations\n  const invalidOp = operations.find((operation) => {\n    return operation.op !== 'move'\n  })\n  if (invalidOp) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not a \"move\" operation ' +\n        '(actual: ' +\n        JSON.stringify(invalidOp) +\n        ')'\n    )\n  }\n\n  // parse all paths\n  const parsedOperations: Array<{ from: JSONPath | undefined; path: JSONPath }> = operations.map(\n    (operation) => ({\n      from:\n        isJSONPatchCopy(operation) || isJSONPatchMove(operation)\n          ? parseFrom(operation.from)\n          : undefined,\n      path: parsePath(json, operation.path)\n    })\n  )\n\n  // validate whether the move actions take place in an array\n  const arrayPath = initial(first(parsedOperations)?.path)\n  const array = getIn(json, arrayPath)\n  if (!Array.isArray(array)) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not an Array ' + '(path: ' + JSON.stringify(arrayPath) + ')'\n    )\n  }\n\n  // validate whether all paths are in the same array\n  const invalidPath = parsedOperations.find((parsedOperation) => {\n    return (\n      !isEqual(arrayPath, initial(parsedOperation.path)) ||\n      !isEqual(arrayPath, initial(parsedOperation.from))\n    )\n  })\n  if (invalidPath) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not all move operations are in the same array ' +\n        '(expected: ' +\n        JSON.stringify(arrayPath) +\n        ', actual: ' +\n        JSON.stringify(invalidPath) +\n        ')'\n    )\n  }\n\n  // apply the actual operations on the same array. Only copy the only array once\n  const updatedArray = array.slice(0)\n  parsedOperations.forEach((parsedOperation) => {\n    const toIndex = int(last(parsedOperation.path) || '-1')\n    const fromIndex = int(last(parsedOperation.from) || '-1')\n\n    const value = updatedArray.splice(fromIndex, 1)[0]\n    updatedArray.splice(toIndex, 0, value)\n  })\n\n  return setIn(json, arrayPath, updatedArray)\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { limit } from '$lib/utils/arrayUtils.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let items: (string | number)[]\n  export let selectedItem: string | number\n  export let onSelect: (item: string | number) => void\n\n  const MAX_ITEMS = 100\n  const MAX_ITEM_CHARACTERS = 30\n</script>\n\n<div class=\"jse-navigation-bar-dropdown\">\n  {#each limit(items, MAX_ITEMS) as item (item)}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      class:jse-selected={item === selectedItem}\n      on:click|stopPropagation={() => onSelect(item)}\n      title={item.toString()}\n    >\n      {truncate(item.toString(), MAX_ITEM_CHARACTERS)}\n    </button>\n  {/each}\n  {#if items.length > MAX_ITEMS}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      title=\"Limited to {MAX_ITEMS} items\"\n    >\n      ...\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarDropdown.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faAngleRight } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarDropdown from '../../../components/controls/navigationBar/NavigationBarDropdown.svelte'\n  import { getContext } from 'svelte'\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let index: number\n  export let onSelect: (path: JSONPath) => void\n  export let getItems: (path: JSONPath) => string[]\n\n  let refNavigationBarItem: Element | undefined\n  let open = false\n  let popupId: number | undefined\n\n  $: itemPath = path.slice(0, index)\n  $: selectedItem = path[index]\n\n  function handleSelectItem(item: string) {\n    closeAbsolutePopup(popupId)\n    onSelect(itemPath.concat(item))\n  }\n\n  function openDropdown() {\n    if (refNavigationBarItem) {\n      open = true\n\n      const props = {\n        items: getItems(itemPath),\n        selectedItem,\n        onSelect: handleSelectItem\n      }\n\n      popupId = openAbsolutePopup(NavigationBarDropdown, props, {\n        anchor: refNavigationBarItem,\n        closeOnOuterClick: true,\n        onClose: () => {\n          open = false\n        }\n      })\n    }\n  }\n</script>\n\n<div class=\"jse-navigation-bar-item\" bind:this={refNavigationBarItem}>\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-button jse-navigation-bar-arrow\"\n    class:jse-open={open}\n    on:click={openDropdown}\n  >\n    <Icon data={faAngleRight} />\n  </button>\n  {#if selectedItem !== undefined}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-button\"\n      on:click={() => handleSelectItem(selectedItem)}\n    >\n      {selectedItem}\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarItem.scss\"></style>\n","export default function copyToClipBoard(text: string): Promise<void> {\n  if (navigator.clipboard) {\n    return navigator.clipboard.writeText(text)\n  }\n  // Compatible with old browsers such as Chrome <=65, Edge <=18 & IE\n  // Compatible with HTTP\n  else if (document.queryCommandSupported?.('copy')) {\n    const textarea = document.createElement('textarea')\n    textarea.value = text\n\n    textarea.style.position = 'fixed' // Avoid scrolling to bottom\n    textarea.style.opacity = '0'\n\n    document.body.appendChild(textarea)\n    textarea.select()\n\n    // Security exception may be thrown by some browsers\n    try {\n      document.execCommand('copy')\n    } catch (e) {\n      console.error(e)\n    } finally {\n      document.body.removeChild(textarea)\n    }\n\n    return Promise.resolve()\n  } else {\n    console.error('Copy failed.')\n\n    return Promise.resolve()\n  }\n}\n","<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getContext, onDestroy, onMount } from 'svelte'\n  import copyToClipBoard from '$lib/utils/copyToClipboard.js'\n  import { faCopy, faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, JSONPathParser, OnError } from '$lib/types.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let pathParser: JSONPathParser\n  export let onChange: (updatedPath: JSONPath) => void\n  export let onClose: () => void\n  export let onError: OnError\n  export let pathExists: (path: JSONPath) => boolean\n\n  let inputRef: HTMLInputElement\n  let inputPath: string\n  let validationActive = false\n  $: inputPath = pathParser.stringify(path)\n  $: inputValidationError = validationActive ? parseAndValidate(inputPath).error : undefined\n\n  let copiedTimer: number | undefined = undefined\n  let copied = false\n  const copiedDelay = 1000 // ms\n\n  onMount(() => {\n    focus()\n  })\n\n  onDestroy(() => {\n    clearTimeout(copiedTimer)\n  })\n\n  function focus() {\n    inputRef.focus()\n  }\n\n  function parseAndValidate(pathStr: string): {\n    path: JSONPath | undefined\n    error: Error | undefined\n  } {\n    try {\n      const path = pathParser.parse(pathStr)\n      validatePathExists(path)\n      return {\n        path,\n        error: undefined\n      }\n    } catch (error) {\n      return {\n        path: undefined,\n        error: error as Error\n      }\n    }\n  }\n\n  function validatePathExists(path: JSONPath) {\n    if (!pathExists(path)) {\n      throw new Error('Path does not exist in current document')\n    }\n  }\n\n  function handleInput(event: Event & { currentTarget: EventTarget & HTMLInputElement }) {\n    inputPath = event.currentTarget.value\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      onClose()\n    }\n\n    if (combo === 'Enter') {\n      validationActive = true\n      const result = parseAndValidate(inputPath)\n      if (result.path !== undefined) {\n        onChange(result.path)\n      } else {\n        onError(result.error as Error)\n      }\n    }\n  }\n\n  function handleCopy() {\n    copyToClipBoard(inputPath)\n    copied = true\n    copiedTimer = window.setTimeout(() => (copied = false), copiedDelay)\n    focus()\n  }\n</script>\n\n<div class=\"jse-navigation-bar-path-editor\" class:error={inputValidationError}>\n  <input\n    type=\"text\"\n    class=\"jse-navigation-bar-text\"\n    value={inputPath}\n    bind:this={inputRef}\n    on:keydown|stopPropagation={handleKeyDown}\n    on:input={handleInput}\n  />\n  {#if inputValidationError}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-validation-error\"\n      use:tooltip={{\n        text: String(inputValidationError || ''),\n        ...absolutePopupContext\n      }}\n    >\n      <Icon data={faExclamationTriangle} />\n    </button>\n  {/if}\n  {#if copied}\n    <div class=\"jse-copied-text\">Copied!</div>\n  {/if}\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-copy\"\n    class:copied\n    title=\"Copy selected path to the clipboard\"\n    on:click={handleCopy}\n  >\n    <Icon data={faCopy} />\n  </button>\n</div>\n\n<style src=\"./NavigationBarPathEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { existsIn, getIn } from 'immutable-json-patch'\n  import { range } from 'lodash-es'\n  import { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import { createMultiSelection, getFocusPath } from '$lib/logic/selection.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { caseInsensitiveNaturalCompare } from '$lib/logic/sort.js'\n  import type { JSONPathParser, JSONSelection, OnError, OnJSONSelect } from '$lib/types.js'\n  import Icon from 'svelte-awesome'\n  import { faClose, faEdit } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarItem from './NavigationBarItem.svelte'\n  import NavigationBarPathEditor from './NavigationBarPathEditor.svelte'\n\n  const debug = createDebug('jsoneditor:NavigationBar')\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n  export let onSelect: OnJSONSelect\n  export let onError: OnError\n  export let pathParser: JSONPathParser\n\n  let refNavigationBar: Element | undefined\n  let editing = false\n\n  $: path = selection ? getFocusPath(selection) : []\n  $: hasNextItem = isObjectOrArray(getIn(json, path))\n\n  // we have an unused parameter path to trigger scrollToLastItem when path changes,\n  // see $: scrollToLastItem(path)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function scrollToLastItem(path: JSONPath) {\n    setTimeout(() => {\n      if (refNavigationBar && refNavigationBar.scrollTo) {\n        const left = refNavigationBar.scrollWidth - refNavigationBar.clientWidth\n        if (left > 0) {\n          debug('scrollTo ', left)\n          refNavigationBar.scrollTo({ left, behavior: 'smooth' })\n        }\n      }\n    })\n  }\n\n  // trigger scrollToLastItem when path changes\n  $: scrollToLastItem(path)\n\n  function getItems(path: JSONPath): string[] {\n    debug('get items for path', path)\n\n    const node = getIn(json, path)\n    if (Array.isArray(node)) {\n      return range(0, node.length).map(String)\n    } else if (isObject(node)) {\n      const keys = Object.keys(node)\n\n      const sortedKeys = keys.slice(0)\n      sortedKeys.sort(caseInsensitiveNaturalCompare)\n\n      return sortedKeys\n    } else {\n      // never happens but just for robustness...\n      return []\n    }\n  }\n\n  function pathExists(path: JSONPath): boolean {\n    return existsIn(json, path)\n  }\n\n  function handleSelect(path: JSONPath) {\n    debug('select path', JSON.stringify(path))\n\n    onSelect(createMultiSelection(path, path))\n  }\n\n  function toggleEditing() {\n    editing = !editing\n  }\n\n  function handleCloseEditor() {\n    editing = false\n  }\n\n  function handleChangePath(path: JSONPath) {\n    handleCloseEditor()\n    handleSelect(path)\n  }\n</script>\n\n<div class=\"jse-navigation-bar\" bind:this={refNavigationBar}>\n  {#if !editing}\n    <!-- eslint-disable-next-line @typescript-eslint/no-unused-vars -->\n    {#each path as item, index (index)}\n      <NavigationBarItem {getItems} {path} {index} onSelect={handleSelect} />\n    {/each}\n    {#if hasNextItem}\n      <NavigationBarItem {getItems} {path} index={path.length} onSelect={handleSelect} />\n    {/if}\n  {:else}\n    <NavigationBarPathEditor\n      {path}\n      onClose={handleCloseEditor}\n      onChange={handleChangePath}\n      {onError}\n      {pathExists}\n      {pathParser}\n    />\n  {/if}\n\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-edit\"\n    class:flex={!editing}\n    class:editing\n    title={editing ? 'Cancel editing the selected path' : 'Edit the selected path'}\n    on:click={toggleEditing}\n  >\n    <span class=\"jse-navigation-bar-space\">\n      <!-- ensure the right height (arrows have less height than the text) -->\n      {!isObjectOrArray(json) && !editing ? 'Navigation bar' : '\\u00A0'}\n    </span>\n\n    <Icon data={editing ? faClose : faEdit} />\n  </button>\n</div>\n\n<style src=\"./NavigationBar.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { debounce } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    faCaretDown,\n    faCaretRight,\n    faChevronDown,\n    faChevronUp,\n    faCircleNotch,\n    faSearch,\n    faTimes\n  } from '@fortawesome/free-solid-svg-icons'\n  import { DEBOUNCE_DELAY, MAX_SEARCH_RESULTS } from '$lib/constants.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { DocumentState, JSONParser, OnPatch, SearchResultDetails } from '$lib/types.js'\n  import {\n    createSearchAndReplaceAllOperations,\n    createSearchAndReplaceOperations,\n    search,\n    searchNext,\n    searchPrevious,\n    updateSearchResult\n  } from '$lib/logic/search.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { tick } from 'svelte'\n\n  const debug = createDebug('jsoneditor:SearchBox')\n\n  export let json: unknown\n  export let documentState: DocumentState | undefined\n  export let parser: JSONParser\n  export let showSearch: boolean\n  export let showReplace: boolean\n  export let readOnly: boolean\n  export let columns: JSONPath[] | undefined\n  export let onSearch: (result: SearchResultDetails | undefined) => void\n  export let onFocus: (path: JSONPath) => Promise<void>\n  export let onPatch: OnPatch\n  export let onClose: () => void\n\n  let text = ''\n  let appliedText = ''\n  let replaceText = ''\n  let searching = false\n  let searchResult: SearchResultDetails | undefined\n\n  $: resultCount = searchResult?.items?.length || 0\n  $: activeIndex = searchResult?.activeIndex || 0\n  $: formattedResultCount =\n    resultCount >= MAX_SEARCH_RESULTS ? `${MAX_SEARCH_RESULTS - 1}+` : String(resultCount)\n\n  $: onSearch(searchResult)\n\n  $: applyChangedShowSearch(showSearch)\n\n  const applyChangedSearchTextDebounced = debounce(applyChangedSearchText, DEBOUNCE_DELAY)\n  $: applyChangedSearchTextDebounced(text)\n\n  const applyChangedJsonDebounced = debounce(applyChangedJson, DEBOUNCE_DELAY)\n  $: applyChangedJsonDebounced(json)\n\n  function toggleShowReplace() {\n    showReplace = !showReplace && !readOnly\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    // key events must not be handled by the generic keydown handler of the\n    // whole JSONEditor.\n    event.stopPropagation()\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n\n      const pendingChanges = text !== appliedText\n      if (pendingChanges) {\n        applyChangedSearchTextDebounced.flush()\n      } else {\n        handleNext()\n      }\n    }\n\n    if (combo === 'Shift+Enter') {\n      event.preventDefault()\n      handlePrevious()\n    }\n\n    if (combo === 'Ctrl+Enter') {\n      event.preventDefault()\n\n      if (showReplace) {\n        handleReplace()\n      } else {\n        handleNext()\n        // TODO: move focus to the active element so you can start editing?\n      }\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      toggleShowReplace()\n    }\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n\n      handleClose()\n    }\n  }\n\n  function handleReplaceKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n      event.stopPropagation()\n\n      handleReplace()\n    }\n  }\n\n  async function handlePaste() {\n    await tick()\n    setTimeout(() => applyChangedSearchTextDebounced.flush())\n  }\n\n  async function handleReplace() {\n    if (readOnly) {\n      return\n    }\n\n    const activeItem = searchResult?.activeItem\n    debug('handleReplace', { replaceText, activeItem })\n\n    if (!searchResult || !activeItem || json === undefined) {\n      return\n    }\n\n    // move to the next search result *before* applying the replacement\n    searchResult = {\n      ...searchNext(searchResult),\n      activeIndex // trick to prevent shortly flickering of index from 1 to 2 and then to 1 again after the next search\n    }\n\n    const { operations, newSelection } = createSearchAndReplaceOperations(\n      json,\n      documentState,\n      replaceText,\n      activeItem,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    // immediately trigger updating the search results\n    await tick()\n    await applyChangedJsonDebounced.flush()\n\n    // focus to the next search result\n    await handleFocus()\n  }\n\n  async function handleReplaceAll() {\n    if (readOnly) {\n      return\n    }\n\n    debug('handleReplaceAll', { text, replaceText })\n\n    const { operations, newSelection } = createSearchAndReplaceAllOperations(\n      json,\n      documentState,\n      text,\n      replaceText,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    await handleFocus()\n  }\n\n  function initSearchInput(element: HTMLInputElement) {\n    element.select()\n  }\n\n  async function handleNext() {\n    searchResult = searchResult ? searchNext(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handlePrevious() {\n    searchResult = searchResult ? searchPrevious(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handleFocus() {\n    debug('handleFocus', searchResult)\n\n    const activeItem = searchResult?.activeItem\n    if (activeItem && json !== undefined) {\n      await onFocus(activeItem.path)\n    }\n  }\n\n  async function applyChangedShowSearch(showSearch: boolean) {\n    await applySearch(showSearch, text, json)\n  }\n\n  async function applyChangedSearchText(text: string) {\n    await applySearch(showSearch, text, json)\n    await handleFocus()\n  }\n\n  async function applyChangedJson(json: unknown) {\n    await applySearch(showSearch, text, json)\n  }\n\n  // we pass searchText and json as argument to trigger search when these variables change,\n  // via various listeners like applyChangedSearchText\n  async function applySearch(showSearch: boolean, text: string, json: unknown): Promise<void> {\n    if (!showSearch) {\n      if (searchResult) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    debug('applySearch', { showSearch, text })\n\n    if (text === '') {\n      debug('clearing search result')\n\n      if (searchResult !== undefined) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    appliedText = text\n    searching = true\n\n    return new Promise<void>((resolve) => {\n      setTimeout(() => {\n        // wait until the search icon has been rendered\n        const newResultItems = search(text, json, { maxResults: MAX_SEARCH_RESULTS, columns })\n        searchResult = updateSearchResult(newResultItems, searchResult)\n\n        searching = false\n        resolve()\n      })\n    })\n  }\n\n  function handleClose() {\n    debug('handleClose')\n    applyChangedSearchTextDebounced.cancel()\n    applyChangedJsonDebounced.cancel()\n    applySearch(false, text, json) // will clear the search results\n    onClose()\n  }\n</script>\n\n{#if showSearch}\n  <div class=\"jse-search-box\">\n    <!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n    <form class=\"jse-search-form\" on:keydown={handleKeyDown}>\n      {#if !readOnly}\n        <button\n          type=\"button\"\n          class=\"jse-replace-toggle\"\n          title=\"Toggle visibility of replace options (Ctrl+H)\"\n          on:click={toggleShowReplace}\n        >\n          <Icon data={showReplace ? faCaretDown : faCaretRight} />\n        </button>\n      {/if}\n      <div class=\"jse-search-contents\">\n        <div class=\"jse-search-section\">\n          <div class=\"jse-search-icon\">\n            {#if searching}\n              <Icon data={faCircleNotch} spin />\n            {:else}\n              <Icon data={faSearch} />\n            {/if}\n          </div>\n          <label class=\"jse-search-input-label\" about=\"jse-search input\">\n            <input\n              class=\"jse-search-input\"\n              title=\"Enter text to search\"\n              type=\"text\"\n              placeholder=\"Find\"\n              bind:value={text}\n              use:initSearchInput\n              on:paste={handlePaste}\n            />\n          </label>\n          <div class=\"jse-search-count\" class:jse-visible={text !== ''}>\n            {activeIndex !== -1 && activeIndex < resultCount\n              ? `${activeIndex + 1}/`\n              : ''}{formattedResultCount}\n          </div>\n          <button\n            type=\"button\"\n            class=\"jse-search-next\"\n            title=\"Go to next search result (Enter)\"\n            on:click={handleNext}\n          >\n            <Icon data={faChevronDown} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-previous\"\n            title=\"Go to previous search result (Shift+Enter)\"\n            on:click={handlePrevious}\n          >\n            <Icon data={faChevronUp} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-clear\"\n            title=\"Close search box (Esc)\"\n            on:click={handleClose}\n          >\n            <Icon data={faTimes} />\n          </button>\n        </div>\n        {#if showReplace && !readOnly}\n          <div class=\"jse-replace-section\">\n            <input\n              class=\"jse-replace-input\"\n              title=\"Enter replacement text\"\n              type=\"text\"\n              placeholder=\"Replace\"\n              bind:value={replaceText}\n              on:keydown={handleReplaceKeyDown}\n            />\n            <button\n              type=\"button\"\n              title=\"Replace current occurrence (Ctrl+Enter)\"\n              on:click={handleReplace}>Replace</button\n            >\n            <button type=\"button\" title=\"Replace all occurrences\" on:click={handleReplaceAll}\n              >All</button\n            >\n          </div>\n        {/if}\n      </div>\n    </form>\n  </div>\n{/if}\n\n<style src=\"./SearchBox.scss\"></style>\n","import type { JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  isJSONArray,\n  isJSONObject,\n  parseJSONPointer\n} from 'immutable-json-patch'\nimport { groupBy, isEmpty, isEqual, mapValues, partition } from 'lodash-es'\nimport type { JSONSelection, SortedColumn, TableCellIndex, ValidationError } from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { createValueSelection, getFocusPath, pathStartsWith } from './selection.js'\nimport { containsNumber } from '../utils/numberUtils.js'\nimport type { Dictionary } from 'lodash'\nimport { stringifyJSONPath } from '$lib/utils/pathUtils.js'\nimport { forEachSample } from '$lib/utils/arrayUtils.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype NestedObject = Record<string, NestedObject>\n\nconst endOfPath = Symbol('path')\n\nexport function getColumns(\n  array: Array<unknown>,\n  flatten: boolean,\n  maxSampleCount = Infinity\n): JSONPath[] {\n  const merged: NestedObject = {}\n\n  if (Array.isArray(array)) {\n    // We read samples spread through the whole array, from begin to end.\n    // When the array is sorted, and a specific field is present only at the last\n    // couple of items of the array or in the middle, we want to pick that up too.\n    forEachSample(array, maxSampleCount, (item) => {\n      if (isObject(item)) {\n        _recurseObject(item, merged, flatten)\n      } else {\n        merged[endOfPath] = true\n      }\n    })\n  }\n\n  const paths: JSONPath[] = []\n  if (endOfPath in merged) {\n    paths.push([])\n  }\n  _collectPaths(merged, [], paths, flatten)\n\n  return paths\n}\n\n// internal function for getColumns\n// mutates the argument merged\nfunction _recurseObject(object: NestedObject, merged: NestedObject, flatten: boolean): void {\n  for (const key in object) {\n    const value = object[key]\n    const valueMerged = merged[key] || (merged[key] = {})\n\n    if (isObject(value) && flatten) {\n      _recurseObject(value, valueMerged, flatten)\n    } else {\n      if (valueMerged[endOfPath] === undefined) {\n        valueMerged[endOfPath] = true\n      }\n    }\n  }\n}\n\n// internal function for getColumns\n// mutates the argument paths\nfunction _collectPaths(\n  object: NestedObject,\n  parentPath: JSONPath,\n  paths: JSONPath[],\n  flatten: boolean\n): void {\n  for (const key in object) {\n    const path = parentPath.concat(key)\n    const value = object[key]\n\n    if (value && value[endOfPath] === true) {\n      paths.push(path)\n    }\n\n    if (isJSONObject(value) && flatten) {\n      _collectPaths(value, path, paths, flatten)\n    }\n  }\n}\n\nexport function maintainColumnOrder(\n  newColumns: JSONPath[],\n  previousColumns: JSONPath[]\n): JSONPath[] {\n  const orderedColumns = new Set(previousColumns.map(compileJSONPointer))\n  const newColumnsSet = new Set(newColumns.map(compileJSONPointer))\n\n  // delete the columns that are gone now\n  for (const column of orderedColumns) {\n    if (!newColumnsSet.has(column)) {\n      orderedColumns.delete(column)\n    }\n  }\n\n  // append the new columns to the end\n  for (const column of newColumnsSet) {\n    if (!orderedColumns.has(column)) {\n      orderedColumns.add(column)\n    }\n  }\n\n  return [...orderedColumns].map(parseJSONPointer)\n}\n\nexport function getShallowKeys(value: unknown): JSONPath[] {\n  return isJSONObject(value) ? Object.keys(value).map((key) => [key]) : [[]]\n}\n\nexport function getRecursiveKeys(value: unknown): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value)) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    } else {\n      // array or primitive value like string or number\n      paths.push(path)\n    }\n  }\n\n  recurse(value, [])\n\n  return paths\n}\n\nexport interface VisibleSection {\n  startIndex: number\n  endIndex: number\n  startHeight: number\n  visibleHeight: number\n  endHeight: number\n  averageItemHeight: number\n  visibleItems: Array<unknown>\n}\n\n// TODO: write unit tests\nexport function calculateVisibleSection(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number,\n  searchBoxOffset: number,\n  margin = 80\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = calculateAverageItemHeight(itemHeights, defaultItemHeight)\n  const viewPortTop = scrollTop - margin\n  const viewPortBottom = viewPortHeight + 2 * margin\n\n  const getItemHeight = (index: number) => itemHeights[index] || defaultItemHeight\n\n  let startIndex = 0\n  let startHeight = searchBoxOffset\n  while (startHeight < viewPortTop && startIndex < itemCount) {\n    startHeight += getItemHeight(startIndex)\n    startIndex++\n  }\n  if (startIndex > 0) {\n    // go one item back, else there is white space at the top for up to 1 missing item\n    startIndex--\n    startHeight -= getItemHeight(startIndex)\n  }\n\n  let endIndex = startIndex\n  let visibleHeight = 0\n  while (visibleHeight < viewPortBottom && endIndex < itemCount) {\n    visibleHeight += getItemHeight(endIndex)\n    endIndex++\n  }\n\n  let endHeight = 0\n  for (let i = endIndex; i < itemCount; i++) {\n    endHeight += getItemHeight(i)\n  }\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: cleanup if we will not use it in the end\n// TODO: write unit tests\nexport function calculateVisibleSectionApprox(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  defaultItemHeight: number\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = defaultItemHeight\n\n  const viewPortTop = scrollTop\n  const startIndex = Math.floor(viewPortTop / defaultItemHeight)\n  const startHeight = startIndex * defaultItemHeight\n  const endIndex = Math.ceil((viewPortTop + viewPortHeight) / defaultItemHeight)\n  const visibleHeight = (endIndex - startIndex) * defaultItemHeight\n  const endHeight = (itemCount - endIndex) * defaultItemHeight\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: write unit tests\nexport function calculateAbsolutePosition(\n  path: JSONPath,\n  columns: JSONPath[],\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const { rowIndex } = toTableCellPosition(path, columns)\n\n  let top = 0\n  for (let currentIndex = 0; currentIndex < rowIndex; currentIndex++) {\n    top += itemHeights[currentIndex] || defaultItemHeight\n  }\n\n  // TODO: also calculate left\n  return top\n}\n\nfunction calculateAverageItemHeight(\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const values = Object.values(itemHeights) // warning: itemHeights is mutated and not updated itself, we can't watch it!\n  if (isEmpty(values)) {\n    return defaultItemHeight\n  }\n\n  const add = (a: number, b: number) => a + b\n  const total = values.reduce(add)\n  return total / values.length\n}\n\nexport function selectPreviousRow(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex > 0) {\n    const previousPosition = { rowIndex: rowIndex - 1, columnIndex }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextRow(\n  json: unknown,\n  columns: JSONPath[],\n  selection: JSONSelection\n): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex < (json as Array<unknown>).length - 1) {\n    const nextPosition = { rowIndex: rowIndex + 1, columnIndex }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function selectPreviousColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex > 0) {\n    const previousPosition = { rowIndex, columnIndex: columnIndex - 1 }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex < columns.length - 1) {\n    const nextPosition = { rowIndex, columnIndex: columnIndex + 1 }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function toTableCellPosition(path: JSONPath, columns: JSONPath[]): TableCellIndex {\n  const [index, ...column] = path\n\n  const rowIndex = parseInt(index, 10)\n\n  return {\n    rowIndex: !isNaN(rowIndex) ? rowIndex : -1,\n    columnIndex: columns.findIndex((c) => pathStartsWith(column, c))\n  }\n}\n\nexport function fromTableCellPosition(position: TableCellIndex, columns: JSONPath[]): JSONPath {\n  const { rowIndex, columnIndex } = position\n\n  return [String(rowIndex), ...columns[columnIndex]]\n}\n\nexport function stringifyTableCellPosition(position: TableCellIndex): string {\n  const { rowIndex, columnIndex } = position\n\n  return `${rowIndex}:${columnIndex}`\n}\n\ninterface GroupedValidationErrorsByRow {\n  row: ValidationError[]\n  columns: Dictionary<ValidationError[]>\n}\n\nexport interface GroupedValidationErrors {\n  root: ValidationError[]\n  rows: Dictionary<GroupedValidationErrorsByRow>\n}\n\n/**\n * Group validation errors for use in the Table view: per column, and a group for the row as a whole\n */\nexport function groupValidationErrors(\n  validationErrors: ValidationError[],\n  columns: JSONPath[]\n): GroupedValidationErrors {\n  const [arrayErrors, rootErrors] = partition(validationErrors, (validationError) =>\n    containsNumber(validationError.path[0])\n  )\n\n  const errorsByRow: Dictionary<ValidationError[]> = groupBy(arrayErrors, findRowIndex)\n\n  const groupedErrorsByRow = mapValues(errorsByRow, (errors) => {\n    const groupByRow: GroupedValidationErrorsByRow = {\n      row: [],\n      columns: {}\n    }\n\n    errors.forEach((error) => {\n      const columnIndex = findColumnIndex(error, columns)\n\n      if (columnIndex !== -1) {\n        if (groupByRow.columns[columnIndex] === undefined) {\n          groupByRow.columns[columnIndex] = []\n        }\n        groupByRow.columns[columnIndex].push(error)\n      } else {\n        groupByRow.row.push(error)\n      }\n    })\n\n    return groupByRow\n  })\n\n  return {\n    root: rootErrors,\n    rows: groupedErrorsByRow\n  }\n}\n\nexport function mergeValidationErrors(\n  path: JSONPath,\n  validationErrors: ValidationError[] | undefined\n): ValidationError | undefined {\n  if (!validationErrors || validationErrors.length === 0) {\n    return undefined\n  }\n\n  if (validationErrors.length === 1) {\n    return validationErrors[0]\n  }\n\n  return {\n    path,\n    message:\n      'Multiple validation issues: ' +\n      validationErrors\n        .map((error) => {\n          return stringifyJSONPath(error.path) + ' ' + error.message\n        })\n        .join(', '),\n    severity: ValidationSeverity.warning\n  }\n}\n\nfunction findRowIndex(error: ValidationError): number {\n  return parseInt(error.path[0], 10)\n}\n\nfunction findColumnIndex(error: ValidationError, columns: JSONPath[]): number {\n  const position = toTableCellPosition(error.path, columns)\n\n  if (position.columnIndex !== -1) {\n    return position.columnIndex\n  }\n\n  return -1\n}\n\n/**\n * Clear the sorted column from the documentState when it is affected by the operations\n */\nexport function clearSortedColumnWhenAffectedByOperations(\n  sortedColumn: SortedColumn | undefined,\n  operations: JSONPatchOperation[],\n  columms: JSONPath[]\n): SortedColumn | undefined {\n  const mustBeCleared = operations.some((operation) =>\n    operationAffectsSortedColumn(sortedColumn, operation, columms)\n  )\n\n  return mustBeCleared ? undefined : sortedColumn\n}\n\nexport function operationAffectsSortedColumn(\n  sortedColumn: SortedColumn | undefined,\n  operation: JSONPatchOperation,\n  columns: JSONPath[]\n): boolean {\n  if (!sortedColumn) {\n    return false\n  }\n\n  // an operation of replacing a value in a different column does not affect the currently sorted order\n  if (operation.op === 'replace') {\n    const path = parseJSONPointer(operation.path)\n    const { rowIndex, columnIndex } = toTableCellPosition(path, columns)\n    const selectedColumnIndex = columns.findIndex((column) => isEqual(column, sortedColumn.path))\n\n    if (rowIndex !== -1 && columnIndex !== -1 && columnIndex !== selectedColumnIndex) {\n      return false\n    }\n  }\n\n  // TODO: there are more cases where we can known an operation does not affect the sorted order, improve this\n  //  For example adding a nested value in a different column, or removing a full row.\n\n  return true\n}\n\n/**\n * Find nested arrays inside a JSON object\n */\nexport function findNestedArrays(json: unknown, maxLevel = 2): JSONPath[] {\n  const props: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value) && path.length < maxLevel) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    }\n\n    if (isJSONArray(value)) {\n      props.push(path)\n    }\n  }\n\n  recurse(json, [])\n\n  return props\n}\n","import {\n  createEditKeySelection,\n  createEditValueSelection,\n  createInsideSelection,\n  createMultiSelection,\n  createValueSelection,\n  getFocusPath,\n  hasSelectionContents,\n  isKeySelection,\n  isValueSelection,\n  selectionToPartialJson\n} from '$lib/logic/selection.js'\nimport copyToClipboard from '$lib/utils/copyToClipboard.js'\nimport {\n  append,\n  createNewValue,\n  createRemoveOperations,\n  duplicate,\n  insert,\n  insertBefore,\n  removeAll\n} from '$lib/logic/operations.js'\nimport type {\n  AfterPatchCallback,\n  InsertType,\n  JSONParser,\n  JSONSelection,\n  OnChange,\n  OnChangeText,\n  OnJSONSelect,\n  OnPatch\n} from '$lib/types'\nimport { createDebug } from '$lib/utils/debug.js'\nimport {\n  getIn,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchReplace,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport { expandAll, expandNone, expandPath, expandSmart } from '$lib/logic/documentState.js'\nimport { initial, isEmpty, last } from 'lodash-es'\nimport { fromTableCellPosition, toTableCellPosition } from '$lib/logic/table.js'\n\nconst debug = createDebug('jsoneditor:actions')\n\nexport interface OnCutAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport async function onCut({\n  json,\n  selection,\n  indentation,\n  readOnly,\n  parser,\n  onPatch\n}: OnCutAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('cut', { selection, clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n\n  const { operations, newSelection } = createRemoveOperations(json, selection)\n\n  onPatch(operations, (_, patchedState) => ({\n    state: patchedState,\n    selection: newSelection\n  }))\n}\n\nexport interface OnCopyAction {\n  json: unknown\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  parser: JSONParser\n}\n\n// TODO: write unit tests\nexport async function onCopy({ json, selection, indentation, parser }: OnCopyAction) {\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('copy', { clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n}\n\ntype RepairModalCallback = (text: string, onApply: (repairedText: string) => void) => void\n\ninterface OnPasteAction {\n  clipboardText: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onChangeText: OnChangeText\n  openRepairModal: RepairModalCallback\n}\n\n// TODO: write unit tests\nexport function onPaste({\n  clipboardText,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onChangeText,\n  openRepairModal\n}: OnPasteAction) {\n  if (readOnly) {\n    return\n  }\n\n  function doPaste(pastedText: string) {\n    if (json !== undefined) {\n      const ensureSelection = selection || createValueSelection([])\n\n      const operations = insert(json, ensureSelection, pastedText, parser)\n\n      debug('paste', { pastedText, operations, ensureSelection })\n\n      onPatch(operations, (patchedJson, patchedState) => {\n        let updatedState = patchedState\n\n        // expand newly inserted object/array\n        operations\n          .filter(\n            (operation) =>\n              (isJSONPatchAdd(operation) || isJSONPatchReplace(operation)) &&\n              isObjectOrArray(operation.value)\n          )\n          .forEach((operation) => {\n            const path = parsePath(json, operation.path)\n            updatedState = expandSmart(patchedJson, updatedState, path)\n          })\n\n        return {\n          state: updatedState\n        }\n      })\n    } else {\n      // no json: empty document, or the contents is invalid text\n      debug('paste text', { pastedText })\n\n      onChangeText(clipboardText, (patchedJson, patchedState) => {\n        if (patchedJson) {\n          const path: JSONPath = []\n          return {\n            state: expandSmart(patchedJson, patchedState, path)\n          }\n        }\n\n        return undefined\n      })\n    }\n  }\n\n  try {\n    doPaste(clipboardText)\n  } catch {\n    openRepairModal(clipboardText, (repairedText) => {\n      debug('repaired pasted text: ', repairedText)\n      doPaste(repairedText)\n    })\n  }\n}\n\nexport interface OnRemoveAction {\n  json: unknown | undefined\n  text: string | undefined\n  selection: JSONSelection | undefined\n  keepSelection: boolean\n  readOnly: boolean\n  onChange: OnChange\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport function onRemove({\n  json,\n  text,\n  selection,\n  keepSelection,\n  readOnly,\n  onChange,\n  onPatch\n}: OnRemoveAction) {\n  if (readOnly || !selection) {\n    return\n  }\n\n  // in case of a selected key or value, we change the selection to the whole\n  // entry to remove this, we do not want to clear a key or value only.\n  const removeSelection =\n    json !== undefined && (isKeySelection(selection) || isValueSelection(selection))\n      ? createMultiSelection(selection.path, selection.path)\n      : selection\n\n  if (isEmpty(getFocusPath(selection))) {\n    // root selected -> clear complete document\n    debug('remove root', { selection })\n\n    if (onChange) {\n      onChange(\n        { text: '', json: undefined },\n        json !== undefined ? { text: undefined, json } : { text: text || '', json },\n        {\n          contentErrors: undefined,\n          patchResult: undefined\n        }\n      )\n    }\n  } else {\n    // remove selection\n    if (json !== undefined) {\n      const { operations, newSelection } = createRemoveOperations(json, removeSelection)\n\n      debug('remove', { operations, selection, newSelection })\n\n      onPatch(operations, (_, patchedState) => ({\n        state: patchedState,\n        selection: keepSelection ? selection : newSelection\n      }))\n    }\n  }\n}\n\nexport interface OnDuplicateRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onDuplicateRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnDuplicateRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('duplicate row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = duplicate(json, [rowPath])\n\n  onPatch(operations, (_, patchedState) => {\n    const newRowIndex = rowIndex < (json as Array<unknown>).length ? rowIndex + 1 : rowIndex\n    const newPath = fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(newPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsertBeforeRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertBeforeRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertBeforeRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert before row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n  const operations = insertBefore(json, rowPath, values)\n\n  onPatch(operations)\n}\n\nexport interface OnInsertAfterRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertAfterRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertAfterRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert after row', { rowIndex })\n\n  const nextRowIndex = rowIndex + 1\n  const nextRowPath = [String(nextRowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n\n  const operations =\n    nextRowIndex < (json as Array<unknown>).length\n      ? insertBefore(json, nextRowPath, values)\n      : append(json, [], values)\n\n  onPatch(operations, (_, patchedState) => {\n    const nextPath = fromTableCellPosition({ rowIndex: nextRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(nextPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnRemoveRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onRemoveRow({ json, selection, columns, readOnly, onPatch }: OnRemoveRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('remove row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = removeAll([rowPath])\n\n  onPatch(operations, (patchedJson, patchedState) => {\n    const newRowIndex =\n      rowIndex < (patchedJson as Array<unknown>).length\n        ? rowIndex\n        : rowIndex > 0\n          ? rowIndex - 1\n          : undefined\n\n    const newSelection =\n      newRowIndex !== undefined\n        ? createValueSelection(\n            fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n          )\n        : undefined\n\n    debug('remove row new selection', { rowIndex, newRowIndex, newSelection })\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsert {\n  insertType: InsertType\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  initialValue: string | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\n// TODO: write unit tests\nexport function onInsert({\n  insertType,\n  selectInside,\n  initialValue,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsert): void {\n  if (readOnly) {\n    return\n  }\n\n  const newValue = createNewValue(json, selection, insertType)\n\n  if (json !== undefined) {\n    const data = parser.stringify(newValue) as string\n    const operations = insert(json, selection, data, parser)\n    debug('onInsert', { insertType, operations, newValue, data })\n\n    const operation = last(\n      operations.filter((operation) => operation.op === 'add' || operation.op === 'replace')\n    )\n\n    onPatch(operations, (patchedJson, patchedState, patchedSelection) => {\n      // TODO: extract determining the newSelection in a separate function\n      if (operation) {\n        const path = parsePath(patchedJson, operation.path)\n\n        if (isObjectOrArray(newValue)) {\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandAll),\n            selection: selectInside ? createInsideSelection(path) : patchedSelection\n          }\n        }\n\n        if (newValue === '') {\n          // open the newly inserted value in edit mode\n          const parent = !isEmpty(path) ? getIn(patchedJson, initial(path)) : undefined\n\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandNone),\n            selection: isObject(parent)\n              ? createEditKeySelection(path, initialValue)\n              : createEditValueSelection(path, initialValue)\n          }\n        }\n      }\n\n      return undefined\n    })\n\n    debug('after patch')\n  } else {\n    // document is empty or invalid (in that case it has text but no json)\n    debug('onInsert', { insertType, newValue })\n\n    const path: JSONPath = []\n    onReplaceJson(newValue, (patchedJson, patchedState) => ({\n      state: expandSmart(patchedJson, patchedState, path),\n      selection: isObjectOrArray(newValue)\n        ? createInsideSelection(path)\n        : createEditValueSelection(path)\n    }))\n  }\n}\n\nexport interface OnInsertCharacter {\n  char: string\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n  onSelect: OnJSONSelect\n}\n\n// TODO: write unit tests\nexport async function onInsertCharacter({\n  char,\n  selectInside,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson,\n  onSelect\n}: OnInsertCharacter) {\n  // a regular key like a, A, _, etc. is entered.\n  // Replace selected contents with a new value having this first character as text\n  if (readOnly) {\n    return\n  }\n\n  if (isKeySelection(selection)) {\n    onSelect({ ...selection, edit: true, initialValue: char })\n    return\n  }\n\n  if (char === '{') {\n    onInsert({\n      insertType: 'object',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else if (char === '[') {\n    onInsert({\n      insertType: 'array',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else {\n    if (isValueSelection(selection) && json !== undefined) {\n      if (!isObjectOrArray(getIn(json, selection.path))) {\n        onSelect({ ...selection, edit: true, initialValue: char })\n      } else {\n        // TODO: replace the object/array with editing a text in edit mode?\n        //  (Ideally this this should not create an entry in history though,\n        //  which isn't really possible right now since we have to apply\n        //  a patch to change the object/array into a value)\n      }\n    } else {\n      debug('onInsertValueWithCharacter', { char })\n      await onInsertValueWithCharacter({\n        char,\n        json,\n        selection,\n        readOnly,\n        parser,\n        onPatch,\n        onReplaceJson\n      })\n    }\n  }\n}\n\ninterface OnInsertValueWithCharacter {\n  char: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\nasync function onInsertValueWithCharacter({\n  char,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsertValueWithCharacter) {\n  if (readOnly) {\n    return\n  }\n\n  // first insert a new value\n  onInsert({\n    insertType: 'value',\n    selectInside: false, // not relevant, we insert a value, not an object or array\n    initialValue: char,\n    json,\n    selection,\n    readOnly,\n    parser,\n    onPatch,\n    onReplaceJson\n  })\n}\n","<script lang=\"ts\">\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { getText } from '$lib/utils/jsonUtils.js'\n  import { MAX_CHARACTERS_TEXT_PREVIEW } from '$lib/constants.js'\n\n  export let text: string | undefined\n  export let json: unknown | undefined\n  export let indentation: number | string\n  export let parser: JSONParser\n\n  $: content = json !== undefined ? { json } : { text: text || '' }\n  $: truncated = truncate(getText(content, indentation, parser), MAX_CHARACTERS_TEXT_PREVIEW)\n</script>\n\n<div class=\"jse-json-preview\">\n  {truncated}\n</div>\n\n<style src=\"./JSONPreview.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuButton } from '$lib/types'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n</script>\n\n<button\n  type=\"button\"\n  class={classnames('jse-context-menu-button', className, item.className)}\n  on:click={(event) => {\n    onRequestClose()\n    item.onClick(event)\n  }}\n  title={item.title}\n  disabled={item.disabled || false}\n>\n  {#if item.icon}\n    <Icon data={item.icon} />\n  {/if}\n  {#if item.text}\n    {item.text}\n  {/if}\n</button>\n\n<style src=\"./ContextMenuButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy, onMount } from 'svelte'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import type { MenuButton } from '$lib/types.js'\n\n  export let items: MenuButton[] = []\n  export let title: string | undefined = undefined\n  export let width = '120px'\n\n  let visible = false\n\n  $: allItemsDisabled = items.every((item) => item.disabled === true)\n\n  function toggleShow() {\n    const wasVisible = visible\n\n    // trigger *after* the handleClick which changes visibility to false\n    setTimeout(() => (visible = !wasVisible))\n  }\n\n  function handleClick() {\n    visible = false\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      visible = false\n    }\n  }\n\n  onMount(() => {\n    document.addEventListener('click', handleClick)\n    document.addEventListener('keydown', handleKeyDown)\n  })\n\n  onDestroy(() => {\n    document.removeEventListener('click', handleClick)\n    document.removeEventListener('keydown', handleKeyDown)\n  })\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<div role=\"button\" tabindex=\"0\" class=\"jse-dropdown-button\" {title} on:click={handleClick}>\n  <slot name=\"defaultItem\" />\n\n  <button\n    type=\"button\"\n    class=\"jse-open-dropdown\"\n    data-type=\"jse-open-dropdown\"\n    class:jse-visible={visible}\n    on:click={toggleShow}\n    disabled={allItemsDisabled}\n  >\n    <Icon data={faCaretDown} />\n  </button>\n\n  <div class=\"jse-dropdown-items\" class:jse-visible={visible} style=\"width: {width};\">\n    <ul>\n      {#each items as item}\n        <li>\n          <button\n            type=\"button\"\n            on:click={(event) => item.onClick(event)}\n            title={item.title}\n            disabled={item.disabled}\n            class={item.className}\n          >\n            {#if item.icon}\n              <Icon data={item.icon} />\n            {/if}\n            {item.text}\n          </button>\n        </li>\n      {/each}\n    </ul>\n  </div>\n</div>\n\n<style src=\"./DropdownButton.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuDropDownButton } from '$lib/types'\n  import DropdownButton from '../DropdownButton.svelte'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuDropDownButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n\n  $: items = item.items.map((item) => ({\n    ...item,\n    onClick: (event: MouseEvent) => {\n      onRequestClose()\n      item.onClick(event)\n    }\n  }))\n</script>\n\n<DropdownButton width={item.width} {items}>\n  <button\n    class={classnames('jse-context-menu-button', className, item.main.className)}\n    type=\"button\"\n    slot=\"defaultItem\"\n    title={item.main.title}\n    on:click={(event) => {\n      onRequestClose()\n      item.main.onClick(event)\n    }}\n    disabled={item.main.disabled || false}\n  >\n    {#if item.main.icon}\n      <Icon data={item.main.icon} />\n    {/if}\n    {item.main.text}\n  </button>\n</DropdownButton>\n\n<style src=\"./ContextMenuDropDownButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { faLightbulb } from '@fortawesome/free-regular-svg-icons'\n  import { findNearestElement } from '$lib/utils/domUtils.js'\n  import type { ContextMenuItem, MenuItem } from '$lib/types.js'\n  import {\n    isContextMenuColumn,\n    isContextMenuRow,\n    isMenuButton,\n    isMenuDropDownButton,\n    isMenuLabel,\n    isMenuSeparator\n  } from '$lib/typeguards.js'\n  import ContextMenuButton from './ContextMenuButton.svelte'\n  import ContextMenuDropDownButton from './ContextMenuDropDownButton.svelte'\n\n  export let items: ContextMenuItem[]\n  export let onRequestClose: () => void\n  export let tip: string | undefined\n\n  let refContextMenu: HTMLDivElement\n\n  onMount(() => {\n    const firstEnabledButton = Array.from(refContextMenu.querySelectorAll('button')).find(\n      (button) => !button.disabled\n    )\n\n    if (firstEnabledButton) {\n      firstEnabledButton.focus()\n    }\n  })\n\n  const directionByCombo: Record<string, 'Up' | 'Down' | 'Left' | 'Right'> = {\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right'\n  }\n\n  function handleKeyDown(event: KeyboardEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    const combo = keyComboFromEvent(event)\n    const direction: 'Up' | 'Down' | 'Left' | 'Right' | undefined = directionByCombo[combo]\n\n    if (direction && event.target) {\n      event.preventDefault()\n\n      const buttons: HTMLButtonElement[] = Array.from(\n        refContextMenu.querySelectorAll('button:not([disabled])')\n      )\n      const nearest = findNearestElement<HTMLButtonElement>({\n        allElements: buttons,\n        currentElement: event.target as unknown as HTMLButtonElement,\n        direction,\n        hasPrio: (element: HTMLButtonElement) => {\n          return element.getAttribute('data-type') !== 'jse-open-dropdown'\n        }\n      })\n      if (nearest) {\n        nearest.focus()\n      }\n    }\n  }\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of context menu item', item)\n    return '???'\n  }\n</script>\n\n<div\n  role=\"menu\"\n  tabindex=\"-1\"\n  class=\"jse-contextmenu\"\n  bind:this={refContextMenu}\n  on:keydown={handleKeyDown}\n>\n  {#each items as item}\n    {#if isMenuButton(item)}\n      <ContextMenuButton {item} {onRequestClose} />\n    {:else if isMenuDropDownButton(item)}\n      <ContextMenuDropDownButton {item} {onRequestClose} />\n    {:else if isContextMenuRow(item)}\n      <div class=\"jse-row\">\n        {#each item.items as rowItem}\n          {#if isMenuButton(rowItem)}\n            <ContextMenuButton item={rowItem} {onRequestClose} />\n          {:else if isMenuDropDownButton(rowItem)}\n            <ContextMenuDropDownButton item={rowItem} {onRequestClose} />\n          {:else if isContextMenuColumn(rowItem)}\n            <div class=\"jse-column\">\n              {#each rowItem.items as columnItem}\n                {#if isMenuButton(columnItem)}\n                  <ContextMenuButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuDropDownButton(columnItem)}\n                  <ContextMenuDropDownButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuSeparator(columnItem)}\n                  <div class=\"jse-separator\"></div>\n                {:else if isMenuLabel(columnItem)}\n                  <div class=\"jse-label\">\n                    {columnItem.text}\n                  </div>\n                {:else}\n                  {unknownMenuItem(columnItem)}\n                {/if}\n              {/each}\n            </div>\n          {:else if isMenuSeparator(rowItem)}\n            <div class=\"jse-separator\"></div>\n          {:else}\n            {unknownMenuItem(rowItem)}\n          {/if}\n        {/each}\n      </div>\n    {:else if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  {#if tip}\n    <div class=\"jse-row\">\n      <div class=\"jse-tip\">\n        <div class=\"jse-tip-icon\">\n          <Icon data={faLightbulb} />\n        </div>\n        <div class=\"jse-tip-text\">{tip}</div>\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./ContextMenu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createAutoScrollHandler } from '../../controls/createAutoScrollHandler.js'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { initial, isEmpty, isEqual, noop, uniqueId } from 'lodash-es'\n  import { getContext, onDestroy, onMount, tick } from 'svelte'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import {\n    collapsePath,\n    createDocumentState,\n    documentStatePatch,\n    expandAll,\n    expandMinimal,\n    expandNone,\n    expandPath,\n    expandSection,\n    expandSelf,\n    expandSmart,\n    getEnforceString,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { createHistory } from '$lib/logic/history.js'\n  import { duplicate, extract, revertJSONPatchWithMoveOperations } from '$lib/logic/operations.js'\n  import {\n    canConvert,\n    createAfterSelection,\n    createEditKeySelection,\n    createEditValueSelection,\n    createInsideSelection,\n    createSelectionFromOperations,\n    createValueSelection,\n    findRootPath,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getInitialSelection,\n    getSelectionDown,\n    getSelectionLeft,\n    getSelectionNextInside,\n    getSelectionPaths,\n    getSelectionRight,\n    getSelectionUp,\n    hasSelectionContents,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isJSONSelection,\n    isKeySelection,\n    isMultiSelection,\n    isMultiSelectionWithOneItem,\n    isSelectionInsidePath,\n    isValueSelection,\n    removeEditModeFromSelection,\n    selectAll\n  } from '$lib/logic/selection.js'\n  import { toRecursiveValidationErrors, validateJSON } from '$lib/logic/validation.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getWindow,\n    isChildOf,\n    isChildOfNodeName\n  } from '$lib/utils/domUtils.js'\n  import {\n    convertValue,\n    isJSONContent,\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '$lib/utils/jsonUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import CopyPasteModal from '../../modals/CopyPasteModal.svelte'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import JSONNode from './JSONNode.svelte'\n  import TreeMenu from './menu/TreeMenu.svelte'\n  import Welcome from './Welcome.svelte'\n  import NavigationBar from '../../controls/navigationBar/NavigationBar.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    ConvertType,\n    DocumentState,\n    HistoryItem,\n    InsertType,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    JSONRepairModalProps,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    ParseError,\n    PastedJson,\n    SearchResultDetails,\n    SearchResults,\n    Section,\n    TransformModalOptions,\n    TreeModeContext,\n    ValidationError,\n    ValidationErrors,\n    Validator,\n    ValueNormalization\n  } from '$lib/types'\n  import { Mode, ValidationSeverity } from '$lib/types.js'\n  import memoizeOne from 'memoize-one'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import {\n    onCopy,\n    onCut,\n    onInsert,\n    onInsertCharacter,\n    onPaste,\n    onRemove\n  } from '$lib/logic/actions.js'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import createTreeContextMenuItems from './contextmenu/createTreeContextMenuItems'\n  import { toRecursiveSearchResults as toRecursiveSearchResults } from 'svelte-jsoneditor/logic/search.js'\n\n  const debug = createDebug('jsoneditor:TreeMode')\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n  let refJsonEditor: HTMLDivElement\n  let hasFocus = false\n  const jump = createJump()\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let indentation: number | string\n  export let onError: OnError\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName | undefined\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n  let copyPasteModalOpen = false\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let documentStateInitialized = false\n  let documentState: DocumentState | undefined = createDocumentState({ json })\n  let selection: JSONSelection | undefined\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  $: emitOnSelect(selection)\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    if (showSearch && refContents.scrollTop === 0) {\n      refContents.style.overflowAnchor = 'none'\n      refContents.scrollTop += SEARCH_BOX_HEIGHT\n      setTimeout(() => {\n        if (refContents) {\n          refContents.style.overflowAnchor = ''\n        }\n      })\n    }\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath) {\n    documentState = expandPath(json, documentState, path, expandNone)\n    await scrollTo(path)\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n    scrollTo(error.path)\n  }\n\n  const history = createHistory<HistoryItem>({\n    onChange: (state) => {\n      historyState = state\n    }\n  })\n  let historyState = history.getState()\n\n  export function expand(path: JSONPath, callback: OnExpand = expandSelf) {\n    debug('expand')\n\n    documentState = expandPath(json, documentState, path, callback)\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean) {\n    documentState = collapsePath(json, documentState, path, recursive)\n\n    if (selection) {\n      // check whether the selection is still visible and not collapsed\n      if (isSelectionInsidePath(selection, path)) {\n        // remove selection when not visible anymore\n        selection = undefined\n      }\n    }\n  }\n\n  // two-way binding of externalContent and internal json and text (\n  // when receiving an updated prop, we have to update state for example\n  $: applyExternalContent(externalContent)\n\n  $: applyExternalSelection(externalSelection)\n\n  let textIsRepaired = false\n\n  let validationErrorList: ValidationError[] = []\n  let validationErrors: ValidationErrors | undefined\n\n  $: updateValidationErrors(json, validator, parser, validationParser)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrorList: ValidationError[]\n        try {\n          newValidationErrorList = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrorList = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrorList, validationErrorList)) {\n          debug('validationErrors changed:', newValidationErrorList)\n          validationErrorList = newValidationErrorList\n          validationErrors = toRecursiveValidationErrors(json, validationErrorList)\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrorList) ? { validationErrors: validationErrorList } : undefined\n  }\n\n  export function getJson() {\n    return json\n  }\n\n  function getDocumentState(): DocumentState | undefined {\n    return documentState\n  }\n\n  function getSelection(): JSONSelection | undefined {\n    return selection\n  }\n\n  function applyExternalContent(updatedContent: Content) {\n    debug('applyExternalContent', { updatedContent })\n\n    if (isJSONContent(updatedContent)) {\n      applyExternalJson(updatedContent.json)\n    } else if (isTextContent(updatedContent)) {\n      applyExternalText(updatedContent.text)\n    }\n  }\n\n  function applyExternalJson(updatedJson: unknown | undefined) {\n    if (updatedJson === undefined) {\n      return\n    }\n\n    // TODO: this is inefficient. Make an optional flag promising that the updates are immutable so we don't have to do a deep equality check? First do some profiling!\n    const isChanged = !isEqual(json, updatedJson)\n\n    debug('update external json', { isChanged, currentlyText: json === undefined })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    json = updatedJson\n    documentState = syncDocumentState(updatedJson, documentState)\n    expandWhenNotInitialized(json)\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalText(updatedText: string | undefined) {\n    if (updatedText === undefined || isJSONContent(externalContent)) {\n      return\n    }\n\n    const isChanged = updatedText !== text\n\n    debug('update external text', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      expandWhenNotInitialized(json)\n      text = updatedText\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        expandWhenNotInitialized(json)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n        clearSelectionWhenNotExisting(json)\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = externalContent['text']\n        textIsRepaired = false\n        parseError =\n          text !== undefined && text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  function expandWhenNotInitialized(json: unknown) {\n    if (!documentStateInitialized) {\n      documentStateInitialized = true\n      documentState = expandSmart(json, documentState, [])\n    }\n  }\n\n  function clearSelectionWhenNotExisting(json: unknown) {\n    if (!selection) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = getInitialSelection(json, documentState)\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: undefined\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined\n      }\n    })\n  }\n\n  function createDefaultSelection() {\n    debug('createDefaultSelection')\n\n    selection = createValueSelection([])\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      textIsRepaired,\n      sortedColumn: undefined\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // update the selection based on the operations\n    const updatedSelection = createSelectionFromOperations(json, operations) ?? selection\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, updatedSelection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : updatedSelection\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    history.add({\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed, we use patch to reconstruct\n        text,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  // TODO: cleanup logging\n  // $: debug('json', json)\n  // $: debug('state', state)\n  // $: debug('selection', selection)\n\n  function handleEditKey() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    selection = createEditKeySelection(getFocusPath(selection))\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path, value)\n    } else {\n      selection = createEditValueSelection(path)\n    }\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  export function acceptAutoRepair(): Content {\n    if (textIsRepaired && json !== undefined) {\n      handleReplaceJson(json)\n    }\n\n    return json !== undefined ? { json } : { text: text || '' }\n  }\n\n  async function handleCut(indent = true) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain') as string | undefined\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  function handlePasteFromMenu() {\n    copyPasteModalOpen = true\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: false,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleDuplicate() {\n    if (\n      readOnly ||\n      json === undefined ||\n      !selection ||\n      !hasSelectionContents ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot duplicate\n    ) {\n      return\n    }\n\n    debug('duplicate', { selection })\n\n    const operations = duplicate(json, getSelectionPaths(json, selection))\n\n    handlePatch(operations)\n  }\n\n  function handleExtract() {\n    if (\n      readOnly ||\n      !selection ||\n      (!isMultiSelection(selection) && !isValueSelection(selection)) ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot extract\n    ) {\n      return\n    }\n\n    debug('extract', { selection })\n\n    const operations = extract(json, selection)\n\n    handlePatch(operations, (patchedJson, patchedState) => {\n      if (isObjectOrArray(patchedJson)) {\n        // expand extracted object/array\n        const path: JSONPath = []\n        return {\n          state: expandSmart(patchedJson, patchedState, path)\n        }\n      }\n\n      return undefined\n    })\n  }\n\n  function handleInsert(insertType: InsertType): void {\n    onInsert({\n      insertType,\n      selectInside: true,\n      initialValue: undefined,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson\n    })\n  }\n\n  function handleInsertFromContextMenu(type: InsertType) {\n    if (isKeySelection(selection)) {\n      // in this case, we do not want to rename the key, but replace the property\n      selection = createValueSelection(selection.path)\n    }\n\n    if (!selection) {\n      selection = getInitialSelection(json, documentState)\n    }\n\n    handleInsert(type)\n  }\n\n  function handleConvert(type: ConvertType) {\n    if (readOnly || !selection) {\n      return\n    }\n\n    if (!canConvert(selection)) {\n      onError(new Error(`Cannot convert current selection to ${type}`))\n      return\n    }\n\n    try {\n      const path = getAnchorPath(selection)\n      const currentValue: unknown = getIn(json, path)\n      const convertedValue = convertValue(\n        currentValue,\n        type as 'value' | 'object' | 'array',\n        parser\n      )\n      if (convertedValue === currentValue) {\n        // no change, do nothing\n        return\n      }\n\n      const operations: JSONPatchDocument = [\n        { op: 'replace', path: compileJSONPointer(path), value: convertedValue }\n      ]\n\n      debug('handleConvert', { selection, path, type, operations })\n\n      handlePatch(operations, (patchedJson, patchedState) => {\n        // expand converted object/array\n        return {\n          state: selection\n            ? expandSmart(patchedJson, patchedState, getFocusPath(selection))\n            : documentState\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleInsertBefore() {\n    if (!selection) {\n      return\n    }\n\n    const selectionBefore = getSelectionUp(json, documentState, selection, false)\n    const parentPath = initial(getFocusPath(selection))\n\n    if (\n      selectionBefore &&\n      !isEmpty(getFocusPath(selectionBefore)) &&\n      isEqual(parentPath, initial(getFocusPath(selectionBefore)))\n    ) {\n      selection = createAfterSelection(getFocusPath(selectionBefore))\n    } else {\n      selection = createInsideSelection(parentPath)\n    }\n\n    debug('insert before', { selection, selectionBefore, parentPath })\n\n    tick().then(() => handleContextMenu())\n  }\n\n  function handleInsertAfter() {\n    if (!selection) {\n      return\n    }\n\n    const path = getEndPath(json, selection)\n\n    debug('insert after', path)\n\n    selection = createAfterSelection(path)\n\n    tick().then(() => handleContextMenu())\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: true,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.getState().canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!item) {\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.getState().canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!item) {\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: async ({ operations }) => {\n        debug('onSort', rootPath, operations)\n\n        handlePatch(operations, (patchedJson, patchedState) => ({\n          // expand the newly replaced array and select it\n          state: expandSmart(patchedJson, patchedState, rootPath),\n          selection: createValueSelection(rootPath)\n        }))\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function handleSortSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openSortModal(rootPath)\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath,\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations, (patchedJson, patchedState) => ({\n            // expand the newly replaced array and select it\n            state: expandSmart(patchedJson, patchedState, rootPath),\n            selection: createValueSelection(rootPath)\n          }))\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function handleTransformSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openTransformModal({\n      rootPath\n    })\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath, value: unknown) {\n    debug('openJSONEditorModal', { path, value })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: value\n      },\n      path,\n      onPatch: context.onPatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export async function scrollTo(path: JSONPath, scrollToWhenVisible = true): Promise<void> {\n    documentState = expandPath(json, documentState, path, expandNone)\n    await tick() // await rerender (else the element we want to scroll to does not yet exist)\n\n    const elem = findElement(path)\n\n    debug('scrollTo', { path, elem, refContents })\n\n    if (!elem || !refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    if (!scrollToWhenVisible) {\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -(viewPortRect.height / 4)\n\n    return new Promise<void>((resolve) => {\n      jump(elem, {\n        container: refContents,\n        offset,\n        duration: SCROLL_DURATION,\n        callback: () => resolve()\n      })\n    })\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    return refContents?.querySelector(`div[data-path=\"${encodeDataPath(path)}\"]`) ?? undefined\n  }\n\n  /**\n   * If given path is outside the visible viewport, scroll up/down.\n   * When the path is already in view, nothing is done\n   */\n  function scrollIntoView(path: JSONPath) {\n    const elem = findElement(path)\n\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    const margin = 20\n    const elemHeight = isObjectOrArray(getIn(json, path))\n      ? margin // do not use real height when array or object\n      : elemRect.height\n\n    if (elemRect.top < viewPortRect.top + margin) {\n      // scroll down\n      jump(elem, {\n        container: refContents,\n        offset: -margin,\n        duration: 0\n      })\n    } else if (elemRect.top + elemHeight > viewPortRect.bottom - margin) {\n      // scroll up\n      jump(elem, {\n        container: refContents,\n        offset: -(viewPortRect.height - elemHeight - margin),\n        duration: 0\n      })\n    }\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (text !== undefined) {\n      const content = { text, json: undefined }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    } else if (json !== undefined) {\n      const content = { text: undefined, json }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    const updatedState = expandPath(\n      json,\n      syncDocumentState(updatedJson, documentState),\n      [],\n      expandMinimal\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = createDocumentState({ json, expand: expandMinimal })\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  /**\n   * Toggle expanded state of a node\n   * @param path The path to be expanded\n   * @param expanded  True if currently expanded, false when currently collapsed\n   * @param [recursive=false]  Only applicable when expanding\n   */\n  function handleExpand(path: JSONPath, expanded: boolean, recursive = false): void {\n    debug('handleExpand', { path, expanded, recursive })\n\n    if (expanded) {\n      expand(path, recursive ? expandAll : expandSelf)\n    } else {\n      collapse(path, recursive)\n    }\n\n    // set focus to the hidden input, so we can capture quick keys like Ctrl+X, Ctrl+C, Ctrl+V\n    focus()\n  }\n\n  function handleExpandAll() {\n    handleExpand([], true, true)\n  }\n\n  function handleCollapseAll() {\n    handleExpand([], false, true)\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    tick().then(() => {\n      // trick to make sure the focus goes to the search box\n      showSearch = true\n      showReplace = findAndReplace\n    })\n  }\n\n  function handleExpandSection(path: JSONPath, section: Section) {\n    debug('handleExpandSection', path, section)\n\n    documentState = expandSection(json, documentState, path, section)\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    const keepAnchorPath = event.shiftKey\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      handleDuplicate()\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      handleInsert('structure')\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      selection = selectAll()\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowUp' || combo === 'Shift+ArrowUp') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionUp(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowDown' || combo === 'Shift+ArrowDown') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionDown(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowLeft' || combo === 'Shift+ArrowLeft') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionLeft(json, documentState, selection, keepAnchorPath, !readOnly) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowRight' || combo === 'Shift+ArrowRight') {\n      event.preventDefault()\n\n      const newSelection =\n        selection && json !== undefined\n          ? getSelectionRight(json, documentState, selection, keepAnchorPath, !readOnly) ||\n            selection\n          : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n\n    if (combo === 'Enter' && selection) {\n      // when the selection consists of a single Array item, change selection to editing its value\n      if (isMultiSelectionWithOneItem(selection)) {\n        const path = selection.focusPath\n        const parent = getIn(json, initial(path))\n        if (Array.isArray(parent)) {\n          // change into selection of the value\n          selection = createValueSelection(path)\n        }\n      }\n\n      if (isKeySelection(selection)) {\n        // go to key edit mode\n        event.preventDefault()\n        selection = { ...selection, edit: true }\n      }\n\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const value = getIn(json, selection.path)\n        if (isObjectOrArray(value)) {\n          // expand object/array\n          handleExpand(selection.path, true)\n        } else {\n          // go to value edit mode\n          selection = { ...selection, edit: true }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Enter' && (isAfterSelection(selection) || isInsideSelection(selection))) {\n      // Enter on an insert area -> open the area in edit mode\n      event.preventDefault()\n      handleInsertCharacter('')\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n      handleRedo()\n    }\n  }\n\n  function handleMouseDown(event: Event) {\n    debug('handleMouseDown', event)\n\n    const target = event.target as HTMLElement\n\n    if (!isChildOfNodeName(target, 'BUTTON') && !target.isContentEditable) {\n      // for example when clicking on the empty area in the main menu\n      focus()\n\n      if (!selection && json === undefined && (text === '' || text === undefined)) {\n        createDefaultSelection()\n      }\n    }\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTreeContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditKey: handleEditKey,\n      onEditValue: handleEditValue,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicate: handleDuplicate,\n      onExtract: handleExtract,\n\n      onInsertBefore: handleInsertBefore,\n      onInsert: handleInsertFromContextMenu,\n      onInsertAfter: handleInsertAfter,\n      onConvert: handleConvert,\n\n      onSort: handleSortSelection,\n      onTransform: handleTransformSelection\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: () => closeAbsolutePopup(popupId)\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event?: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-context-menu-pointer.jse-selected')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTreeMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    pastedJson = undefined\n\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  function handleNavigationBarSelect(newSelection: JSONSelection) {\n    selection = newSelection\n\n    focus()\n    scrollTo(getFocusPath(newSelection))\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection | undefined {\n    return getSelectionNextInside(json, documentState, path)\n  }\n\n  $: autoScrollHandler = refContents ? createAutoScrollHandler(refContents) : undefined\n\n  function handleDrag(event: MouseEvent) {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDrag(event)\n    }\n  }\n\n  function handleDragEnd() {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDragEnd()\n    }\n  }\n\n  // Note that we want the context to change as little as possible since it forces all nodes to re-render,\n  // it should only change when a config option like readOnly or onClassName is changed\n  let context: TreeModeContext\n  $: context = {\n    mode: Mode.tree,\n    readOnly,\n    parser,\n    normalization,\n    getJson,\n    getDocumentState,\n    getSelection,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: handlePatch,\n    onInsert: handleInsert,\n    onExpand: handleExpand,\n    onSelect: handleSelect,\n    onFind: openFind,\n    onExpandSection: handleExpandSection,\n    onPasteJson: handlePasteJson,\n    onRenderValue,\n    onContextMenu: openContextMenu,\n    onClassName: onClassName || (() => undefined),\n    onDrag: handleDrag,\n    onDragEnd: handleDragEnd\n  }\n\n  $: debug('context changed', context)\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<div\n  role=\"tree\"\n  tabindex=\"-1\"\n  class=\"jse-tree-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:keydown={handleKeyDown}\n  on:mousedown={handleMouseDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TreeMenu\n      {json}\n      {selection}\n      {readOnly}\n      {historyState}\n      bind:showSearch\n      onExpandAll={handleExpandAll}\n      onCollapseAll={handleCollapseAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onContextMenu={handleContextMenuFromTreeMenu}\n      onCopy={handleCopy}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if navigationBar}\n    <NavigationBar {json} {selection} onSelect={handleNavigationBarSelect} {onError} {pathParser} />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if json === undefined}\n      {#if text === '' || text === undefined}\n        <Welcome\n          {readOnly}\n          onCreateObject={() => {\n            focus()\n            handleInsertCharacter('{')\n          }}\n          onCreateArray={() => {\n            focus()\n            handleInsertCharacter('[')\n          }}\n          onClick={() => {\n            // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n            //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n            focus()\n          }}\n        />\n      {:else}\n        <Message\n          type=\"error\"\n          message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCode,\n                  text: 'Repair manually',\n                  title: 'Open the document in \"code\" mode and repair it manually',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n        />\n        <JSONPreview {text} {json} {indentation} {parser} />\n      {/if}\n    {:else}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          columns={undefined}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div class=\"jse-contents\" data-jsoneditor-scrollable-contents={true} bind:this={refContents}>\n        {#if showSearch}\n          <div class=\"jse-search-box-background\"></div>\n        {/if}\n        <JSONNode\n          value={json}\n          pointer={''}\n          state={documentState}\n          {validationErrors}\n          {searchResults}\n          {selection}\n          {context}\n          onDragSelectionStart={noop}\n        />\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Replace the value with the pasted JSON',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the JSON embedded in the value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview\n        validationErrors={validationErrorList}\n        selectError={handleSelectValidationError}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TreeMode.scss\"></style>\n","import {\n  faArrowRightArrowLeft,\n  faCaretSquareDown,\n  faCaretSquareUp,\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCropAlt,\n  faCut,\n  faFilter,\n  faPaste,\n  faPen,\n  faPlus,\n  faSortAmountDownAlt,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport {\n  canConvert,\n  getFocusPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  singleItemSelected\n} from '$lib/logic/selection'\nimport type {\n  ConvertType,\n  DocumentState,\n  InsertType,\n  JSONSelection,\n  ContextMenuItem\n} from '$lib/types'\nimport { initial, isEmpty } from 'lodash-es'\nimport { getIn } from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditKey,\n  onEditValue,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicate,\n  onExtract,\n  onInsertBefore,\n  onInsert,\n  onConvert,\n  onInsertAfter,\n  onSort,\n  onTransform\n}: {\n  json: unknown\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditKey: () => void\n  onEditValue: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicate: () => void\n  onExtract: () => void\n  onInsertBefore: () => void\n  onInsert: (type: InsertType) => void\n  onConvert: (type: ConvertType) => void\n  onInsertAfter: () => void\n  onSort: () => void\n  onTransform: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const rootSelected = selection ? isEmpty(getFocusPath(selection)) : false\n  const focusValue = selection ? getIn(json, getFocusPath(selection)) : undefined\n  const editValueText = Array.isArray(focusValue)\n    ? 'Edit array'\n    : isObject(focusValue)\n      ? 'Edit object'\n      : 'Edit value'\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const parent =\n    selection && !rootSelected ? getIn(json, initial(getFocusPath(selection))) : undefined\n\n  const canEditKey =\n    !readOnly && hasJson && singleItemSelected(selection) && !rootSelected && !Array.isArray(parent)\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n  const canCopy = hasSelectionContents\n  const canPaste = !readOnly && hasSelection\n  const canDuplicate = !readOnly && hasJson && hasSelectionContents && !rootSelected // must not be root\n  const canExtract =\n    !readOnly &&\n    hasJson &&\n    selection !== undefined &&\n    (isMultiSelection(selection) || isValueSelection(selection)) &&\n    !rootSelected // must not be root\n\n  const convertMode = hasSelectionContents\n  const insertOrConvertText = convertMode ? 'Convert to:' : 'Insert:'\n\n  const canInsertOrConvertStructure =\n    !readOnly &&\n    ((isInsideSelection(selection) && Array.isArray(focusValue)) ||\n      (isAfterSelection(selection) && Array.isArray(parent)))\n  const canInsertOrConvertObject =\n    !readOnly && (convertMode ? canConvert(selection) && !isObject(focusValue) : hasSelection)\n  const canInsertOrConvertArray =\n    !readOnly && (convertMode ? canConvert(selection) && !Array.isArray(focusValue) : hasSelection)\n  const canInsertOrConvertValue =\n    !readOnly && (convertMode ? canConvert(selection) && isObjectOrArray(focusValue) : hasSelection)\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  function handleInsertOrConvert(type: InsertType) {\n    if (hasSelectionContents) {\n      if (type !== 'structure') {\n        onConvert(type)\n      }\n    } else {\n      onInsert(type)\n    }\n  }\n\n  return [\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onEditKey(),\n          icon: faPen,\n          text: 'Edit key',\n          title: 'Edit the key (Double-click on the key)',\n          disabled: !canEditKey\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onEditValue(),\n            icon: faPen,\n            text: editValueText,\n            title: 'Edit the value (Double-click on the value)',\n            disabled: !canEditValue\n          },\n          width: '11em',\n          items: [\n            {\n              type: 'button',\n              icon: faPen,\n              text: editValueText,\n              title: 'Edit the value (Double-click on the value)',\n              onClick: () => onEditValue(),\n              disabled: !canEditValue\n            },\n            {\n              type: 'button',\n              icon: enforceString ? faCheckSquare : faSquare,\n              text: 'Enforce string',\n              title: 'Enforce keeping the value as string when it contains a numeric value',\n              onClick: () => onToggleEnforceString(),\n              disabled: !canEnforceString\n            }\n          ]\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCut(true),\n            icon: faCut,\n            text: 'Cut',\n            title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n            disabled: !canCut\n          },\n          width: '10em',\n          items: [\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut formatted',\n              title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n              onClick: () => onCut(true),\n              disabled: !canCut\n            },\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut compacted',\n              title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n              onClick: () => onCut(false),\n              disabled: !canCut\n            }\n          ]\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCopy(true),\n            icon: faCopy,\n            text: 'Copy',\n            title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n            disabled: !canCopy\n          },\n          width: '12em',\n          items: [\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy formatted',\n              title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n              onClick: () => onCopy(true),\n              disabled: !canCopy\n            },\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy compacted',\n              title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n              onClick: () => onCopy(false),\n              disabled: !canCopy\n            }\n          ]\n        },\n        {\n          type: 'button',\n          onClick: () => onPaste(),\n          icon: faPaste,\n          text: 'Paste',\n          title: 'Paste clipboard contents (Ctrl+V)',\n          disabled: !canPaste\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            {\n              type: 'button',\n              onClick: () => onDuplicate(),\n              icon: faClone,\n              text: 'Duplicate',\n              title: 'Duplicate selected contents (Ctrl+D)',\n              disabled: !canDuplicate\n            },\n            {\n              type: 'button',\n              onClick: () => onExtract(),\n              icon: faCropAlt,\n              text: 'Extract',\n              title: 'Extract selected contents',\n              disabled: !canExtract\n            },\n            {\n              type: 'button',\n              onClick: () => onSort(),\n              icon: faSortAmountDownAlt,\n              text: 'Sort',\n              title: 'Sort array or object contents',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onTransform(),\n              icon: faFilter,\n              text: 'Transform',\n              title: 'Transform array or object contents (filter, sort, project)',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: insertOrConvertText },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('structure'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Structure',\n              title: insertOrConvertText + ' structure like the first item in the array',\n              disabled: !canInsertOrConvertStructure\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('object'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Object',\n              title: insertOrConvertText + ' object',\n              disabled: !canInsertOrConvertObject\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('array'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Array',\n              title: insertOrConvertText + ' array',\n              disabled: !canInsertOrConvertArray\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('value'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Value',\n              title: insertOrConvertText + ' value',\n              disabled: !canInsertOrConvertValue\n            }\n          ]\n        }\n      ]\n    },\n    {\n      type: 'separator'\n    },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onInsertBefore(),\n          icon: faCaretSquareUp,\n          text: 'Insert before',\n          title: 'Select area before current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        },\n        {\n          type: 'button',\n          onClick: () => onInsertAfter(),\n          icon: faCaretSquareDown,\n          text: 'Insert after',\n          title: 'Select area after current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        }\n      ]\n    }\n  ]\n}\n","/**\n * Create a readonly proxy around an object or array.\n *\n * Will throw an error when trying to mutate the object or array\n *\n * Inspired by: https://github.com/kourge/readonly-proxy/\n */\nexport function readonlyProxy(target: unknown): unknown {\n  if (!isObject(target)) {\n    return target\n  }\n\n  return new Proxy(target, {\n    get(target, property, receiver) {\n      const value = Reflect.get(target, property, receiver)\n\n      return readonlyProxy(value)\n    },\n\n    set() {\n      return false\n    },\n\n    deleteProperty() {\n      return false\n    }\n  })\n}\n\nfunction isObject(value: unknown): value is object {\n  return typeof value === 'object' && value !== null\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import { debounce, isEmpty, noop } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { DEBOUNCE_DELAY } from '$lib/constants.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { transformModalStates, transformModalStateShared } from './transformModalStates.js'\n  import TransformWizard from './TransformWizard.svelte'\n  import TransformModalHeader from './TransformModalHeader.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n  import { createDebug } from '$lib/utils/debug.js'\n  import TreeMode from '../modes/treemode/TreeMode.svelte'\n  import type {\n    Content,\n    JSONParser,\n    JSONPathParser,\n    OnChangeQueryLanguage,\n    OnClassName,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    QueryLanguage,\n    QueryLanguageOptions\n  } from '$lib/types.js'\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { readonlyProxy } from '$lib/utils/readonlyProxy.js'\n  import Modal from './Modal.svelte'\n  import { onMount } from 'svelte'\n\n  const debug = createDebug('jsoneditor:TransformModal')\n\n  export let id = 'transform-modal-' + uniqueId()\n  export let json: unknown\n  export let rootPath: JSONPath = []\n\n  export let indentation: number | string\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName\n\n  export let onTransform: (operations: JSONPatchDocument) => void\n  export let onClose: () => void\n\n  let refQueryInput: HTMLTextAreaElement\n\n  let selectedJson: unknown | undefined\n  $: selectedJson = readonlyProxy(getIn(json, rootPath))\n  let selectedContent: Content\n  $: selectedContent = selectedJson ? { json: selectedJson } : { text: '' }\n\n  let fullscreen = false\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  const state = transformModalStates[stateId] ?? {}\n\n  // showWizard is not stored inside a stateId\n  let showWizard = transformModalStateShared.showWizard !== false\n  let showOriginal = transformModalStateShared.showOriginal !== false\n\n  let queryOptions = state.queryOptions ?? {}\n  let query = queryLanguageId === state.queryLanguageId && state.query ? state.query : ''\n  let isManual = state.isManual ?? false\n  let queryError: string | undefined = undefined\n\n  let previewError: string | undefined = undefined\n  let previewContent: Content = { text: '' }\n\n  if (!isManual) {\n    updateQueryByWizard(queryOptions)\n  }\n\n  onMount(() => {\n    refQueryInput?.focus()\n  })\n\n  function getSelectedQueryLanguage(queryLanguageId: string): QueryLanguage {\n    return queryLanguages.find((item) => item.id === queryLanguageId) ?? queryLanguages[0]\n  }\n\n  function updateQueryByWizard(newQueryOptions: QueryLanguageOptions) {\n    try {\n      queryOptions = newQueryOptions\n\n      query = getSelectedQueryLanguage(queryLanguageId).createQuery(selectedJson, newQueryOptions)\n      queryError = undefined\n      isManual = false\n\n      debug('updateQueryByWizard', { queryOptions, query, isManual })\n    } catch (err) {\n      queryError = String(err)\n    }\n  }\n\n  function handleChangeQuery(event: Event) {\n    query = (event.target as HTMLTextAreaElement).value\n    isManual = true\n    debug('handleChangeQuery', { query, isManual })\n  }\n\n  function previewTransform(previewJson: unknown | undefined, query: string) {\n    if (previewJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    if (query.trim() === '') {\n      previewContent = { json: previewJson }\n      return\n    }\n\n    try {\n      debug('previewTransform', {\n        query\n      })\n\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        previewJson,\n        query,\n        parser\n      )\n\n      previewContent = { json: jsonTransformed }\n      previewError = undefined\n    } catch (err) {\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  const previewTransformDebounced = debounce(previewTransform, DEBOUNCE_DELAY)\n\n  $: {\n    previewTransformDebounced(selectedJson, query)\n  }\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    transformModalStates[stateId] = {\n      queryOptions,\n      query,\n      queryLanguageId,\n      isManual\n    }\n\n    debug('store state in memory', stateId, transformModalStates[stateId])\n  }\n\n  function handleTransform() {\n    if (selectedJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    try {\n      debug('handleTransform', { query })\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        selectedJson,\n        query,\n        parser\n      )\n\n      onTransform([\n        {\n          op: 'replace',\n          path: compileJSONPointer(rootPath),\n          value: jsonTransformed\n        }\n      ])\n\n      onClose()\n    } catch (err) {\n      // this should never occur since we can only press the Transform\n      // button when creating a preview was successful\n      console.error(err)\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  function toggleShowWizard() {\n    showWizard = !showWizard\n\n    // not stored inside a stateId\n    transformModalStateShared.showWizard = showWizard\n  }\n\n  function toggleShowOriginal() {\n    showOriginal = !showOriginal\n\n    // not stored inside a stateId\n    transformModalStateShared.showOriginal = showOriginal\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n\n    updateQueryByWizard(queryOptions)\n  }\n\n  function handleEscape() {\n    if (fullscreen) {\n      fullscreen = !fullscreen\n    } else {\n      onClose()\n    }\n  }\n</script>\n\n<Modal {onClose} className=\"jse-transform-modal\" {fullscreen}>\n  <div class=\"jse-transform-modal-inner\" use:onEscape={handleEscape}>\n    <AbsolutePopup>\n      <TransformModalHeader\n        {queryLanguages}\n        {queryLanguageId}\n        onChangeQueryLanguage={handleChangeQueryLanguage}\n        {onClose}\n        bind:fullscreen\n      />\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-main-contents\">\n          <div class=\"jse-query-contents\">\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Language</div>\n            </div>\n            <div class=\"jse-description\">\n              <!-- eslint-disable-next-line svelte/no-at-html-tags -->\n              {@html getSelectedQueryLanguage(queryLanguageId).description}\n            </div>\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Path</div>\n            </div>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={!isEmpty(rootPath) ? stringifyJSONPath(rootPath) : '(document root)'}\n            />\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">\n                <button type=\"button\" on:click={toggleShowWizard}>\n                  <Icon data={showWizard ? faCaretDown : faCaretRight} />\n                  Wizard\n                </button>\n              </div>\n            </div>\n            {#if showWizard}\n              {#if Array.isArray(selectedJson)}\n                <TransformWizard\n                  {queryOptions}\n                  json={selectedJson}\n                  onChange={updateQueryByWizard}\n                />\n                {#if queryError}\n                  <div class=\"query-error\">\n                    {queryError}\n                  </div>\n                {/if}\n              {:else}\n                (Only available for arrays, not for objects)\n              {/if}\n            {/if}\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Query</div>\n            </div>\n            <textarea\n              bind:this={refQueryInput}\n              class=\"jse-query\"\n              spellcheck=\"false\"\n              on:input={handleChangeQuery}>{query}</textarea\n            >\n          </div>\n          <div class=\"jse-data-contents\" class:jse-hide-original-data={!showOriginal}>\n            <div class=\"jse-original-data\" class:jse-hide={!showOriginal}>\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">\n                  <button type=\"button\" on:click={toggleShowOriginal}>\n                    <Icon data={showOriginal ? faCaretDown : faCaretRight} />\n                    Original\n                  </button>\n                </div>\n              </div>\n              {#if showOriginal}\n                <TreeMode\n                  externalContent={selectedContent}\n                  externalSelection={undefined}\n                  readOnly={true}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {/if}\n            </div>\n            <div class=\"jse-preview-data\">\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">Preview</div>\n              </div>\n              {#if !previewError}\n                <TreeMode\n                  externalContent={previewContent}\n                  externalSelection={undefined}\n                  readOnly={true}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {:else}\n                <div class=\"jse-preview jse-error\">\n                  {previewError}\n                </div>\n              {/if}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"jse-actions\">\n          <button\n            type=\"button\"\n            class=\"jse-primary\"\n            on:click={handleTransform}\n            use:focus\n            disabled={!!previewError}\n          >\n            Transform\n          </button>\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./TransformModal.scss\"></style>\n","export function noop() {\n  return undefined\n}\n","/**\n * Return a human readable document size\n * For example formatSize(7570718) outputs '7.6 MB'\n * @param size\n * @param kilo Is 1000 by default, you can specify 1024 if you\n *                             want the output in KiB\n * @return Returns a human readable size\n */\nexport function formatSize(size: number, kilo = 1000): string {\n  if (size < 0.9 * kilo) {\n    return size.toFixed() + ' B'\n  }\n\n  const KB = size / kilo\n  if (KB < 0.9 * kilo) {\n    return KB.toFixed(1) + ' KB'\n  }\n\n  const MB = KB / kilo\n  if (MB < 0.9 * kilo) {\n    return MB.toFixed(1) + ' MB'\n  }\n\n  const GB = MB / kilo\n  if (GB < 0.9 * kilo) {\n    return GB.toFixed(1) + ' GB'\n  }\n\n  const TB = GB / kilo\n  return TB.toFixed(1) + ' TB'\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { faJSONEditorCompact, faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type { MenuItem, OnRenderMenuInternal } from '$lib/types'\n\n  export let readOnly = false\n  export let onFormat: () => boolean\n  export let onCompact: () => boolean\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onToggleSearch: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let canUndo: boolean\n  export let canRedo: boolean\n  export let canFormat: boolean\n  export let canCompact: boolean\n  export let canSort: boolean\n  export let canTransform: boolean\n  export let onRenderMenu: OnRenderMenuInternal\n\n  const searchItem: MenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: onToggleSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faJSONEditorFormat,\n          title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n          className: 'jse-format',\n          onClick: onFormat,\n          disabled: readOnly || !canFormat\n        },\n        {\n          type: 'button',\n          icon: faJSONEditorCompact,\n          title: 'Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)',\n          className: 'jse-compact',\n          onClick: onCompact,\n          disabled: readOnly || !canCompact\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !canSort\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !canTransform\n        },\n        searchItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        searchItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<script lang=\"ts\">\n  import type { EditorState, Line } from '@codemirror/state'\n\n  export let editorState: EditorState | undefined\n\n  let pos: number | undefined\n  $: pos = editorState?.selection?.main?.head\n\n  let line: Line | undefined\n  $: line = pos !== undefined ? editorState?.doc?.lineAt(pos) : undefined\n\n  let lineNumber: number | undefined\n  $: lineNumber = line !== undefined ? line.number : undefined\n\n  let columnNumber: number | undefined\n  $: columnNumber = line !== undefined && pos !== undefined ? pos - line.from + 1 : undefined\n\n  let charCount: number | undefined\n  $: charCount = editorState?.selection?.ranges?.reduce((count, range) => {\n    return count + range.to - range.from\n  }, 0)\n</script>\n\n<div class=\"jse-status-bar\">\n  {#if lineNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Line: {lineNumber}</div>\n  {/if}\n\n  {#if columnNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Column: {columnNumber}</div>\n  {/if}\n\n  {#if charCount !== undefined && charCount > 0}\n    <div class=\"jse-status-bar-info\">Selection: {charCount} characters</div>\n  {/if}\n</div>\n\n<style src=\"./StatusBar.scss\"></style>\n","import { HighlightStyle, syntaxHighlighting } from '@codemirror/language'\nimport { tags } from '@lezer/highlight'\n\nconst highlightStyle = HighlightStyle.define([\n  { tag: tags.propertyName, color: 'var(--internal-key-color)' }, // keys\n  { tag: tags.number, color: 'var(--internal-value-color-number)' },\n  { tag: tags.bool, color: 'var(--internal-value-color-boolean)' },\n  { tag: tags.string, color: 'var(--internal-value-color-string)' },\n  { tag: tags.keyword, color: 'var(--internal-value-color-null)' } // null\n])\n\nexport const highlighter = syntaxHighlighting(highlightStyle)\n\n// TODO: remove workaround when not needed anymore\n// Workaround for the error \"CodeMirror plugin crashed: TypeError: tags3 is undefined\"\n// thrown when using the json() language from '@codemirror/lang-json'\n//\n// Note that a plain CodeSandbox with parcel and code mirror v6.0.0,\n// so it is maybe related to Vite\n//\n// See https://discuss.codemirror.net/t/highlighting-that-seems-ignored-in-cm6/4320/15\nconst originalStyle = highlightStyle.style\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// noinspection JSConstantReassignment\nhighlightStyle.style = (tags) => originalStyle(tags || [])\n","// source: https://github.com/sveltejs/svelte/issues/7583\n\nlet observer: ResizeObserver\nlet callbacks: WeakMap<Element, (element: Element) => void>\n\n/**\n * Example usage:\n *\n *   <script lang=\"ts\">\n *      let clientWidth = 0\n *   </script>\n *\n *   <div use:resizeObserver={element => clientWidth = element.clientWidth}>\n *      My width is: {clientWidth}\n *   </div>\n */\nexport function resizeObserver(element: Element, onResize: (element: Element) => void) {\n  if (!observer) {\n    callbacks = new WeakMap()\n    observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const onResize = callbacks.get(entry.target)\n        if (onResize) {\n          onResize(entry.target)\n        }\n      }\n    })\n  }\n\n  callbacks.set(element, onResize)\n  observer.observe(element)\n\n  return {\n    destroy: () => {\n      callbacks.delete(element)\n      observer.unobserve(element)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faExclamationTriangle,\n    faEye,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { immutableJSONPatch, revertJSONPatch } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { debounce, isEqual, uniqueId } from 'lodash-es'\n  import { onDestroy, onMount, tick } from 'svelte'\n  import {\n    JSON_STATUS_INVALID,\n    JSON_STATUS_REPAIRABLE,\n    JSON_STATUS_VALID,\n    MAX_CHARACTERS_TEXT_PREVIEW,\n    MAX_DOCUMENT_SIZE_TEXT_MODE,\n    TEXT_MODE_ONCHANGE_DELAY\n  } from '$lib/constants.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    getWindow\n  } from '$lib/utils/domUtils.js'\n  import { formatSize } from '$lib/utils/fileUtils.js'\n  import { findTextLocation, getText, needsFormatting } from '$lib/utils/jsonUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import TextMenu from './menu/TextMenu.svelte'\n  import { Compartment, EditorSelection, EditorState, type Extension } from '@codemirror/state'\n  import {\n    crosshairCursor,\n    drawSelection,\n    dropCursor,\n    EditorView,\n    highlightActiveLine,\n    highlightActiveLineGutter,\n    highlightSpecialChars,\n    keymap,\n    lineNumbers,\n    rectangularSelection\n  } from '@codemirror/view'\n  import {\n    defaultKeymap,\n    history,\n    historyKeymap,\n    indentWithTab,\n    redo,\n    redoDepth,\n    undo,\n    undoDepth\n  } from '@codemirror/commands'\n  import type { Diagnostic } from '@codemirror/lint'\n  import { linter, lintGutter, lintKeymap } from '@codemirror/lint'\n  import { json as jsonLang } from '@codemirror/lang-json'\n  import {\n    bracketMatching,\n    defaultHighlightStyle,\n    foldGutter,\n    foldKeymap,\n    indentOnInput,\n    indentUnit,\n    syntaxHighlighting\n  } from '@codemirror/language'\n  import {\n    closeSearchPanel,\n    highlightSelectionMatches,\n    openSearchPanel,\n    search,\n    searchKeymap\n  } from '@codemirror/search'\n  import {\n    autocompletion,\n    closeBrackets,\n    closeBracketsKeymap,\n    completionKeymap\n  } from '@codemirror/autocomplete'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import jsonSourceMap from 'json-source-map'\n  import StatusBar from './StatusBar.svelte'\n  import { highlighter } from './codemirror/codemirror-theme.js'\n  import type {\n    Content,\n    ContentErrors,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnError,\n    OnFocus,\n    OnRenderMenuInternal,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    ParseError,\n    RichValidationError,\n    TransformModalOptions,\n    ValidationError,\n    Validator\n  } from '$lib/types.js'\n  import { Mode, SelectionType, ValidationSeverity } from '$lib/types.js'\n  import { isContentParseError, isContentValidationErrors } from '$lib/typeguards.js'\n  import memoizeOne from 'memoize-one'\n  import { validateText } from '$lib/logic/validation.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import { indentationMarkers } from '@replit/codemirror-indentation-markers'\n  import { isTextSelection } from '$lib/logic/selection.js'\n  import { wrappedLineIndent } from 'codemirror-wrapped-line-indent'\n\n  export let readOnly: boolean\n  export let mainMenuBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let indentation: number | string\n  export let tabSize: number\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  const debug = createDebug('jsoneditor:TextMode')\n\n  const formatCompactKeyBinding = {\n    key: 'Mod-i',\n    run: handleFormat,\n    shift: handleCompact,\n    preventDefault: true\n  }\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  let codeMirrorRef: HTMLDivElement\n  let domTextMode: HTMLDivElement\n  let codeMirrorView: EditorView\n  let editorState: EditorState\n\n  let onChangeDisabled = false\n  let acceptTooLarge = false\n  let askToFormatApplied = askToFormat\n\n  let validationErrors: ValidationError[] = []\n  const linterCompartment = new Compartment()\n  const readOnlyCompartment = new Compartment()\n  const indentCompartment = new Compartment()\n  const tabSizeCompartment = new Compartment()\n  const themeCompartment = new Compartment()\n\n  let content: Content = externalContent\n  let text = getText(content, indentation, parser) // text is just a cached version of content.text or parsed content.json\n\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters: false,\n    escapeUnicodeCharacters\n  })\n\n  $: setCodeMirrorContent(externalContent, false, false)\n  $: applyExternalSelection(externalSelection)\n  $: updateLinter(validator)\n  $: updateIndentation(indentation)\n  $: updateTabSize(tabSize)\n  $: updateReadOnly(readOnly)\n\n  // force updating the text when escapeUnicodeCharacters changes\n  let previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n  $: {\n    if (previousEscapeUnicodeCharacters !== escapeUnicodeCharacters) {\n      previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n      forceUpdateText()\n    }\n  }\n\n  onMount(async () => {\n    if (isSSR) {\n      return\n    }\n\n    try {\n      codeMirrorView = createCodeMirrorView({\n        target: codeMirrorRef,\n        initialText: !disableTextEditor(text, acceptTooLarge)\n          ? normalization.escapeValue(text)\n          : '',\n        readOnly,\n        indentation\n      })\n    } catch (err) {\n      // TODO: report error to the user\n      console.error(err)\n    }\n  })\n\n  onDestroy(() => {\n    if (codeMirrorView) {\n      debug('Destroy CodeMirror editor')\n      codeMirrorView.destroy()\n    }\n  })\n\n  let canUndo = false\n  let canRedo = false\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  export function focus() {\n    if (codeMirrorView) {\n      debug('focus')\n      codeMirrorView.focus()\n    }\n  }\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  onDestroy(() => {\n    flush()\n  })\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(domTextMode),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(domTextMode),\n    onFocus,\n    onBlur: () => {\n      flush()\n      onBlur()\n    }\n  })\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    return handlePatch(operations, false)\n  }\n\n  export function handlePatch(operations: JSONPatchDocument, emitChange: boolean): JSONPatchResult {\n    debug('handlePatch', operations, emitChange)\n\n    const previousJson = parser.parse(text)\n    const updatedJson = immutableJSONPatch(previousJson, operations)\n    const undo = revertJSONPatch(previousJson, operations)\n    const updatedContent = {\n      text: parser.stringify(updatedJson, null, indentation) as string\n    }\n\n    setCodeMirrorContent(updatedContent, emitChange, false)\n\n    return {\n      json: updatedJson,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handleFormat(): boolean {\n    debug('format')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson, null, indentation) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = askToFormat // reset to the original value\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleCompact(): boolean {\n    debug('compact')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = false\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleRepair() {\n    debug('repair')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const updatedContent = {\n        text: jsonrepair(text)\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onSortModal({\n        id: sortModalId,\n        json,\n        rootPath: [],\n        onSort: async ({ operations }) => {\n          debug('onSort', operations)\n          handlePatch(operations, true)\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal({\n    id,\n    rootPath,\n    onTransform,\n    onClose\n  }: TransformModalOptions) {\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onTransformModal({\n        id: id || transformModalId,\n        json,\n        rootPath: rootPath || [],\n        onTransform: (operations) => {\n          if (onTransform) {\n            onTransform({\n              operations,\n              json,\n              transformedJson: immutableJSONPatch(json, operations)\n            })\n          } else {\n            debug('onTransform', operations)\n            handlePatch(operations, true)\n          }\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n          if (onClose) {\n            onClose()\n          }\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleTransform() {\n    if (readOnly) {\n      return\n    }\n\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function handleToggleSearch() {\n    if (codeMirrorView) {\n      // TODO: figure out the proper way to detect whether the search panel is open\n      if (codeMirrorRef && codeMirrorRef.querySelector('.cm-search')) {\n        closeSearchPanel(codeMirrorView)\n      } else {\n        openSearchPanel(codeMirrorView)\n      }\n    }\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (codeMirrorView) {\n      undo(codeMirrorView)\n      focus()\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (codeMirrorView) {\n      redo(codeMirrorView)\n      focus()\n    }\n  }\n\n  function handleAcceptTooLarge() {\n    acceptTooLarge = true\n    setCodeMirrorContent(externalContent, true, true)\n  }\n\n  function handleSwitchToTreeMode() {\n    onChangeMode(Mode.tree)\n  }\n\n  function cancelLoadTooLarge() {\n    // copy the latest contents of the text editor again into text\n    onChangeCodeMirrorValue()\n  }\n\n  function handleSelectValidationError(validationError: ValidationError) {\n    debug('select validation error', validationError)\n\n    const { from, to } = toRichValidationError(validationError)\n    if (from === undefined || to === undefined) {\n      return\n    }\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function handleSelectParseError(parseError: ParseError) {\n    debug('select parse error', parseError)\n\n    const richParseError = toRichParseError(parseError, false)\n    const from = richParseError.from != null ? richParseError.from : 0\n    const to = richParseError.to != null ? richParseError.to : 0\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function setSelection(anchor: number, head: number) {\n    debug('setSelection', { anchor, head })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch(\n        codeMirrorView.state.update({\n          selection: { anchor, head },\n          scrollIntoView: true\n        })\n      )\n    }\n  }\n\n  function handleDoubleClick(event: MouseEvent, view: EditorView) {\n    // When the user double-clicked right from a bracket [ or {,\n    // select the contents of the array or object\n    if (view.state.selection.ranges.length === 1) {\n      const range = view.state.selection.ranges[0]\n      const selectedText = text.slice(range.from, range.to)\n      if (selectedText === '{' || selectedText === '[') {\n        const jsmap = jsonSourceMap.parse(text)\n        const path = Object.keys(jsmap.pointers).find((path) => {\n          const pointer = jsmap.pointers[path]\n          return pointer.value?.pos === range.from\n        })\n        const pointer = jsmap.pointers[path]\n\n        if (path && pointer && pointer.value && pointer.valueEnd) {\n          debug('pointer found, selecting inner contents of path:', path, pointer)\n          const anchor = pointer.value.pos + 1\n          const head = pointer.valueEnd.pos - 1\n          setSelection(anchor, head)\n        }\n      }\n    }\n  }\n\n  function createLinter() {\n    return linter(linterCallback, { delay: TEXT_MODE_ONCHANGE_DELAY })\n  }\n\n  function createCodeMirrorView({\n    target,\n    initialText,\n    readOnly,\n    indentation\n  }: {\n    target: HTMLDivElement\n    initialText: string\n    readOnly: boolean\n    indentation: number | string\n  }): EditorView {\n    debug('Create CodeMirror editor', { readOnly, indentation })\n\n    const state = EditorState.create({\n      doc: initialText,\n      selection: isValidSelection(externalSelection, initialText)\n        ? toCodeMirrorSelection(externalSelection)\n        : undefined,\n      extensions: [\n        keymap.of([indentWithTab, formatCompactKeyBinding]),\n        linterCompartment.of(createLinter()),\n        lintGutter(),\n        lineNumbers(),\n        highlightActiveLineGutter(),\n        highlightSpecialChars(),\n        history(),\n        foldGutter(),\n        drawSelection(),\n        dropCursor(),\n        EditorState.allowMultipleSelections.of(true),\n        indentOnInput(),\n        syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n        bracketMatching(),\n        closeBrackets(),\n        autocompletion(),\n        rectangularSelection(),\n        crosshairCursor(),\n        highlightActiveLine(),\n        highlightSelectionMatches(),\n        keymap.of([\n          ...closeBracketsKeymap,\n          ...defaultKeymap,\n          ...searchKeymap,\n          ...historyKeymap,\n          ...foldKeymap,\n          ...completionKeymap,\n          ...lintKeymap\n        ]),\n        highlighter,\n        indentationMarkers({ hideFirstIndent: true }),\n        EditorView.domEventHandlers({\n          dblclick: handleDoubleClick\n        }),\n        EditorView.updateListener.of((update) => {\n          editorState = update.state\n\n          if (update.docChanged) {\n            onChangeCodeMirrorValueDebounced()\n          } else if (update.selectionSet) {\n            // note that emitOnSelect is invoked in onChangeCodeMirrorValue too,\n            // right after firing onChange. Hence, the else if here, we do not want to fire it twice.\n            emitOnSelect()\n          }\n        }),\n        jsonLang(),\n        search({\n          top: true\n        }),\n        EditorView.lineWrapping,\n        readOnlyCompartment.of(EditorState.readOnly.of(readOnly)),\n        tabSizeCompartment.of(EditorState.tabSize.of(tabSize)),\n        indentCompartment.of(createIndent(indentation)),\n        themeCompartment.of(EditorView.theme({}, { dark: hasDarkTheme() }))\n      ]\n    })\n\n    codeMirrorView = new EditorView({\n      state,\n      parent: target\n    })\n\n    return codeMirrorView\n  }\n\n  function getCodeMirrorValue() {\n    return codeMirrorView ? normalization.unescapeValue(codeMirrorView.state.doc.toString()) : ''\n  }\n\n  function hasDarkTheme() {\n    return codeMirrorRef\n      ? getComputedStyle(codeMirrorRef).getPropertyValue('--jse-theme').includes('dark')\n      : false\n  }\n\n  function isValidSelection(selection: JSONEditorSelection | undefined, text: string): boolean {\n    if (!isTextSelection(selection)) {\n      return false\n    }\n\n    return selection.ranges.every((range) => range.anchor < text.length && range.head < text.length)\n  }\n\n  function toRichValidationError(validationError: ValidationError): RichValidationError {\n    const { path, message, severity } = validationError\n    const { line, column, from, to } = findTextLocation(normalization.escapeValue(text), path)\n\n    return {\n      path,\n      line,\n      column,\n      from,\n      to,\n      message,\n      severity,\n      actions: []\n    }\n  }\n\n  function toRichParseError(parseError: ParseError, isRepairable: boolean): RichValidationError {\n    const { line, column, position, message } = parseError\n\n    return {\n      path: [] as JSONPath,\n      line,\n      column,\n      from: position,\n      to: position,\n      severity: ValidationSeverity.error,\n      message,\n      actions:\n        isRepairable && !readOnly\n          ? [\n              {\n                name: 'Auto repair',\n                apply: () => handleRepair()\n              }\n            ]\n          : undefined\n    }\n  }\n\n  function toDiagnostic(error: RichValidationError): Diagnostic {\n    return {\n      from: error.from || 0,\n      to: error.to || 0,\n      message: error.message || '',\n      actions: error.actions as Diagnostic['actions'],\n      severity: error.severity\n    }\n  }\n\n  function setCodeMirrorContent(newContent: Content, emitChange: boolean, forceUpdate: boolean) {\n    const newText = getText(newContent, indentation, parser)\n    const isChanged = !isEqual(newContent, content)\n    const previousContent = content\n\n    debug('setCodeMirrorContent', { isChanged, emitChange, forceUpdate })\n\n    if (!codeMirrorView || (!isChanged && !forceUpdate)) {\n      return\n    }\n\n    content = newContent\n    text = newText\n\n    if (!disableTextEditor(text, acceptTooLarge)) {\n      // keep state\n      // to reset state: codeMirrorView.setState(EditorState.create({doc: text, extensions: ...}))\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n\n    updateCanUndoRedo()\n\n    if (isChanged && emitChange) {\n      emitOnChange(content, previousContent)\n    }\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (!isTextSelection(externalSelection)) {\n      return\n    }\n\n    const selection = toCodeMirrorSelection(externalSelection)\n    if (codeMirrorView && selection && (!editorState || !editorState.selection.eq(selection))) {\n      debug('applyExternalSelection', selection)\n\n      // note that we cannot clear the selection (we could maybe set the cursor to 0 but that's not really what we want)\n      codeMirrorView.dispatch({ selection })\n    }\n  }\n\n  function toCodeMirrorSelection(\n    selection: JSONEditorSelection | undefined\n  ): EditorSelection | undefined {\n    return isTextSelection(selection) ? EditorSelection.fromJSON(selection) : undefined\n  }\n\n  /**\n   * Force refreshing the editor, for example after changing the font size\n   * to update the positioning of the line numbers in the gutter\n   */\n  export async function refresh(): Promise<void> {\n    debug('refresh')\n\n    // update the theme (light/dark), but also, as a side effect,\n    // refresh the font size of the line numbers in the gutter\n    await updateTheme()\n  }\n\n  function forceUpdateText() {\n    debug('forceUpdateText', { escapeUnicodeCharacters })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n  }\n\n  function onChangeCodeMirrorValue() {\n    if (onChangeDisabled || !codeMirrorView) {\n      return\n    }\n\n    const codeMirrorText = getCodeMirrorValue()\n\n    const isChanged = codeMirrorText !== text\n    debug('onChangeCodeMirrorValue', { isChanged })\n    if (!isChanged) {\n      return\n    }\n\n    const previousContent = content\n    text = codeMirrorText\n    content = { text }\n\n    updateCanUndoRedo()\n    emitOnChange(content, previousContent)\n\n    // We emit OnSelect on the next tick to cater for the case where\n    // the user changes the content directly inside the OnChange callback.\n    // This change will be dispatched by Svelte on the next tick. Before\n    // that tick, emitOnSelect would be fired based on the \"old\" contents,\n    // which may be out of range when the replacement by the user is shorter.\n    tick().then(emitOnSelect)\n  }\n\n  function updateLinter(validator: Validator | undefined) {\n    debug('updateLinter', validator)\n\n    if (!codeMirrorView) {\n      return\n    }\n\n    codeMirrorView.dispatch({\n      effects: linterCompartment.reconfigure(createLinter())\n    })\n  }\n\n  function updateIndentation(indentation: number | string) {\n    if (codeMirrorView) {\n      debug('updateIndentation', indentation)\n\n      codeMirrorView.dispatch({\n        effects: indentCompartment.reconfigure(createIndent(indentation))\n      })\n    }\n  }\n\n  function updateTabSize(tabSize: number) {\n    if (codeMirrorView) {\n      debug('updateTabSize', tabSize)\n\n      codeMirrorView.dispatch({\n        effects: tabSizeCompartment.reconfigure(EditorState.tabSize.of(tabSize))\n      })\n    }\n  }\n\n  function updateReadOnly(readOnly: boolean) {\n    if (codeMirrorView) {\n      debug('updateReadOnly', readOnly)\n\n      codeMirrorView.dispatch({\n        effects: [readOnlyCompartment.reconfigure(EditorState.readOnly.of(readOnly))]\n      })\n    }\n  }\n\n  async function updateTheme(): Promise<void> {\n    // we check the theme on the next tick, to make sure the page\n    // is re-rendered with (possibly) changed CSS variables\n    await tick()\n\n    if (codeMirrorView) {\n      const dark = hasDarkTheme()\n      debug('updateTheme', { dark })\n\n      codeMirrorView.dispatch({\n        effects: [themeCompartment.reconfigure(EditorView.theme({}, { dark }))]\n      })\n    }\n  }\n\n  function createIndent(indentation: number | string): Extension[] {\n    const indent = indentUnit.of(\n      typeof indentation === 'number' ? ' '.repeat(indentation) : indentation\n    )\n\n    // We disable wrappedLineIndent in case of tabs to work around a bug:\n    // https://github.com/fauzi9331/codemirror-wrapped-line-indent/issues/2\n    return indentation === '\\t' ? [indent] : [indent, wrappedLineIndent]\n  }\n\n  function updateCanUndoRedo() {\n    canUndo = undoDepth(codeMirrorView.state) > 0\n    canRedo = redoDepth(codeMirrorView.state) > 0\n\n    debug({ canUndo, canRedo })\n  }\n\n  // debounce the input: when pressing Enter at the end of a line, two change\n  // events are fired: one with the new Return character, and a second with\n  // indentation added on the new line. This causes a race condition when used\n  // for example in React. Debouncing the onChange events also results in not\n  // firing a change event with every character that a user types, but only as\n  // soon as the user stops typing.\n  const onChangeCodeMirrorValueDebounced = debounce(\n    onChangeCodeMirrorValue,\n    TEXT_MODE_ONCHANGE_DELAY\n  )\n\n  function flush() {\n    onChangeCodeMirrorValueDebounced.flush()\n  }\n\n  function emitOnChange(content: Content, previousContent: Content) {\n    if (onChange) {\n      onChange(content, previousContent, {\n        contentErrors: validate(),\n        patchResult: undefined\n      })\n    }\n  }\n\n  function emitOnSelect() {\n    onSelect({\n      type: SelectionType.text,\n      ...editorState.selection.toJSON()\n    })\n  }\n\n  function disableTextEditor(text: string, acceptTooLarge: boolean): boolean {\n    const tooLarge = text ? text.length > MAX_DOCUMENT_SIZE_TEXT_MODE : false\n    return tooLarge && !acceptTooLarge\n  }\n\n  let jsonStatus = JSON_STATUS_VALID\n\n  let jsonParseError: ParseError | undefined\n\n  function linterCallback(): Diagnostic[] {\n    if (disableTextEditor(text, acceptTooLarge)) {\n      return []\n    }\n\n    const contentErrors = validate()\n\n    if (isContentParseError(contentErrors)) {\n      const { parseError, isRepairable } = contentErrors\n\n      return [toDiagnostic(toRichParseError(parseError, isRepairable))]\n    }\n\n    if (isContentValidationErrors(contentErrors)) {\n      return contentErrors.validationErrors.map(toRichValidationError).map(toDiagnostic)\n    }\n\n    return []\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate:start')\n\n    flush()\n\n    const contentErrors = memoizedValidateText(\n      normalization.escapeValue(text),\n      validator,\n      parser,\n      validationParser\n    )\n\n    if (isContentParseError(contentErrors)) {\n      jsonStatus = contentErrors.isRepairable ? JSON_STATUS_REPAIRABLE : JSON_STATUS_INVALID\n      jsonParseError = contentErrors.parseError\n      validationErrors = []\n    } else {\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n      validationErrors = contentErrors?.validationErrors || []\n    }\n\n    debug('validate:end')\n\n    return contentErrors\n  }\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidateText = memoizeOne(validateText)\n\n  function handleShowMe() {\n    if (jsonParseError) {\n      handleSelectParseError(jsonParseError)\n    }\n  }\n\n  const repairActionShowMe = {\n    icon: faEye,\n    text: 'Show me',\n    title: 'Move to the parse error location',\n    onClick: handleShowMe\n  }\n\n  $: repairActions =\n    jsonStatus === JSON_STATUS_REPAIRABLE && !readOnly\n      ? [\n          {\n            icon: faWrench,\n            text: 'Auto repair',\n            title: 'Automatically repair JSON',\n            onClick: handleRepair\n          },\n          repairActionShowMe\n        ]\n      : [repairActionShowMe]\n</script>\n\n<div class=\"jse-text-mode\" class:no-main-menu={!mainMenuBar} bind:this={domTextMode}>\n  {#if mainMenuBar}\n    {@const isNewDocument = text.length === 0}\n\n    <TextMenu\n      {readOnly}\n      onFormat={handleFormat}\n      onCompact={handleCompact}\n      onSort={handleSort}\n      onTransform={handleTransform}\n      onToggleSearch={handleToggleSearch}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      canFormat={!isNewDocument}\n      canCompact={!isNewDocument}\n      canSort={!isNewDocument}\n      canTransform={!isNewDocument}\n      {canUndo}\n      {canRedo}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    {@const editorDisabled = disableTextEditor(text, acceptTooLarge)}\n\n    <div class=\"jse-contents\" class:jse-hidden={editorDisabled} bind:this={codeMirrorRef}></div>\n\n    {#if editorDisabled}\n      <Message\n        icon={faExclamationTriangle}\n        type=\"error\"\n        message={`The JSON document is larger than ${formatSize(\n          MAX_DOCUMENT_SIZE_TEXT_MODE,\n          1024\n        )}, ` +\n          `and may crash your browser when loading it in text mode. Actual size: ${formatSize(\n            text.length,\n            1024\n          )}.`}\n        actions={[\n          {\n            text: 'Open anyway',\n            title: 'Open the document in text mode. This may freeze or crash your browser.',\n            onClick: handleAcceptTooLarge\n          },\n          {\n            text: 'Open in tree mode',\n            title: 'Open the document in tree mode. Tree mode can handle large documents.',\n            onClick: handleSwitchToTreeMode\n          },\n          {\n            text: 'Cancel',\n            title: 'Cancel opening this large document.',\n            onClick: cancelLoadTooLarge\n          }\n        ]}\n        onClose={focus}\n      />\n\n      <div class=\"jse-contents jse-preview\">\n        {truncate(text || '', MAX_CHARACTERS_TEXT_PREVIEW)}\n      </div>\n    {/if}\n\n    {#if !editorDisabled}\n      {#if statusBar}\n        <StatusBar {editorState} />\n      {/if}\n\n      {#if jsonParseError}\n        <Message\n          type=\"error\"\n          icon={faExclamationTriangle}\n          message={jsonParseError.message}\n          actions={repairActions}\n          onClick={handleShowMe}\n          onClose={focus}\n        />\n      {/if}\n\n      {#if !jsonParseError && askToFormatApplied && needsFormatting(text)}\n        <Message\n          type=\"success\"\n          message=\"Do you want to format the JSON?\"\n          actions={[\n            {\n              icon: faJSONEditorFormat,\n              text: 'Format',\n              title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n              onClick: handleFormat\n            },\n            {\n              icon: faTimes,\n              text: 'No thanks',\n              title: 'Close this message',\n              onClick: () => (askToFormatApplied = false)\n            }\n          ]}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./TextMode.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { MenuItem, OnRenderMenuInternal } from '$lib/types'\n  import Menu from '../../../controls/Menu.svelte'\n  import {\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import type { HistoryState } from '$lib/logic/history'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n\n  export let containsValidArray: boolean\n  export let readOnly: boolean\n  export let showSearch = false\n  export let historyState: HistoryState\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faSearch,\n          title: 'Search (Ctrl+F)',\n          className: 'jse-search',\n          onClick: handleToggleSearch,\n          disabled: !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !historyState.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !historyState.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        {\n          type: 'space'\n        }\n      ]\n\n  let items: MenuItem[]\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { MAX_INLINE_OBJECT_CHARS } from '$lib/constants.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let parser: JSONParser\n  export let isSelected: boolean\n  export let containsSearchResult: boolean\n  export let containsActiveSearchResult: boolean\n  export let onEdit: (path: JSONPath) => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-inline-value\"\n  class:jse-selected={isSelected}\n  class:jse-highlight={containsSearchResult}\n  class:jse-active={containsActiveSearchResult}\n  on:dblclick={() => onEdit(path)}\n>\n  {truncate(parser.stringify(value) ?? '', MAX_INLINE_OBJECT_CHARS)}\n</button>\n\n<style src=\"./InlineValue.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { SortedColumn } from '$lib/types.js'\n  import { SortDirection } from '$lib/types.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretDown, faCaretUp } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty, isEqual } from 'lodash-es'\n  import { MAX_HEADER_NAME_CHARACTERS, SORT_DIRECTION_NAMES } from '$lib/constants.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let path: JSONPath\n  export let sortedColumn: SortedColumn | undefined\n  export let readOnly: boolean\n  export let onSort: (sortedColumn: SortedColumn) => void\n\n  // TODO: improve truncating of long column names when they are a deeply nested path: the last item from the path should be visible, and halfway the path is least interesting\n  $: columnName = !isEmpty(path) ? stringifyJSONPath(path) : 'values'\n\n  $: sortDirection =\n    sortedColumn && isEqual(path, sortedColumn?.path) ? sortedColumn.sortDirection : undefined\n  $: sortDirectionName = sortDirection ? SORT_DIRECTION_NAMES[sortDirection] : undefined\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    onSort({\n      path,\n      sortDirection: sortDirection === SortDirection.asc ? SortDirection.desc : SortDirection.asc\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  on:click={handleSort}\n  title={!readOnly ? columnName + ' (Click to sort the data by this column)' : columnName}\n>\n  <span class=\"jse-column-name\">\n    {truncate(columnName, MAX_HEADER_NAME_CHARACTERS)}\n  </span>\n  {#if sortDirection !== undefined}\n    <span class=\"jse-column-sort-icon\" title={`Currently sorted in ${sortDirectionName} order`}>\n      <Icon data={sortDirection === SortDirection.asc ? faCaretDown : faCaretUp} />\n    </span>\n  {/if}\n</button>\n\n<style src=\"./ColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\n  import type { JSONParser, OnChangeMode } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import { valueType } from '$lib/utils/typeUtils.js'\n  import { findNestedArrays } from '$lib/logic/table.js'\n  import { isEmpty } from 'lodash-es'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n\n  export let text: string | undefined\n  export let json: unknown | undefined\n  export let readOnly: boolean\n  export let parser: JSONParser\n  export let openJSONEditorModal: (path: JSONPath) => void\n  export let onChangeMode: OnChangeMode\n  export let onClick: () => void\n\n  $: action = readOnly ? 'View' : 'Edit'\n\n  let nestedArrayPaths: JSONPath[]\n  $: nestedArrayPaths = json\n    ? findNestedArrays(json)\n        .slice(0, 99)\n        .filter((path) => path.length > 0)\n    : []\n  $: hasNestedArrays = !isEmpty(nestedArrayPaths)\n  $: isEmptyDocument = json === undefined && (text === '' || text === undefined)\n\n  $: documentType = hasNestedArrays\n    ? 'Object with nested arrays'\n    : isEmptyDocument\n      ? 'An empty document'\n      : isJSONObject(json)\n        ? 'An object'\n        : isJSONArray(json)\n          ? 'An empty array' // note: can also be an array with objects but without properties\n          : `A ${valueType(json, parser)}`\n\n  function countItems(nestedArrayPath: JSONPath): number {\n    return (getIn(json, nestedArrayPath) as JSONPath).length\n  }\n</script>\n\n<div class=\"jse-table-mode-welcome\" on:click={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n\n  <div class=\"jse-nested-arrays\">\n    <div class=\"jse-nested-arrays-title\">{documentType}</div>\n    <div class=\"jse-nested-arrays-info\">\n      {#if hasNestedArrays}\n        An object cannot be opened in table mode. You can open a nested array instead, or open the\n        document in tree mode.\n      {:else}\n        {documentType} cannot be opened in table mode.\n      {/if}\n      {#if isEmptyDocument && !readOnly}\n        You can open the document in tree mode instead, or paste a JSON Array using <b>Ctrl+V</b>.\n      {:else}\n        You can open the document in tree mode instead.\n      {/if}\n    </div>\n    {#each nestedArrayPaths as nestedArrayPath}\n      {@const count = countItems(nestedArrayPath)}\n\n      <button\n        type=\"button\"\n        class=\"jse-nested-array-action\"\n        on:click={() => openJSONEditorModal(nestedArrayPath)}\n      >\n        {action} \"{stringifyJSONPath(nestedArrayPath)}\"\n        <span class=\"jse-nested-array-count\">({count} {count !== 1 ? 'items' : 'item'})</span>\n      </button>\n    {/each}\n    <button type=\"button\" class=\"jse-nested-array-action\" on:click={() => onChangeMode(Mode.tree)}>\n      {action} in tree mode\n    </button>\n  </div>\n\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./TableModeWelcome.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faRotate } from '@fortawesome/free-solid-svg-icons'\n\n  export let count: number\n  export let maxSampleCount: number\n  export let readOnly: boolean\n  export let onRefresh: () => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  title={`The Columns are created by sampling ${maxSampleCount} items out of ${count}. ` +\n    \"If you're missing a column, click here to sample all of the items instead of a subset. \" +\n    'This is slower.'}\n  on:click={() => onRefresh()}\n>\n  <Icon data={faRotate} />\n</button>\n\n<style src=\"./RefreshColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    DocumentState,\n    HistoryItem,\n    JSONEditorContext,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    ParseError,\n    PastedJson,\n    SearchResults,\n    SearchResultDetails,\n    SortedColumn,\n    TransformModalOptions,\n    ValidationError,\n    Validator,\n    ValueNormalization,\n    JSONRepairModalProps\n  } from '$lib/types'\n  import { Mode, SortDirection, ValidationSeverity } from '$lib/types.js'\n  import TableMenu from './menu/TableMenu.svelte'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    isJSONArray,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import {\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '../../../utils/jsonUtils.js'\n  import {\n    calculateAbsolutePosition,\n    calculateVisibleSection,\n    clearSortedColumnWhenAffectedByOperations,\n    getColumns,\n    groupValidationErrors,\n    maintainColumnOrder,\n    mergeValidationErrors,\n    selectNextColumn,\n    selectNextRow,\n    selectPreviousColumn,\n    selectPreviousRow,\n    toTableCellPosition\n  } from '$lib/logic/table.js'\n  import { isEmpty, isEqual, uniqueId } from 'lodash-es'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getDataPathFromTarget,\n    getWindow,\n    isChildOf\n  } from '$lib/utils/domUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    createDocumentState,\n    documentStatePatch,\n    getEnforceString,\n    getInRecursiveState,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import InlineValue from './tag/InlineValue.svelte'\n  import {\n    createNestedValueOperations,\n    revertJSONPatchWithMoveOperations\n  } from '$lib/logic/operations.js'\n  import {\n    createValueSelection,\n    getAnchorPath,\n    getFocusPath,\n    isEditingSelection,\n    isJSONSelection,\n    isValueSelection,\n    pathInSelection,\n    pathStartsWith,\n    removeEditModeFromSelection\n  } from '$lib/logic/selection.js'\n  import { createHistory } from '$lib/logic/history.js'\n  import ColumnHeader from './ColumnHeader.svelte'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createFocusTracker } from '$lib/components/controls/createFocusTracker.js'\n  import { getContext, onDestroy, onMount, tick } from 'svelte'\n  import { jsonrepair } from 'jsonrepair'\n  import Message from '../../controls/Message.svelte'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import memoizeOne from 'memoize-one'\n  import { validateJSON } from '$lib/logic/validation.js'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import { noop } from '$lib/utils/noop.js'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import ValidationErrorIcon from '../treemode/ValidationErrorIcon.svelte'\n  import {\n    onCopy,\n    onCut,\n    onDuplicateRow,\n    onInsertAfterRow,\n    onInsertBeforeRow,\n    onInsertCharacter,\n    onPaste,\n    onRemove,\n    onRemoveRow\n  } from '$lib/logic/actions.js'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import { resizeObserver } from '$lib/actions/resizeObserver.js'\n  import CopyPasteModal from '../../../components/modals/CopyPasteModal.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import TableModeWelcome from './TableModeWelcome.svelte'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import RefreshColumnHeader from './RefreshColumnHeader.svelte'\n  import createTableContextMenuItems from './contextmenu/createTableContextMenuItems'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import { flattenSearchResults, toRecursiveSearchResults } from '$lib/logic/search.js'\n  import JSONValue from '../treemode/JSONValue.svelte'\n\n  const debug = createDebug('jsoneditor:TableMode')\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n  const jump = createJump()\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let mainMenuBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let indentation: number | string\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let refJsonEditor: HTMLDivElement\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    const offset = showSearch ? SEARCH_BOX_HEIGHT : -SEARCH_BOX_HEIGHT\n    refContents.scrollTo({\n      top: (refContents.scrollTop += offset),\n      left: refContents.scrollLeft\n    })\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath) {\n    selection = undefined // navigation path of current selection would be confusing\n    await scrollTo(path)\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  $: applyExternalContent(externalContent)\n  $: applyExternalSelection(externalSelection)\n\n  let maxSampleCount = 10_000\n  let columns: JSONPath[] = []\n  $: columns = isJSONArray(json)\n    ? maintainColumnOrder(getColumns(json, flattenColumns, maxSampleCount), columns)\n    : []\n\n  let containsValidArray: boolean\n  $: containsValidArray = !!(json && !isEmpty(columns))\n  $: showRefreshButton = Array.isArray(json) && json.length > maxSampleCount\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  let hasFocus = false\n  let copyPasteModalOpen = false\n\n  let itemHeightsCache: Record<number, number> = {}\n\n  let viewPortHeight = 600\n  let scrollTop = 0\n  let defaultItemHeight = 18 // px\n\n  $: visibleSection = calculateVisibleSection(\n    scrollTop,\n    viewPortHeight,\n    json,\n    itemHeightsCache, // warning: itemHeightsCache is mutated and is not responsive itself\n    defaultItemHeight,\n    showSearch ? SEARCH_BOX_HEIGHT : 0\n  )\n\n  $: refreshScrollTop(json)\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function refreshScrollTop(_json: unknown | undefined) {\n    // When the contents go from lots of items and scrollable contents to only a few items and\n    // no vertical scroll, the actual scrollTop changes to 0 but there is no on:scroll event\n    // triggered, so the internal scrollTop variable is not up-to-date.\n    // This is a workaround to update the scrollTop by triggering an on:scroll event\n    if (refContents) {\n      refContents.scrollTo({\n        top: refContents.scrollTop,\n        left: refContents.scrollLeft\n      })\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  $: emitOnSelect(selection)\n\n  function clearSelectionWhenNotExisting(json: unknown | undefined) {\n    if (!selection || json === undefined) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = undefined // TODO: try find the closest cell that still exists (similar to getInitialSelection)\n  }\n\n  let documentState: DocumentState | undefined =\n    json !== undefined ? createDocumentState({ json }) : undefined\n  let selection: JSONSelection | undefined\n  let sortedColumn: SortedColumn | undefined\n  let textIsRepaired = false\n\n  function onSortByHeader(newSortedColumn: SortedColumn) {\n    if (readOnly) {\n      return\n    }\n\n    debug('onSortByHeader', newSortedColumn)\n\n    const rootPath: JSONPath = []\n    const direction = newSortedColumn.sortDirection === SortDirection.desc ? -1 : 1\n    const operations = sortJson(json, rootPath, newSortedColumn.path, direction)\n    handlePatch(operations, (_, patchedState) => {\n      return {\n        state: patchedState,\n        sortedColumn: newSortedColumn\n      }\n    })\n  }\n\n  const history = createHistory<HistoryItem>({\n    onChange: (state) => {\n      historyState = state\n    }\n  })\n  let historyState = history.getState()\n\n  let context: JSONEditorContext\n  $: context = {\n    mode: Mode.table,\n    readOnly,\n    parser,\n    normalization,\n    getJson: () => json,\n    getDocumentState: () => documentState,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: (operations, afterPatch) => {\n      // When having flattened table columns and having inserted a new row, it is possible that\n      // we edit a nested value of which the parent object is not existing. Therefore, we call\n      // replaceNestedValue to create the parent object(s) first.\n      return handlePatch(createNestedValueOperations(operations, json), afterPatch)\n    },\n    onSelect: handleSelect,\n    onFind: openFind,\n    onPasteJson: handlePasteJson,\n    onRenderValue\n  }\n\n  function applyExternalContent(content: Content) {\n    const currentContent = { json }\n    const isChanged = isTextContent(content)\n      ? content.text !== text\n      : !isEqual(currentContent.json, content.json)\n\n    debug('update external content', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    if (isTextContent(content)) {\n      try {\n        json = parseMemoizeOne(content.text)\n        documentState = syncDocumentState(json, documentState)\n        text = content.text\n        textIsRepaired = false\n        parseError = undefined\n      } catch (err) {\n        try {\n          json = parseMemoizeOne(jsonrepair(content.text))\n          documentState = syncDocumentState(json, documentState)\n          text = content.text\n          textIsRepaired = true\n          parseError = undefined\n        } catch {\n          // no valid JSON, will show empty document or invalid json\n          json = undefined\n          documentState = undefined\n          text = content.text\n          textIsRepaired = false\n          parseError =\n            text !== ''\n              ? normalizeJsonParseError(text, (err as Error).message || String(err))\n              : undefined\n        }\n      }\n    } else {\n      json = content.json\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    }\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    // reset the sorting order (we don't know...)\n    sortedColumn = undefined\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n    sortedColumn: SortedColumn | undefined\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: previous.sortedColumn\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn\n      }\n    })\n  }\n\n  let validationErrors: ValidationError[] = []\n  $: updateValidationErrors(json, validator, parser, validationParser)\n  $: groupedValidationErrors = groupValidationErrors(validationErrors, columns)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrors: ValidationError[]\n        try {\n          newValidationErrors = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrors = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrors, validationErrors)) {\n          debug('validationErrors changed:', newValidationErrors)\n          validationErrors = newValidationErrors\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState: PreviousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      sortedColumn,\n      textIsRepaired\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // Clear the sorted column when needed. We need to do this before `afterPatch`,\n    // else we clear any changed made in the callback. It is a bit odd that\n    // afterPatch does not receive the actual previousDocumentState. Better ideas?\n    const patchedSortedColumn = clearSortedColumnWhenAffectedByOperations(\n      sortedColumn,\n      operations,\n      columns\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn =\n      callback?.sortedColumn !== undefined ? callback.sortedColumn : patchedSortedColumn\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    history.add({\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed: we use patch to reconstruct the json\n        text: undefined,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (onChange) {\n      if (text !== undefined) {\n        const content = { text, json: undefined }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      } else if (json !== undefined) {\n        const content = { text: undefined, json }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      }\n    }\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection {\n    const index = parseInt(path[0], 10)\n    const nextPath = [String(index + 1), ...path.slice(1)]\n\n    return existsIn(json, nextPath) ? createValueSelection(nextPath) : createValueSelection(path)\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function handleScroll(event: Event) {\n    scrollTop = (event.target as HTMLElement)['scrollTop']\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    const target = event.target as HTMLElement\n    if (!target.isContentEditable) {\n      focus()\n    }\n\n    const path = getDataPathFromTarget(target)\n    if (path) {\n      // when clicking inside the current selection, editing a value, do nothing\n      if (isEditingSelection(selection) && pathInSelection(json, selection, path)) {\n        return\n      }\n\n      selection = createValueSelection(path)\n\n      event.preventDefault()\n    }\n  }\n\n  function createDefaultSelection(): JSONSelection | undefined {\n    if (isJSONArray(json) && !isEmpty(json) && !isEmpty(columns)) {\n      // Select the first row, first column\n      const path = ['0', ...columns[0]]\n\n      return createValueSelection(path)\n    } else {\n      return undefined\n    }\n  }\n\n  function createDefaultSelectionWhenUndefined() {\n    if (!selection) {\n      selection = createDefaultSelection()\n    }\n  }\n\n  export function acceptAutoRepair() {\n    if (textIsRepaired && json !== undefined) {\n      const previousContent = { json, text }\n      const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n      // json stays as is\n      text = undefined\n      textIsRepaired = false\n\n      clearSelectionWhenNotExisting(json)\n\n      addHistoryItem(previousState)\n\n      // we could work out a patchResult, or use patch(), but only when the previous and new\n      // contents are both json and not text. We go for simplicity and consistency here and\n      // do _not_ return a patchResult ever.\n      const patchResult = undefined\n\n      emitOnChange(previousContent, patchResult)\n    }\n\n    return { json, text }\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export function scrollTo(path: JSONPath, scrollToWhenVisible = true): Promise<void> {\n    const searchBoxHeight = showSearch ? SEARCH_BOX_HEIGHT : 0\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const roughDistance = top - scrollTop + searchBoxHeight + defaultItemHeight\n    const elem = findElement(path)\n\n    debug('scrollTo', { path, top, scrollTop, elem })\n\n    if (!refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    if (elem && !scrollToWhenVisible) {\n      const elemRect = elem.getBoundingClientRect()\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -Math.max(searchBoxHeight + 2 * defaultItemHeight, viewPortRect.height / 4)\n\n    if (elem) {\n      return new Promise((resolve) => {\n        jump(elem, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: () => {\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    } else {\n      return new Promise((resolve) => {\n        jump(roughDistance, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: async () => {\n            // ensure the element is rendered now that it is scrolled into view\n            await tick()\n\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    }\n  }\n\n  function scrollToVertical(path: JSONPath) {\n    if (!refContents) {\n      return\n    }\n\n    const { rowIndex } = toTableCellPosition(path, columns)\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const bottom = top + (itemHeightsCache[rowIndex] || defaultItemHeight)\n\n    const headerHeight = defaultItemHeight\n    const viewPortRect = refContents.getBoundingClientRect()\n    const viewPortTop = scrollTop\n    const viewPortBottom = scrollTop + viewPortRect.height - headerHeight\n\n    if (bottom > viewPortBottom) {\n      const diff = bottom - viewPortBottom\n      refContents.scrollTop += diff\n    }\n\n    if (top < viewPortTop) {\n      const diff = viewPortTop - top\n      refContents.scrollTop -= diff\n    }\n  }\n\n  function scrollToHorizontal(path: JSONPath) {\n    const elem = findElement(path)\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect() // TODO: scroll to column instead of item (is always rendered)\n\n    if (elemRect.right > viewPortRect.right) {\n      const diff = elemRect.right - viewPortRect.right\n      refContents.scrollLeft += diff\n    }\n\n    if (elemRect.left < viewPortRect.left) {\n      const diff = viewPortRect.left - elemRect.left\n      refContents.scrollLeft -= diff\n    }\n  }\n\n  function scrollIntoView(path: JSONPath) {\n    scrollToVertical(path)\n    scrollToHorizontal(path)\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    const column = columns.find((c) => pathStartsWith(path.slice(1), c))\n\n    const resolvedPath = column ? path.slice(0, 1).concat(column) : path\n\n    return (\n      refContents?.querySelector(`td[data-path=\"${encodeDataPath(resolvedPath)}\"]`) ?? undefined\n    )\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTableContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditValue: handleEditValue,\n      onEditRow: handleEditRow,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicateRow: handleDuplicateRow,\n      onInsertBeforeRow: handleInsertBeforeRow,\n      onInsertAfterRow: handleInsertAfterRow,\n      onRemoveRow: handleRemoveRow\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: function () {\n        closeAbsolutePopup(popupId)\n        focus()\n      }\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-table-cell.jse-selected-value')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTableMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path)\n    } else {\n      selection = createValueSelection(path)\n    }\n  }\n\n  function handleEditRow() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pathRow = path.slice(0, 1)\n    openJSONEditorModal(pathRow)\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = selection.path\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  function handlePasteFromMenu() {\n    copyPasteModalOpen = true\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  async function handleCut(indent: boolean) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: true,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleDuplicateRow() {\n    onDuplicateRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertBeforeRow() {\n    onInsertBeforeRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertAfterRow() {\n    onInsertAfterRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleRemoveRow() {\n    onRemoveRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: false,\n      json,\n      selection: selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      // handleDuplicate()\n      // TODO: implement duplicate\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      // TODO: implement insert\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      // selection = selectAll()\n      // TODO: implement select all\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowLeft') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowRight') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowUp') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousRow(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowDown') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextRow(json, columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'Enter' && selection) {\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const path = selection.path\n        const value = getIn(json, path)\n        if (isObjectOrArray(value)) {\n          // edit nested object/array\n          openJSONEditorModal(path)\n        } else {\n          if (!readOnly) {\n            // go to value edit mode\n            selection = { ...selection, edit: true }\n          }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n\n      handleRedo()\n    }\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain') as string | undefined\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection: selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    const updatedState = syncDocumentState(updatedJson, documentState)\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn = undefined // we can't know whether the new json is still sorted or not\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n\n    scrollTo(error.path)\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: ({ operations, itemPath, direction }) => {\n        debug('onSort', operations, rootPath, itemPath, direction)\n\n        handlePatch(operations, (_, patchedState) => {\n          return {\n            state: patchedState,\n            sortedColumn: {\n              path: itemPath,\n              sortDirection: direction === -1 ? SortDirection.desc : SortDirection.asc\n            }\n          }\n        })\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath: rootPath || [],\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json: json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations)\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath) {\n    debug('openJSONEditorModal', { path })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: getIn(json, path)\n      },\n      path,\n      onPatch: handlePatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    tick().then(() => {\n      // trick to make sure the focus goes to the search box\n      showSearch = true\n      showReplace = findAndReplace\n    })\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.getState().canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!item) {\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    sortedColumn = item.undo.sortedColumn\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.getState().canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!item) {\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    sortedColumn = item.redo.sortedColumn\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleResizeContents(element: Element) {\n    viewPortHeight = element.getBoundingClientRect().height\n  }\n\n  function handleResizeRow(element: Element, rowIndex: number) {\n    itemHeightsCache[rowIndex] = element.getBoundingClientRect().height\n  }\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n<div\n  role=\"table\"\n  class=\"jse-table-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:mousedown={handleMouseDown}\n  on:keydown={handleKeyDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TableMenu\n      {containsValidArray}\n      {readOnly}\n      bind:showSearch\n      {historyState}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onContextMenu={handleContextMenuFromTableMenu}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if containsValidArray}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          {columns}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div\n        class=\"jse-contents\"\n        bind:this={refContents}\n        use:resizeObserver={handleResizeContents}\n        on:scroll={handleScroll}\n      >\n        <table class=\"jse-table-main\">\n          <tbody>\n            <tr class=\"jse-table-row jse-table-row-header\">\n              <th class=\"jse-table-cell jse-table-cell-header\">\n                {#if !isEmpty(groupedValidationErrors?.root)}\n                  {@const validationError = mergeValidationErrors(\n                    [],\n                    groupedValidationErrors?.root\n                  )}\n                  {#if validationError}\n                    <div class=\"jse-table-root-error\">\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    </div>\n                  {/if}\n                {/if}\n              </th>\n              {#each columns as column}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <ColumnHeader path={column} {sortedColumn} {readOnly} onSort={onSortByHeader} />\n                </th>\n              {/each}\n              {#if showRefreshButton}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <RefreshColumnHeader\n                    count={Array.isArray(json) ? json.length : 0}\n                    {maxSampleCount}\n                    {readOnly}\n                    onRefresh={() => (maxSampleCount = Infinity)}\n                  />\n                </th>\n              {/if}\n            </tr>\n            <tr\n              class=\"jse-table-invisible-start-section\"\n              class:jse-search-box-background={showSearch}\n            >\n              <td style:height={visibleSection.startHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n            {#each visibleSection.visibleItems as item, visibleIndex}\n              {@const rowIndex = visibleSection.startIndex + visibleIndex}\n              {@const validationErrorsByRow = groupedValidationErrors.rows[rowIndex]}\n              {@const validationError = mergeValidationErrors(\n                [String(rowIndex)],\n                validationErrorsByRow?.row\n              )}\n              {@const searchResultByRow = getInRecursiveState(json, searchResults, [\n                String(rowIndex)\n              ])}\n              <tr class=\"jse-table-row\">\n                {#key rowIndex}\n                  <th\n                    class=\"jse-table-cell jse-table-cell-gutter\"\n                    use:resizeObserver={(element) => handleResizeRow(element, rowIndex)}\n                  >\n                    {rowIndex}\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </th>\n                {/key}\n                {#each columns as column, columnIndex}\n                  {@const path = [String(rowIndex)].concat(column)}\n                  {@const value = getIn(item, column)}\n                  {@const isSelected =\n                    isValueSelection(selection) && pathStartsWith(selection.path, path)}\n                  {@const validationErrorsByColumn = validationErrorsByRow?.columns[columnIndex]}\n                  {@const validationError = mergeValidationErrors(path, validationErrorsByColumn)}\n                  <td class=\"jse-table-cell\" data-path={encodeDataPath(path)}>\n                    <div class=\"jse-value-outer\" class:jse-selected-value={isSelected}>\n                      {#if isObjectOrArray(value)}\n                        {@const searchResultsByCell = flattenSearchResults(\n                          getInRecursiveState(item, searchResultByRow, column)\n                        )}\n\n                        {@const containsActiveSearchResult = searchResultsByCell\n                          ? searchResultsByCell.some((item) => item.active)\n                          : false}\n\n                        <InlineValue\n                          {path}\n                          {value}\n                          {parser}\n                          {isSelected}\n                          containsSearchResult={!isEmpty(searchResultsByCell)}\n                          {containsActiveSearchResult}\n                          onEdit={openJSONEditorModal}\n                        />{:else}\n                        {@const searchResultItemsByCell = getInRecursiveState(\n                          json,\n                          searchResults,\n                          path\n                        )?.searchResults}\n\n                        <JSONValue\n                          {path}\n                          value={value !== undefined ? value : ''}\n                          enforceString={getEnforceString(json, documentState, path)}\n                          selection={isSelected ? selection : undefined}\n                          searchResultItems={searchResultItemsByCell}\n                          {context}\n                        />{/if}{#if !readOnly && isSelected && !isEditingSelection(selection)}\n                        <div class=\"jse-context-menu-anchor\">\n                          <ContextMenuPointer selected={true} onContextMenu={openContextMenu} />\n                        </div>\n                      {/if}\n                    </div>\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </td>\n                {/each}\n                {#if showRefreshButton}\n                  <td class=\"jse-table-cell\"></td>\n                {/if}\n              </tr>\n            {/each}\n\n            <tr class=\"jse-table-invisible-end-section\">\n              <td style:height={visibleSection.endHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Paste the text as JSON instead of a single value',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the pasted content as a single value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {:else if parseError && text !== undefined && text !== ''}\n      <Message\n        type=\"error\"\n        message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n        actions={!readOnly\n          ? [\n              {\n                icon: faCode,\n                text: 'Repair manually',\n                title: 'Open the document in \"code\" mode and repair it manually',\n                onClick: handleRequestRepair\n              }\n            ]\n          : []}\n      />\n      <JSONPreview {text} {json} {indentation} {parser} />\n    {:else}\n      <TableModeWelcome\n        {text}\n        {json}\n        {readOnly}\n        {parser}\n        {openJSONEditorModal}\n        {onChangeMode}\n        onClick={() => {\n          // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n          //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n          focus()\n        }}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents jse-contents-loading\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TableMode.scss\"></style>\n","import type { ContextMenuItem, DocumentState, JSONSelection } from 'svelte-jsoneditor'\nimport {\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCut,\n  faPaste,\n  faPen,\n  faPlus,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection'\nimport { getIn } from 'immutable-json-patch'\nimport { getFocusPath, singleItemSelected } from '$lib/logic/selection'\nimport { isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditValue,\n  onEditRow,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicateRow,\n  onInsertBeforeRow,\n  onInsertAfterRow,\n  onRemoveRow\n}: {\n  json: unknown | undefined\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditValue: () => void\n  onEditRow: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicateRow: () => void\n  onInsertBeforeRow: () => void\n  onInsertAfterRow: () => void\n  onRemoveRow: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const focusValue =\n    json !== undefined && selection ? getIn(json, getFocusPath(selection)) : undefined\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  return [\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table cell:' },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onEditValue(),\n                icon: faPen,\n                text: 'Edit',\n                title: 'Edit the value (Double-click on the value)',\n                disabled: !canEditValue\n              },\n              width: '11em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faPen,\n                  text: 'Edit',\n                  title: 'Edit the value (Double-click on the value)',\n                  onClick: () => onEditValue(),\n                  disabled: !canEditValue\n                },\n                {\n                  type: 'button',\n                  icon: enforceString ? faCheckSquare : faSquare,\n                  text: 'Enforce string',\n                  title: 'Enforce keeping the value as string when it contains a numeric value',\n                  onClick: () => onToggleEnforceString(),\n                  disabled: !canEnforceString\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCut(true),\n                icon: faCut,\n                text: 'Cut',\n                title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                disabled: !canCut\n              },\n              width: '10em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut formatted',\n                  title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                  onClick: () => onCut(true),\n                  disabled: readOnly || !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut compacted',\n                  title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n                  onClick: () => onCut(false),\n                  disabled: readOnly || !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCopy(true),\n                icon: faCopy,\n                text: 'Copy',\n                title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                disabled: !hasSelectionContents\n              },\n              width: '12em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy formatted',\n                  title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy compacted',\n                  title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'button',\n              onClick: () => onPaste(),\n              icon: faPaste,\n              text: 'Paste',\n              title: 'Paste clipboard contents (Ctrl+V)',\n              disabled: readOnly || !hasSelection\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table row:' },\n            {\n              type: 'button',\n              onClick: () => onEditRow(),\n              icon: faPen,\n              text: 'Edit row',\n              title: 'Edit the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onDuplicateRow(),\n              icon: faClone,\n              text: 'Duplicate row',\n              title: 'Duplicate the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertBeforeRow(),\n              icon: faPlus,\n              text: 'Insert before',\n              title: 'Insert a row before the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertAfterRow(),\n              icon: faPlus,\n              text: 'Insert after',\n              title: 'Insert a row after the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onRemoveRow(),\n              icon: faTrashCan,\n              text: 'Remove row',\n              title: 'Remove current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n","<script lang=\"ts\">\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    MenuSeparator,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRenderContextMenu,\n    OnRenderContextMenuInternal,\n    OnRenderMenu,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    TransformModalOptions,\n    Validator\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import TextMode from './textmode/TextMode.svelte'\n  import TableMode from './tablemode/TableMode.svelte'\n  import TreeMode from './treemode/TreeMode.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { isMenuSpace } from '$lib/typeguards.js'\n  import { cloneDeep } from 'lodash-es'\n\n  export let content: Content\n  export let selection: JSONEditorSelection | undefined\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let mode: Mode\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let insideModal: boolean\n\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let refTreeMode: TreeMode | undefined\n  let refTableMode: TableMode | undefined\n  let refTextMode: TextMode | undefined\n\n  let modeMenuItems: MenuItem[]\n  $: modeMenuItems = [\n    {\n      type: 'button',\n      text: 'text',\n      title: `Switch to text mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-first' + (mode === Mode.text ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.text)\n    },\n    {\n      type: 'button',\n      text: 'tree',\n      title: `Switch to tree mode (current mode: ${mode})`,\n      className: 'jse-group-button ' + (mode === Mode.tree ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.tree)\n    },\n    {\n      type: 'button',\n      text: 'table',\n      title: `Switch to table mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-last' + (mode === Mode.table ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.table)\n    }\n  ]\n\n  const separatorMenuItem: MenuSeparator = {\n    type: 'separator'\n  }\n\n  let handleRenderMenu: OnRenderMenuInternal\n  $: handleRenderMenu = (items: MenuItem[]) => {\n    const updatedItems = isMenuSpace(items[0])\n      ? modeMenuItems.concat(items) // menu is empty, readOnly mode\n      : modeMenuItems.concat(separatorMenuItem, items)\n\n    const updatedItemsOriginal = cloneDeep(updatedItems) // the user may change updatedItems in the callback\n\n    return (\n      onRenderMenu(updatedItems, { mode, modal: insideModal, readOnly }) || updatedItemsOriginal\n    )\n  }\n\n  let handleRenderContextMenu: OnRenderContextMenuInternal\n  $: handleRenderContextMenu = (items: ContextMenuItem[]) => {\n    const itemsOriginal = cloneDeep(items) // the user may change items in the callback\n\n    return (\n      onRenderContextMenu(items, { mode, modal: insideModal, readOnly, selection }) ??\n      (readOnly ? false : itemsOriginal)\n    )\n  }\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    if (refTreeMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTreeMode.patch(operations)\n    }\n\n    if (refTableMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTableMode.patch(operations)\n    }\n\n    if (refTextMode) {\n      return refTextMode.patch(operations)\n    }\n\n    throw new Error(`Method patch is not available in mode \"${mode}\"`)\n  }\n\n  export function expand(path: JSONPath, callback?: OnExpand): void {\n    if (refTreeMode) {\n      return refTreeMode.expand(path, callback)\n    } else {\n      throw new Error(`Method expand is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean): void {\n    if (refTreeMode) {\n      return refTreeMode.collapse(path, recursive)\n    } else {\n      throw new Error(`Method collapse is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions): void {\n    if (refTextMode) {\n      refTextMode.openTransformModal(options)\n    } else if (refTreeMode) {\n      refTreeMode.openTransformModal(options)\n    } else if (refTableMode) {\n      refTableMode.openTransformModal(options)\n    } else {\n      throw new Error(`Method transform is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    if (refTextMode) {\n      return refTextMode.validate()\n    } else if (refTreeMode) {\n      return refTreeMode.validate()\n    } else if (refTableMode) {\n      return refTableMode.validate()\n    } else {\n      throw new Error(`Method validate is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export function acceptAutoRepair(): Content {\n    if (refTreeMode) {\n      return refTreeMode.acceptAutoRepair()\n    } else {\n      return content\n    }\n  }\n\n  export function scrollTo(path: JSONPath): Promise<void> {\n    if (refTreeMode) {\n      return refTreeMode.scrollTo(path)\n    } else if (refTableMode) {\n      return refTableMode.scrollTo(path)\n    } else {\n      // TODO: implement scrollTo for text mode\n      throw new Error(`Method scrollTo is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    if (refTreeMode) {\n      return refTreeMode.findElement(path)\n    } else if (refTableMode) {\n      return refTableMode.findElement(path)\n    } else {\n      throw new Error(`Method findElement is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function focus() {\n    if (refTextMode) {\n      refTextMode.focus()\n    } else if (refTreeMode) {\n      refTreeMode.focus()\n    } else if (refTableMode) {\n      refTableMode.focus()\n    }\n  }\n\n  export async function refresh(): Promise<void> {\n    if (refTextMode) {\n      await refTextMode.refresh()\n    } else {\n      // nothing to do in tree or table mode (also: don't throw an exception or so,\n      // that annoying having to reckon with that when using .refresh()).\n    }\n  }\n</script>\n\n{#if mode === Mode.text || String(mode) === 'code'}\n  <TextMode\n    bind:this={refTextMode}\n    externalContent={content}\n    externalSelection={selection}\n    {readOnly}\n    {indentation}\n    {tabSize}\n    {mainMenuBar}\n    {statusBar}\n    {askToFormat}\n    {escapeUnicodeCharacters}\n    {parser}\n    {validator}\n    {validationParser}\n    {onChange}\n    {onSelect}\n    {onChangeMode}\n    {onError}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    {onSortModal}\n    {onTransformModal}\n  />\n{:else if mode === Mode.table}\n  <TableMode\n    bind:this={refTableMode}\n    externalContent={content}\n    externalSelection={selection}\n    {readOnly}\n    {mainMenuBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {flattenColumns}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {indentation}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    {onRenderValue}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{:else}\n  <!-- mode === Mode.tree -->\n  <TreeMode\n    bind:this={refTreeMode}\n    externalContent={content}\n    externalSelection={selection}\n    {readOnly}\n    {indentation}\n    {mainMenuBar}\n    {navigationBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {pathParser}\n    {onError}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    {onRenderValue}\n    {onClassName}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{/if}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount, tick } from 'svelte'\n  import Header from './Header.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, immutableJSONPatch, isJSONArray } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type {\n    Content,\n    JSONEditorModalCallback,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPathParser,\n    OnClassName,\n    OnPatch,\n    OnRenderContextMenu,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSortModal,\n    OnTransformModal,\n    Validator\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import JSONEditorRoot from '../modes/JSONEditorRoot.svelte'\n  import { noop } from '$lib/utils/noop.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { initial, isEmpty, last } from 'lodash-es'\n  import { isJSONContent, toJSONContent } from '$lib/utils/jsonUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretLeft } from '@fortawesome/free-solid-svg-icons'\n  import memoizeOne from 'memoize-one'\n  import { getFocusPath, isJSONSelection } from '$lib/logic/selection.js'\n  import Modal from './Modal.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n\n  const debug = createDebug('jsoneditor:JSONEditorModal')\n\n  export let content: Content // the nested document\n  export let path: JSONPath\n  export let onPatch: OnPatch\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  export let onClose: () => void\n\n  interface ModalState {\n    mode: Mode\n    content: Content\n    selection: JSONEditorSelection | undefined\n    relativePath: JSONPath\n  }\n\n  let refEditor: JSONEditorRoot\n  let fullscreen: boolean\n\n  const rootState: ModalState = {\n    mode: determineMode(content),\n    content,\n    selection: undefined,\n    relativePath: path\n  }\n  let stack: ModalState[] = [rootState]\n\n  $: currentState = last(stack) || rootState\n  $: absolutePath = stack.flatMap((state) => state.relativePath)\n  $: pathDescription = !isEmpty(absolutePath) ? stringifyJSONPath(absolutePath) : '(document root)'\n\n  // not relevant in this Modal setting, but well\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  let error: string | undefined = undefined\n\n  onMount(() => {\n    refEditor?.focus()\n  })\n\n  function determineMode(content: Content): Mode {\n    return isJSONContent(content) && isJSONArray(content.json) ? Mode.table : Mode.tree\n  }\n\n  function scrollToSelection() {\n    const selection: JSONEditorSelection | undefined = last(stack)?.selection\n    if (isJSONSelection(selection)) {\n      refEditor.scrollTo(getFocusPath(selection))\n    }\n  }\n\n  function handleApply() {\n    debug('handleApply')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      error = undefined\n\n      const path = currentState.relativePath\n      const content = currentState.content\n      const operations: JSONPatchDocument = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: toJSONContent(content, parser).json // this can throw an error\n        }\n      ]\n\n      if (stack.length > 1) {\n        const parentContent = stack[stack.length - 2].content\n        const parentJson = toJSONContent(parentContent, parser).json\n        const updatedParentContent = {\n          json: immutableJSONPatch(parentJson, operations)\n        }\n\n        // after successfully updated, remove from the stack and apply the change to the parent\n        const parentState = stack[stack.length - 2] || rootState\n        const updatedParentState: ModalState = { ...parentState, content: updatedParentContent }\n        stack = [...stack.slice(0, stack.length - 2), updatedParentState]\n        tick().then(scrollToSelection)\n      } else {\n        onPatch(operations)\n\n        onClose()\n      }\n    } catch (err) {\n      error = String(err)\n    }\n  }\n\n  function handleClose() {\n    debug('handleClose')\n\n    if (fullscreen) {\n      // exit fullscreen\n      fullscreen = false\n    } else if (stack.length > 1) {\n      // remove the last item from the stack\n      stack = initial(stack)\n      tick().then(() => {\n        refEditor?.focus()\n        scrollToSelection()\n      })\n\n      // clear any error from the just closed state\n      error = undefined\n    } else {\n      // this is the first modal, the root state, close the modal\n      onClose()\n    }\n  }\n\n  function handleChange(updatedContent: Content) {\n    debug('handleChange', updatedContent)\n    updateState((state) => ({ ...state, content: updatedContent }))\n  }\n\n  function handleChangeSelection(newSelection: JSONEditorSelection | undefined) {\n    debug('handleChangeSelection', newSelection)\n    updateState((state) => ({ ...state, selection: newSelection }))\n  }\n\n  function handleChangeMode(newMode: Mode) {\n    debug('handleChangeMode', newMode)\n    updateState((state) => ({ ...state, mode: newMode }))\n  }\n\n  function updateState(callback: (state: ModalState) => ModalState) {\n    const state = last(stack) as ModalState\n    const updatedState = callback(state)\n    stack = [...initial(stack), updatedState]\n  }\n\n  function handleError(newError: Error) {\n    error = newError.toString()\n    console.error(newError)\n  }\n\n  function handleJSONEditorModal({ content, path }: JSONEditorModalCallback) {\n    debug('handleJSONEditorModal', { content, path })\n\n    const nestedModalState = {\n      mode: determineMode(content),\n      content,\n      selection: undefined,\n      relativePath: path\n    }\n    stack = [...stack, nestedModalState]\n\n    tick().then(() => refEditor?.focus())\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal onClose={handleClose} className=\"jse-jsoneditor-modal\" {fullscreen}>\n  <div class=\"jse-modal-wrapper\">\n    <AbsolutePopup>\n      <Header\n        title=\"Edit nested content {stack.length > 1 ? ` (${stack.length})` : ''}\"\n        fullScreenButton={true}\n        bind:fullscreen\n        onClose={handleClose}\n      />\n\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Path</div>\n        </div>\n        <input\n          class=\"jse-path\"\n          type=\"text\"\n          readonly\n          title=\"Selected path\"\n          value={pathDescription}\n        />\n\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Contents</div>\n        </div>\n\n        <div class=\"jse-modal-inline-editor\">\n          <JSONEditorRoot\n            bind:this={refEditor}\n            mode={currentState.mode}\n            content={currentState.content}\n            selection={currentState.selection}\n            {readOnly}\n            {indentation}\n            {tabSize}\n            {statusBar}\n            {askToFormat}\n            {mainMenuBar}\n            {navigationBar}\n            {escapeControlCharacters}\n            {escapeUnicodeCharacters}\n            {flattenColumns}\n            {parser}\n            {parseMemoizeOne}\n            {validator}\n            {validationParser}\n            {pathParser}\n            insideModal={true}\n            onError={handleError}\n            onChange={handleChange}\n            onChangeMode={handleChangeMode}\n            onSelect={handleChangeSelection}\n            {onRenderValue}\n            {onClassName}\n            onFocus={noop}\n            onBlur={noop}\n            {onRenderMenu}\n            {onRenderContextMenu}\n            {onSortModal}\n            {onTransformModal}\n            onJSONEditorModal={handleJSONEditorModal}\n          />\n        </div>\n\n        <div class=\"jse-actions\">\n          {#if error}\n            <div class=\"jse-error\">\n              {error}\n            </div>\n          {/if}\n\n          {#if stack.length > 1}\n            <button type=\"button\" class=\"jse-secondary\" on:click={handleClose}>\n              <Icon data={faCaretLeft} /> Back\n            </button>\n          {/if}\n          {#if !readOnly}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleApply} use:focus>\n              Apply\n            </button>\n          {:else}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleClose}> Close </button>\n          {/if}\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./JSONEditorModal.scss\"></style>\n","import type { NumberOption, PathOption } from '$lib/types.js'\n\nexport interface SortModalState {\n  selectedProperty: PathOption\n  selectedDirection: NumberOption\n}\n\nexport const sortModalStates: Record<string, SortModalState> = {}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isEmpty } from 'lodash-es'\n  import Select from 'svelte-select'\n  import Header from './Header.svelte'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { sortModalStates } from './sortModalStates'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { OnSort } from '$lib/types.js'\n  import Modal from './Modal.svelte'\n\n  const debug = createDebug('jsoneditor:SortModal')\n\n  export let id: string\n  export let json: unknown // the whole document\n  export let rootPath: JSONPath\n  export let onSort: OnSort\n  export let onClose: () => void\n\n  $: selectedJson = getIn(json, rootPath)\n  $: jsonIsArray = Array.isArray(selectedJson)\n  $: paths = jsonIsArray ? getNestedPaths(selectedJson) : undefined\n  $: properties = paths ? paths.map(pathToOption) : undefined\n\n  const asc = {\n    value: 1,\n    label: 'ascending'\n  }\n  const desc = {\n    value: -1,\n    label: 'descending'\n  }\n  const directions = [asc, desc]\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  let selectedProperty = sortModalStates[stateId]?.selectedProperty\n  let selectedDirection = sortModalStates[stateId]?.selectedDirection || asc\n  let sortError: string | undefined = undefined\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    sortModalStates[stateId] = {\n      selectedProperty,\n      selectedDirection\n    }\n\n    debug('store state in memory', stateId, sortModalStates[stateId])\n  }\n\n  function handleSort() {\n    try {\n      sortError = undefined\n\n      const itemPath: JSONPath = selectedProperty?.value || properties?.[0]?.value || []\n      const direction = selectedDirection?.value\n      const operations = sortJson(json, rootPath, itemPath, direction)\n      if (onSort !== undefined && rootPath !== undefined) {\n        onSort({ operations, rootPath, itemPath, direction })\n      }\n\n      onClose()\n    } catch (err) {\n      sortError = String(err)\n    }\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-sort-modal\">\n  <Header title={jsonIsArray ? 'Sort array items' : 'Sort object keys'} {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <table>\n      <colgroup>\n        <col width=\"25%\" />\n        <col width=\"75%\" />\n      </colgroup>\n      <tbody>\n        <tr>\n          <th>Path</th>\n          <td>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={rootPath && !isEmpty(rootPath)\n                ? stringifyJSONPath(rootPath)\n                : '(document root)'}\n            />\n          </td>\n        </tr>\n        {#if jsonIsArray && ((properties && properties?.length > 1) || selectedProperty === undefined)}\n          <tr>\n            <th>Property</th>\n            <td>\n              <Select showChevron items={properties} bind:value={selectedProperty} />\n            </td>\n          </tr>\n        {/if}\n        <tr>\n          <th>Direction</th>\n          <td>\n            <Select\n              showChevron\n              clearable={false}\n              items={directions}\n              bind:value={selectedDirection}\n            />\n          </td>\n        </tr>\n      </tbody>\n    </table>\n\n    <div class=\"jse-space\">\n      {#if sortError}\n        <div class=\"jse-error\">\n          {sortError}\n        </div>\n      {/if}\n    </div>\n\n    <div class=\"jse-actions\">\n      <button\n        type=\"button\"\n        class=\"jse-primary\"\n        on:click={handleSort}\n        use:focus\n        disabled={jsonIsArray && properties && properties?.length > 1 ? !selectedProperty : false}\n      >\n        Sort\n      </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./SortModal.scss\"></style>\n","<svelte:options accessors={false} immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '../utils/debug.js'\n  import { uniqueId } from '../utils/uniqueId.js'\n  import { isEqualParser, isJSONContent, validateContentType } from '../utils/jsonUtils.js'\n  import AbsolutePopup from './modals/popup/AbsolutePopup.svelte'\n  import { jsonQueryLanguage } from '$lib/plugins/query/jsonQueryLanguage.js'\n  import { renderValue } from '$lib/plugins/value/renderValue.js'\n  import { tick } from 'svelte'\n  import TransformModal from './modals/TransformModal.svelte'\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    JSONEditorModalCallback,\n    JSONEditorModalProps,\n    JSONEditorPropsOptional,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnChangeQueryLanguage,\n    OnChangeStatus,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSelect,\n    QueryLanguage,\n    SortModalCallback,\n    TransformModalCallback,\n    TransformModalOptions,\n    TransformModalProps,\n    Validator\n  } from '$lib/types'\n  import type { OnRenderContextMenu } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { noop } from '../utils/noop.js'\n  import { parseJSONPath, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import JSONEditorRoot from './modes/JSONEditorRoot.svelte'\n  import JSONEditorModal from './modals/JSONEditorModal.svelte'\n  import memoizeOne from 'memoize-one'\n  import { cloneDeep } from 'lodash-es'\n  import SortModal from './modals/SortModal.svelte'\n\n  // TODO: document how to enable debugging in the readme: localStorage.debug=\"jsoneditor:*\", then reload\n  const debug = createDebug('jsoneditor:JSONEditor')\n\n  export let content: Content = { text: '' }\n  export let selection: JSONEditorSelection | undefined = undefined\n\n  export let readOnly = false\n  export let indentation: number | string = 2\n  export let tabSize = 4\n  export let mode: Mode = Mode.tree\n  export let mainMenuBar = true\n  export let navigationBar = true\n  export let statusBar = true\n  export let askToFormat = true\n  export let escapeControlCharacters = false\n  export let escapeUnicodeCharacters = false\n  export let flattenColumns = true\n  export let parser: JSONParser = JSON\n  export let validator: Validator | undefined = undefined\n  export let validationParser: JSONParser = JSON\n  export let pathParser: JSONPathParser = {\n    parse: parseJSONPath,\n    stringify: stringifyJSONPath\n  }\n\n  export let queryLanguages: QueryLanguage[] = [jsonQueryLanguage]\n  export let queryLanguageId: string = queryLanguages[0].id\n\n  export let onChangeQueryLanguage: OnChangeQueryLanguage = noop\n  export let onChange: OnChange | undefined = undefined\n  export let onSelect: OnSelect | undefined = undefined\n  export let onRenderValue: OnRenderValue = renderValue\n  export let onClassName: OnClassName = () => undefined\n  export let onRenderMenu: OnRenderMenu = noop\n  export let onRenderContextMenu: OnRenderContextMenu = noop\n  export let onChangeMode: OnChangeMode = noop\n  export let onError: OnError = (err) => {\n    console.error(err)\n    alert(err.toString()) // TODO: create a nice alert modal\n  }\n  export let onFocus: OnFocus = noop\n  export let onBlur: OnBlur = noop\n\n  let instanceId = uniqueId()\n  let hasFocus = false\n  let refJSONEditorRoot: JSONEditorRoot\n  let jsonEditorModalProps: JSONEditorModalProps | undefined = undefined\n  let sortModalProps: SortModalCallback | undefined\n  let transformModalProps: TransformModalProps | undefined\n\n  $: {\n    const contentError = validateContentType(content)\n    if (contentError) {\n      console.error('Error: ' + contentError)\n    }\n  }\n\n  // backward compatibility warning since v1.0.0\n  $: if (selection === null) {\n    console.warn('selection is invalid: it is null but should be undefined')\n  }\n\n  // We memoize the last parse result for the case when the content is text and very large.\n  // In that case parsing takes a few seconds. When the user switches between tree and table mode,\n  // without having made a change, we do not want to parse the text again.\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  // rerender the full editor when the parser changes. This is needed because\n  // numeric state is hold at many places in the editor.\n  let previousParser = parser\n  $: {\n    if (!isEqualParser(parser, previousParser)) {\n      debug('parser changed, recreate editor')\n\n      if (isJSONContent(content)) {\n        const text = previousParser.stringify(content.json)\n        content = {\n          json: text !== undefined ? parser.parse(text) : undefined\n        }\n      }\n\n      previousParser = parser\n\n      // new editor id -> will re-create the editor\n      instanceId = uniqueId()\n    }\n  }\n\n  export function get(): Content {\n    return content\n  }\n\n  export async function set(newContent: Content): Promise<void> {\n    debug('set')\n\n    const contentError = validateContentType(newContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    // new editor id -> will re-create the editor\n    instanceId = uniqueId()\n\n    // update content *after* re-render, so that the new editor will trigger an onChange event\n    content = newContent\n  }\n\n  export async function update(updatedContent: Content): Promise<void> {\n    debug('update')\n\n    const contentError = validateContentType(updatedContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    content = updatedContent\n\n    await tick() // await rerender\n  }\n\n  export async function patch(operations: JSONPatchDocument): Promise<JSONPatchResult> {\n    // Note that patch has an optional afterPatch callback.\n    // right now we don's support this in the public API.\n    const result = refJSONEditorRoot.patch(operations)\n\n    await tick() // await rerender\n\n    return result\n  }\n\n  export async function select(newSelection: JSONEditorSelection | undefined) {\n    selection = newSelection\n\n    await tick() // await rerender\n  }\n\n  export async function expand(path: JSONPath, callback?: OnExpand): Promise<void> {\n    refJSONEditorRoot.expand(path, callback)\n\n    await tick() // await rerender\n  }\n\n  export async function collapse(path: JSONPath, recursive = false): Promise<void> {\n    refJSONEditorRoot.collapse(path, recursive)\n\n    await tick() // await rerender\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions): void {\n    refJSONEditorRoot.transform(options)\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    return refJSONEditorRoot.validate()\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export async function acceptAutoRepair(): Promise<Content> {\n    const content = refJSONEditorRoot.acceptAutoRepair()\n\n    await tick() // await rerender\n\n    return content\n  }\n\n  export async function scrollTo(path: JSONPath): Promise<void> {\n    await refJSONEditorRoot.scrollTo(path)\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    return refJSONEditorRoot.findElement(path)\n  }\n\n  export async function focus(): Promise<void> {\n    refJSONEditorRoot.focus()\n\n    await tick() // await rerender\n  }\n\n  export async function refresh(): Promise<void> {\n    await refJSONEditorRoot.refresh()\n  }\n\n  export async function updateProps(props: JSONEditorPropsOptional): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.$set(props)\n\n    await tick() // await rerender\n  }\n\n  export async function destroy() {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.$destroy()\n\n    await tick() // await destroying\n  }\n\n  function handleChange(updatedContent: Content, previousContent: Content, status: OnChangeStatus) {\n    content = updatedContent\n\n    if (onChange) {\n      onChange(updatedContent, previousContent, status)\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONEditorSelection | undefined) {\n    selection = updatedSelection\n\n    if (onSelect) {\n      onSelect(cloneDeep(updatedSelection))\n    }\n  }\n\n  function handleFocus() {\n    hasFocus = true\n    if (onFocus) {\n      onFocus()\n    }\n  }\n\n  function handleBlur() {\n    hasFocus = false\n    if (onBlur) {\n      onBlur()\n    }\n  }\n\n  async function toggleMode(newMode: Mode) {\n    if (mode === newMode) {\n      return\n    }\n\n    mode = newMode\n\n    await tick()\n    await focus()\n\n    onChangeMode(newMode)\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n\n  // The onTransformModal method is located in JSONEditor to prevent circular references:\n  //     TreeMode -> TransformModal -> TreeMode\n  function onTransformModal({ id, json, rootPath, onTransform, onClose }: TransformModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    transformModalProps = {\n      id,\n      json,\n      rootPath,\n      indentation,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      parser,\n      parseMemoizeOne,\n      validationParser,\n      pathParser,\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: handleChangeQueryLanguage,\n      onRenderValue,\n      onRenderMenu: (items: MenuItem[]) => onRenderMenu(items, { mode, modal: true, readOnly }),\n      onRenderContextMenu: (items: ContextMenuItem[]) =>\n        onRenderContextMenu(items, { mode, modal: true, readOnly, selection }),\n      onClassName,\n      onTransform,\n      onClose\n    }\n  }\n\n  // The onSortModal is positioned here for consistency with TransformModal\n  function onSortModal(props: SortModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    sortModalProps = props\n  }\n\n  // The onJSONEditorModal method is located in JSONEditor to prevent circular references:\n  //     JSONEditor -> TableMode -> JSONEditorModal -> JSONEditor\n  function onJSONEditorModal({ content, path, onPatch, onClose }: JSONEditorModalCallback) {\n    debug('onJSONEditorModal', { content, path })\n\n    jsonEditorModalProps = {\n      content,\n      path,\n      onPatch,\n\n      readOnly,\n      indentation,\n      tabSize,\n      mainMenuBar,\n      navigationBar,\n      statusBar,\n      askToFormat,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      flattenColumns,\n      parser,\n      validator: undefined, // TODO: support partial JSON validation?\n      validationParser,\n      pathParser,\n      onRenderValue,\n      onClassName,\n      onRenderMenu,\n      onRenderContextMenu,\n      onSortModal,\n      onTransformModal,\n      onClose\n    }\n  }\n\n  $: debug('mode changed to', mode)\n</script>\n\n<AbsolutePopup>\n  <div class=\"jse-main\" class:jse-focus={hasFocus}>\n    {#key instanceId}\n      <JSONEditorRoot\n        bind:this={refJSONEditorRoot}\n        {mode}\n        {content}\n        {selection}\n        {readOnly}\n        {indentation}\n        {tabSize}\n        {statusBar}\n        {askToFormat}\n        {mainMenuBar}\n        {navigationBar}\n        {escapeControlCharacters}\n        {escapeUnicodeCharacters}\n        {flattenColumns}\n        {parser}\n        {parseMemoizeOne}\n        {validator}\n        {validationParser}\n        {pathParser}\n        insideModal={false}\n        {onError}\n        onChange={handleChange}\n        onChangeMode={toggleMode}\n        onSelect={handleSelect}\n        {onRenderValue}\n        {onClassName}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        {onRenderMenu}\n        {onRenderContextMenu}\n        {onSortModal}\n        {onTransformModal}\n        {onJSONEditorModal}\n      />\n    {/key}\n  </div>\n\n  {#if sortModalProps}\n    <SortModal\n      {...sortModalProps}\n      onClose={() => {\n        sortModalProps?.onClose()\n        sortModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if transformModalProps}\n    <TransformModal\n      {...transformModalProps}\n      onClose={() => {\n        transformModalProps?.onClose()\n        transformModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if jsonEditorModalProps}\n    <JSONEditorModal\n      {...jsonEditorModalProps}\n      onClose={() => {\n        jsonEditorModalProps?.onClose()\n        jsonEditorModalProps = undefined\n      }}\n    />\n  {/if}\n</AbsolutePopup>\n\n<style src=\"./JSONEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import { type JSONParser, type JSONSelection, Mode, type OnPatch } from '$lib/types.js'\n  import { isValueSelection } from '$lib/logic/selection.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let mode: Mode\n  export let parser: JSONParser\n  export let readOnly: boolean\n  export let selection: JSONSelection | undefined\n  export let onPatch: OnPatch\n\n  export let options: Array<{ value: unknown; text: string }>\n\n  let refSelect: HTMLSelectElement | undefined\n\n  let bindValue: unknown = value\n  $: bindValue = value\n\n  function applyFocus(selection: JSONSelection | undefined) {\n    if (selection) {\n      if (refSelect) {\n        refSelect.focus()\n      }\n    }\n  }\n\n  $: applyFocus(selection)\n\n  function handleSelect(event: Event) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: bindValue\n      }\n    ])\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // stop propagation to prevent selecting the whole line\n    event.stopPropagation()\n  }\n</script>\n\n<select\n  class={`jse-enum-value ${getValueClass(bindValue, mode, parser)}`}\n  class:jse-selected={isValueSelection(selection)}\n  bind:value={bindValue}\n  bind:this={refSelect}\n  on:change={handleSelect}\n  on:mousedown={handleMouseDown}\n>\n  {#each options as option}\n    <option value={option.value}>{option.text}</option>\n  {/each}\n</select>\n\n<style src=\"./EnumValue.scss\"></style>\n","import type { JSONPath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, JSONSchemaEnum } from '$lib/types'\n\n/**\n * Find enum options for given path in a JSONSchema\n */\nexport function getJSONSchemaOptions(\n  schema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions | undefined,\n  path: JSONPath\n): JSONSchemaEnum | undefined {\n  const schemaForPath = findSchema(schema, schemaDefinitions || {}, path)\n\n  return schemaForPath ? findEnum(schemaForPath) : undefined\n}\n\n/**\n * find an enum definition in a JSON schema, as property `enum` or inside\n * one of the schemas composites (`oneOf`, `anyOf`, `allOf`)\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findEnum(schema: JSONSchema): JSONSchemaEnum | undefined {\n  if (Array.isArray(schema['enum'])) {\n    return schema['enum']\n  }\n\n  const composite = schema['oneOf'] || schema['anyOf'] || schema['allOf']\n  if (Array.isArray(composite)) {\n    const match = composite.filter((entry) => entry.enum)\n    if (match.length > 0) {\n      return match[0].enum\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Return the part of a JSON schema matching given path.\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findSchema(\n  topLevelSchema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions,\n  path: JSONPath,\n  currentSchema = topLevelSchema\n): JSONSchema | undefined {\n  const nextPath = path.slice(1, path.length)\n  const nextKey = path[0]\n\n  let possibleSchemas = [currentSchema]\n  for (const subSchemas of [currentSchema.oneOf, currentSchema.anyOf, currentSchema.allOf]) {\n    if (Array.isArray(subSchemas)) {\n      possibleSchemas = possibleSchemas.concat(subSchemas)\n    }\n  }\n\n  for (const schema of possibleSchemas) {\n    currentSchema = schema\n\n    if ('$ref' in currentSchema && typeof currentSchema.$ref === 'string') {\n      const ref = currentSchema.$ref\n      if (ref in schemaDefinitions) {\n        currentSchema = schemaDefinitions[ref]\n      } else if (ref.startsWith('#/')) {\n        const refPath = ref.substring(2).split('/')\n        currentSchema = topLevelSchema\n        for (const segment of refPath) {\n          if (segment in currentSchema) {\n            currentSchema = currentSchema[segment] as JSONSchema\n          } else {\n            throw Error(`Unable to resolve reference ${ref}`)\n          }\n        }\n      } else if (ref.match(/#\\//g)?.length === 1) {\n        const [schemaUrl, relativePath] = ref.split('#/')\n        if (schemaUrl in schemaDefinitions) {\n          const referencedSchema = schemaDefinitions[schemaUrl]\n          const reference = { $ref: '#/'.concat(relativePath) }\n          const auxNextPath = []\n          auxNextPath.push(nextKey)\n          if (nextPath.length > 0) {\n            auxNextPath.push(...nextPath)\n          }\n          return findSchema(referencedSchema, schemaDefinitions, auxNextPath, reference)\n        } else {\n          throw Error(`Unable to resolve reference ${ref}`)\n        }\n      } else {\n        throw Error(`Unable to resolve reference ${ref}`)\n      }\n    }\n\n    // We have no more path segments to resolve, return the currently found schema\n    // We do this here, after resolving references, in case of the leaf schema beeing a reference\n    if (nextKey === undefined) {\n      return currentSchema\n    }\n\n    if (\n      typeof currentSchema.properties === 'object' &&\n      currentSchema.properties &&\n      nextKey in currentSchema.properties\n    ) {\n      currentSchema = (currentSchema.properties as Record<string, JSONSchema>)[nextKey]\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.patternProperties === 'object' && currentSchema.patternProperties) {\n      for (const prop in currentSchema.patternProperties) {\n        if (nextKey.match(prop)) {\n          currentSchema = (currentSchema.patternProperties as Record<string, JSONSchema>)[prop]\n          return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n        }\n      }\n    }\n\n    if (typeof currentSchema.additionalProperties === 'object') {\n      currentSchema = currentSchema.additionalProperties as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.items === 'object' && currentSchema.items) {\n      currentSchema = currentSchema.items as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n  }\n\n  return undefined\n}\n","import EnumValue from './components/EnumValue.svelte'\nimport { getJSONSchemaOptions } from '$lib/utils/jsonSchemaUtils.js'\nimport type {\n  JSONSchema,\n  JSONSchemaDefinitions,\n  RenderValueComponentDescription,\n  RenderValueProps\n} from '$lib/types'\n\n/**\n * Search the JSON schema for enums defined at given props.path. If found,\n * return an EnumValue renderer. If not found, return null. In that case you\n * have to fallback on the default valueRender function\n */\nexport function renderJSONSchemaEnum(\n  props: RenderValueProps,\n  schema: JSONSchema,\n  schemaDefinitions?: JSONSchemaDefinitions\n): RenderValueComponentDescription[] | undefined {\n  const enumValues = getJSONSchemaOptions(schema, schemaDefinitions, props.path)\n\n  if (enumValues) {\n    const { value, path, selection, parser, readOnly, onPatch } = props\n\n    const options = enumValues.map((enumValue) => ({\n      value: enumValue,\n      text: enumValue\n    }))\n\n    // make sure the current value is also added as one of the options,\n    // else it would look as if the first option is the current value\n    const optionsWithValue = enumValues.includes(props.value)\n      ? options\n      : [{ value: value as unknown, text: value as unknown }].concat(options)\n\n    return [\n      {\n        component: EnumValue,\n        props: {\n          value,\n          path,\n          selection,\n          parser,\n          readOnly,\n          onPatch,\n          options: optionsWithValue\n        }\n      }\n    ]\n  }\n\n  return undefined\n}\n","import type Ajv from 'ajv'\nimport type { Options, Schema, ErrorObject } from 'ajv'\nimport AjvDist from 'ajv'\nimport { parsePath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, ValidationError, Validator } from '$lib/types'\nimport { ValidationSeverity } from '$lib/types.js'\n\nexport interface AjvValidatorOptions {\n  schema: JSONSchema\n  schemaDefinitions?: JSONSchemaDefinitions\n  ajvOptions?: Options\n  onCreateAjv?: (ajv: Ajv) => Ajv | void\n}\n\n/**\n * Create a JSON Schema validator powered by Ajv.\n * @param options\n * @property schema\n *                    The JSON schema to validate (required).\n * @property [schemaDefinitions=undefined]\n *                    An object containing JSON Schema definitions\n *                    which can be referenced using $ref\n * @property [ajvOptions=undefined]\n *                    Optional extra options for Ajv\n * @property [onCreateAjv=undefined]\n *                    An optional callback function allowing to apply additional\n *                    configuration on the provided Ajv instance, or return\n *                    your own Ajv instance and ignore the provided one.\n * @return Returns a validation function\n */\nexport function createAjvValidator(options: AjvValidatorOptions): Validator {\n  let ajv = createAjvInstance(options)\n  if (options.onCreateAjv !== undefined) {\n    ajv = options.onCreateAjv(ajv) || ajv\n\n    // validate whether ajv is configured correctly (this is needed to enhance error messages)\n    if (ajv.opts.verbose === false) {\n      throw new Error('Ajv must be configured with the option verbose=true')\n    }\n  }\n\n  const validateAjv = ajv.compile(options.schema as Schema)\n\n  if (validateAjv.errors) {\n    throw validateAjv.errors[0]\n  }\n\n  return function validate(json: unknown): ValidationError[] {\n    validateAjv(json)\n    const ajvErrors = validateAjv.errors || []\n\n    return ajvErrors.map(improveAjvError).map((error) => normalizeAjvError(json, error))\n  }\n}\n\nfunction createAjvInstance(options: AjvValidatorOptions): Ajv {\n  const { schemaDefinitions, ajvOptions } = options\n\n  const ajv = new AjvDist({\n    allErrors: true,\n    verbose: true,\n    $data: true,\n    ...ajvOptions\n  })\n\n  if (schemaDefinitions) {\n    Object.keys(schemaDefinitions).forEach((ref) => {\n      ajv.addSchema(schemaDefinitions[ref] as Schema, ref)\n    })\n  }\n\n  return ajv\n}\n\nfunction normalizeAjvError(json: unknown, ajvError: ErrorObject): ValidationError {\n  return {\n    path: parsePath(json, ajvError.instancePath),\n    message: ajvError.message || 'Unknown error',\n    severity: ValidationSeverity.warning\n  }\n}\n\n/**\n * Improve the error message of a JSON schema error,\n * for example list the available values of an enum.\n */\nfunction improveAjvError(ajvError: ErrorObject): ErrorObject {\n  let message: string | undefined = undefined\n\n  if (ajvError.keyword === 'enum' && Array.isArray(ajvError.schema)) {\n    let enums = ajvError.schema\n    if (enums) {\n      enums = enums.map((value) => JSON.stringify(value))\n\n      if (enums.length > 5) {\n        const more = ['(' + (enums.length - 5) + ' more...)']\n        enums = enums.slice(0, 5)\n        enums.push(more)\n      }\n      message = 'should be equal to one of: ' + enums.join(', ')\n    }\n  }\n\n  if (ajvError.keyword === 'additionalProperties') {\n    message = 'should NOT have additional property: ' + ajvError.params.additionalProperty\n  }\n\n  return message ? { ...ajvError, message } : ajvError\n}\n","import jmespath from 'jmespath'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { JSONParser, QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport { isEqualParser } from '$lib/utils/jsonUtils.js'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jmespath.org\" target=\"_blank\" rel=\"noopener noreferrer\">JMESPath</a> query \n  to filter, sort, or transform the JSON data.\n To learn JMESPath, go to <a href=\"https://jmespath.org/tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">the interactive tutorial</a>.\n</p>\n`\n\nexport const jmespathQueryLanguage: QueryLanguage = {\n  id: 'jmespath',\n  name: 'JMESPath',\n  description: description,\n  createQuery,\n  executeQuery\n}\n\n/**\n * Build a JMESPath query based on query options coming from the wizard\n * @param json   The JSON document for which to build the query.\n *                      Used for context information like determining\n *                      the type of values (string or number)\n * @param queryOptions\n * @return Returns a query (as string)\n */\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { sort, filter, projection } = queryOptions\n  let query = ''\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const examplePath = ['0'].concat(filter.path)\n    const exampleValue = getIn(json, examplePath)\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof exampleValue === 'string' && filterValue !== null && filterValue !== undefined\n        ? `\"${filter.value}\"`\n        : filterValue\n\n    query +=\n      '[? ' +\n      stringifyPathForJmespath(filter.path) +\n      ' ' +\n      filter.relation +\n      ' ' +\n      '`' +\n      filterValueStr +\n      '`' +\n      ']'\n  } else {\n    query += Array.isArray(json) ? '[*]' : '@'\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      query += ' | reverse(sort_by(@, &' + stringifyPathForJmespath(sort.path) + '))'\n    } else {\n      query += ' | sort_by(@, &' + stringifyPathForJmespath(sort.path) + ')'\n    }\n  }\n\n  if (projection && projection.paths) {\n    if (query[query.length - 1] !== ']') {\n      query += ' | [*]'\n    }\n\n    if (projection.paths.length === 1) {\n      const path = projection.paths[0]\n\n      query +=\n        path.length === 0\n          ? '' // edge case, selecting projection of the item root\n          : '.' + stringifyPathForJmespath(path)\n    } else if (projection.paths.length > 1) {\n      query +=\n        '.{' +\n        projection.paths\n          .map((path) => {\n            const name = path[path.length - 1]\n            return stringifyProp(name) + ': ' + stringifyPathForJmespath(path)\n          })\n          .join(', ') +\n        '}'\n    } else {\n      // values.length === 0\n      // ignore\n    }\n  }\n\n  return query\n}\n\n/**\n * Execute a JMESPath query, returns the transformed JSON\n */\nfunction executeQuery(json: unknown, query: string, parser: JSONParser): unknown {\n  // JMESPath cannot handle non-native JSON data types like LosslessNumber\n\n  function stringifyAndParse(json: unknown) {\n    const text = parser.stringify(json)\n    return text !== undefined ? JSON.parse(text) : undefined\n  }\n\n  const preprocessedJson = isEqualParser(parser, JSON) ? json : stringifyAndParse(json)\n\n  return jmespath.search(preprocessedJson, query)\n}\n\n// TODO: unit test stringifyPathForJmespath\n// TODO: Isn't there a helper function exposed by the JMESPath library?\nexport function stringifyPathForJmespath(path: JSONPath): string {\n  if (path.length === 0) {\n    return '@'\n  }\n\n  const str = path\n    .map((prop) => {\n      if (typeof prop === 'number') {\n        return '[' + prop + ']'\n      } else {\n        return '.' + stringifyProp(String(prop))\n      }\n    })\n    .join('')\n\n  return str[0] === '.'\n    ? str.slice(1) // remove first dot\n    : str\n}\n\nfunction stringifyProp(prop: string): string {\n  return prop.match(/^[A-Za-z\\d_$]+$/) ? prop : JSON.stringify(prop)\n}\n","import { JSONPath as JSONPathPlus } from 'jsonpath-plus'\nimport { parseString } from '$lib/utils/stringUtils'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://github.com/JSONPath-Plus/JSONPath\" target=\"_blank\" \n  rel=\"noopener noreferrer\"><code>JSONPath</code></a> expression to filter, sort, or transform the data.\n</p>`\n\nexport const jsonpathQueryLanguage: QueryLanguage = {\n  id: 'jsonpath',\n  name: 'JSONPath',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  let expression = '$'\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const filterValue = parseString(filter.value)\n    const filterValueStr = JSON.stringify(filterValue)\n\n    expression += `[?(@${pathToString(filter.path)} ${filter.relation} ${filterValueStr})]`\n  }\n\n  if (sort && sort.path && sort.direction) {\n    throw new Error('Sorting is not supported by JSONPath. Please clear the sorting fields')\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      throw new Error(\n        'Picking multiple fields is not supported by JSONPath. Please select only one field'\n      )\n    }\n\n    if (!expression.endsWith(']')) {\n      expression += '[*]'\n    }\n    expression += `${pathToString(projection.paths[0])}`.replace(/^\\.\\.\\./, '..')\n  }\n\n  return expression\n}\n\nfunction executeQuery(json: unknown, path: string): unknown {\n  const output = JSONPathPlus({ json: json as JSON, path })\n  return output !== undefined ? output : null\n}\n\nfunction pathToString(path: JSONPath): JSONPath | string {\n  const lettersOnlyRegex = /^[A-z]+$/\n\n  return path\n    .map((prop) => {\n      return lettersOnlyRegex.test(prop) ? `.${prop}` : JSON.stringify([prop])\n    })\n    .join('')\n}\n","import * as _ from 'lodash-es'\nimport { last } from 'lodash-es'\nimport { createLodashPropertySelector, createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n  You can use <a href=\"https://lodash.com\" target=\"_blank\" rel=\"noopener noreferrer\">Lodash</a>\n  functions like <code>_.map</code>, <code>_.filter</code>,\n  <code>_.orderBy</code>, <code>_.sortBy</code>, <code>_.groupBy</code>,\n  <code>_.pick</code>, <code>_.uniq</code>, <code>_.get</code>, etcetera.\n</p>\n`\n\nexport const lodashQueryLanguage: QueryLanguage = {\n  id: 'lodash',\n  name: 'Lodash',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return _.chain(data)\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryParts.push(\n      `    .orderBy([${createLodashPropertySelector(sort.path)}], ['${sort.direction}'])\\n`\n    )\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      // Note that we do not use _.pick() here because this function doesn't flatten the results\n      const paths = projection.paths.map((path) => {\n        const name = last(path) || 'item' // 'item' in case of having selected the item root\n        return `      ${JSON.stringify(name)}: item${createPropertySelector(path)}`\n      })\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}\\n    }))\\n`)\n    } else {\n      const path = projection.paths[0]\n      queryParts.push(`    .map(item => item${createPropertySelector(path)})\\n`)\n    }\n  }\n\n  queryParts.push('    .value()\\n')\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  validate(query)\n\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '_',\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )(_)\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n\nfunction validate(query: string) {\n  // It is very common to forget to end a lodash chain with .value()\n  // This lets the JSON Editor crash though.\n  // Therefore, we do a simple validation (not a guarantee)\n  const chainCount = query.match(/_\\.chain\\(/g)?.length\n  const valueCount = query.match(/\\.value\\(\\)/g)?.length\n\n  if (chainCount !== valueCount) {\n    throw new Error('Cannot execute query: Lodash _.chain(...) must end with .value()')\n  }\n}\n","import { createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n</p>\n`\n\nexport const javascriptQueryLanguage: QueryLanguage = {\n  id: 'javascript',\n  name: 'JavaScript',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return data\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort descending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? -1 : valueA < valueB ? 1 : 0\\n` +\n          `    })\\n`\n      )\n    } else {\n      // sort direction 'asc'\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort ascending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? 1 : valueA < valueB ? -1 : 0\\n` +\n          `    })\\n`\n      )\n    }\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      const paths = projection.paths.map((path) => {\n        const name = path[path.length - 1] || 'item' // 'item' in case of having selected the item root\n        const item = `item${createPropertySelector(path)}`\n        return `      ${JSON.stringify(name)}: ${item}`\n      })\n\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}})\\n    )\\n`)\n    } else {\n      const item = `item${createPropertySelector(projection.paths[0])}`\n\n      queryParts.push(`    .map(item => ${item})\\n`)\n    }\n  }\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )()\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n","import JSONEditorComponent from './components/JSONEditor.svelte'\nimport type { JSONEditorPropsOptional } from '$lib/types'\n\n// Note: index.ts exports `JSONEditor`, but we will override this on purpose\n//  since we cannot use it in the vanilla environment starting in Svelte 5.\nexport * from './index'\n\ninterface CreateJSONEditorProps {\n  target: HTMLDivElement\n  props: JSONEditorPropsOptional\n}\n\nexport function createJSONEditor({ target, props }: CreateJSONEditorProps) {\n  // TODO: in Svelte 5, this needs to be changed to:\n  //\n  //     export function createJSONEditor({ target, props }: Parameters<typeof mount>[1]) {\n  //       return mount(JSONEditor, { target, props })\n  //     }\n  //\n  return new JSONEditorComponent({ target, props })\n}\n\n/**\n * The constructor \"new JSONEditor(...)\" is deprecated. Please use \"createJSONEditor(...)\" instead.\n * @constructor\n * @deprecated\n */\nexport function JSONEditor({ target, props }: CreateJSONEditorProps) {\n  // TODO: deprecation warning since v1. Remove some day\n  console.warn(\n    'WARNING: the constructor \"new JSONEditor(...)\" is deprecated since v1. ' +\n      'Please use \"createJSONEditor(...)\" instead.'\n  )\n\n  return createJSONEditor({ target, props })\n}\n"],"names":["noop","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","not_equal","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","slice","get_slot_changes","dirty","lets","undefined","merged","len","Math","max","length","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","p","get_all_dirty_from_scope","exclude_internal_props","props","result","compute_rest_props","keys","rest","Set","has","null_to_empty","value","action_destroyer","action_result","destroy","globals","window","globalThis","global","append","target","node","appendChild","append_styles","style_sheet_id","styles","append_styles_to","document","root","getRootNode","ownerDocument","host","get_root_for_style","getElementById","style","element","id","textContent","head","sheet","append_stylesheet","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","name","createElement","svg_element","createElementNS","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","prevent_default","preventDefault","call","this","stop_propagation","stopPropagation","attr","attribute","removeAttribute","getAttribute","setAttribute","current_component","always_set_through_set_attribute","set_attributes","attributes","descriptors","getOwnPropertyDescriptors","__proto__","key","cssText","set","indexOf","set_svg_attributes","set_data","set_input_value","input","set_style","important","removeProperty","setProperty","select_option","select","mounting","option","__value","selected","selectedIndex","toggle_class","toggle","classList","construct_svelte_component","component","set_current_component","get_current_component","Error","onMount","$$","on_mount","push","onDestroy","on_destroy","createEventDispatcher","type","detail","cancelable","arguments","callbacks","bubbles","CustomEvent","custom_event","defaultPrevented","getContext","context","get","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","then","flush","tick","add_render_callback","add_flush_callback","seen_callbacks","flushidx","saved_component","update","e","pop","callback","add","clear","fragment","before_update","after_update","outros","outroing","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","ensure_array_like","array_like_or_iterator","Array","from","destroy_block","lookup","outro_and_destroy_block","update_keyed_each","old_blocks","get_key","dynamic","list","create_each_block","next","get_context","n","old_indexes","new_blocks","new_lookup","Map","deltas","updates","_loop","child_ctx","abs","will_move","did_move","m","first","new_block","old_block","new_key","old_key","get_spread_update","levels","to_null_out","accounted_for","get_spread_object","spread_props","bind","index","bound","create_component","mount_component","new_on_destroy","map","filter","destroy_component","filtered","targets","init","instance","create_fragment","parent_component","on_disconnect","skip_bound","ready","ret","fill","make_dirty","hydrate","nodes","childNodes","children","l","intro","SvelteComponent","constructor","_defineProperty","$destroy","$on","splice","$set","obj","$$set","createDebug","namespace","enabled","debug","localStorage","_unused","tryReadLocalStorage","endsWith","startsWith","enableDebug","color","hash","charCodeAt","colors","selectColor","_len","args","_key4","console","log","concat","__svelte","v","uniqueId","int","parseInt","containsNumber","NUMBER_REGEX","test","isObject","isObjectOrArray","isBoolean","isTimestamp","isFinite","floor","isNaN","Date","valueOf","Number","_unused2","getColorCSS","colorTestDiv","applied","replace","toLowerCase","isColor","valueType","parser","isArray","valueStr","stringify","isUrlRegex","isUrl","stringConvert","str","strTrim","trim","parse","isInteger","INTEGER_REGEX","MAX_ITEM_PATHS_COLLECTION","ROOT_PATH","strictShallowEqual","getNestedPaths","array","includeObjects","pointersMap","TypeError","recurseNestedPaths","path","compileJSONPointer","min","sort","parseJSONPointer","forEachIndex","start","end","iteratee","limit","arrayToObject","_objectSpread","objectToArray","object","values","moveItems","count","offset","copy","moving","apply","insertItemsAt","items","parseAndRepair","jsonText","_unused3","jsonrepair","parseAndRepairOrUndefined","partialJson","_unused4","parsePartialJson","END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX","_unused5","_unused6","_unused7","repairPartialJson","_unused8","repaired","substring","_unused9","_unused10","normalizeJsonParseError","parseErrorMessage","positionMatch","POSITION_REGEX","exec","position","line","character","charAt","countCharacterOccurrences","column","lastIndexOf","message","lineMatch","LINE_REGEX","lineOneBased","columnMatch","COLUMN_REGEX","columnOneBased","calculatePosition","validateContentType","content","json","isContent","isTextContent","isJSONContent","toTextContent","indentation","JSON","toJSONContent","getText","isLargeContent","maxSize","estimateSerializedSize","Infinity","estimatedSize","recurse","String","isEqualParser","needsFormatting","includes","DELIMITER_WITHOUT_SPACING_REGEX","Mode","SelectionType","CaretType","ValidationSeverity","SearchField","SortDirection","UpdateSelectionAfterChange","createNormalizationFunctions","_ref2","escapeControlCharacters","escapeUnicodeCharacters","normalizeControlAndUnicode","normalizeControl","normalizeUnicode","normalizeNothing","escapeValue","jsonEscapeUnicode","jsonEscapeControl","unescapeValue","jsonUnescapeControl","jsonUnescapeUnicode","x","_x$codePointAt","codePointAt","toString","unescaped","controlCharacters","_unused13","escapedControlCharacters","addNewLineSuffix","isChildOfNodeName","nodeName","isChildOf","toUpperCase","isChildOfAttribute","hasAttribute","predicate","findParent","getWindow","_element$ownerDocumen","_element$ownerDocumen2","defaultView","activeElementIsChildOf","activeElement","findParentWithNodeName","getSelectionTypeFromTarget","inside","after","multi","encodeDataPath","encodeURIComponent","getDataPathFromTarget","_parent$getAttribute","parent","dataPath","decodeURIComponent","findNearestElement","_ref3","allElements","currentElement","direction","hasPrio","margin","all","rect","getBoundingClientRect","width","height","calculateCenter","current","left","y","top","distance","weightY","diffX","diffY","sqrt","distanceToCurrent","candidate","candidatesLeft","button","isLeft","isRight","right","candidatesLeftOnRow","isOnSameRow","nearest","minBy","candidates","isAbove","isBelow","prioCandidates","isMacDevice","_ref4","_navigator$platform$t","_navigator","_navigator2","navigator","platform","userAgentData","keyComboFromEvent","separator","combi","isCtrlKeyDown","altKey","shiftKey","keyName","metaKeys","join","isMac","ctrlKey","metaKey","Ctrl","Command","Control","Alt","Option","Shift","switch_instance_spread_levels","switch_value","switch_instance_props","div","div_style_value","calculateStyle","create_if_block","handleMouseDownInside","refRootPopup","rootRect","positionAbove","positionLeft","offsetTop","offsetLeft","bottom","innerHeight","innerWidth","refHiddenInput","popup","$$props","closeAbsolutePopup","closeWhenOutside","closeOnOuterClick","focus","$$value","each_blocks","popups","popupId","popupIndex","findIndex","onClose","openAbsolutePopup","findUniqueName","keysSet","nameWithoutCopySuffix","validName","truncate","maxLength","maxTextLength","ellipsis","parseString","lower","num","numFloat","parseFloat","jsonQueryLanguage","_json","queryOptions","projection","queryFunctions","relation","operator","getter","paths","query","jsonquery","g","cursor","raw","getRaw","rawData","ids","match","rawId","_","pointerId","$$invalidate","svg","class","svg_class_value","role","svg_role_value","className","box","spin","inverse","pulse","flip","label","path_1","polygon_1","each_value_1","_ctx$","each_value","_ctx$2","polygons","if_block","_ctx$3","_ctx$4","_ctx$5","_ctx$6","iconData","combinedStyle","scale","normalisedScale","numScale","warn","calculateRatio","iconName","icon","error","normaliseData","combined","size","faCheckSquare","faSquare","div_aria_checked_value","icon_changes","readOnly","onPatch","op","ref","onChange","showOnTop","destroyColorPicker","_asyncToGenerator","_yield$import","colorPicker","default","onDone","hex","rgba","show","title","_getWindow$1$innerHei","_getWindow$","windowHeight","ColorPickerPopup","AUTO_SCROLL_INTERVAL","AUTO_SCROLL_SPEED_SLOW","AUTO_SCROLL_SPEED_NORMAL","AUTO_SCROLL_SPEED_FAST","MAX_SEARCH_RESULTS","ARRAY_SECTION_SIZE","MAX_VALIDATION_ERRORS","MAX_CHARACTERS_TEXT_PREVIEW","DEFAULT_VISIBLE_SECTIONS","MAX_VALIDATABLE_SIZE","MAX_AUTO_REPAIRABLE_SIZE","MAX_DOCUMENT_SIZE_TEXT_MODE","MAX_DOCUMENT_SIZE_EXPAND_ALL","INSERT_EXPLANATION","CONTEXT_MENU_EXPLANATION","HOVER_INSERT_INSIDE","HOVER_INSERT_AFTER","HOVER_COLLECTION","JSON_STATUS_VALID","JSON_STATUS_REPAIRABLE","CONTEXT_MENU_HEIGHT","CONTEXT_MENU_WIDTH","SEARCH_BOX_HEIGHT","SORT_DIRECTION_NAMES","asc","desc","mergeSections","sections","sortedSections","sortBy","section","mergedSections","sortedIndex","mergedIndex","previous","nextRoundNumber","currentRoundNumber","isMenuSpace","item","isMenuSeparator","isMenuLabel","isMenuButton","isMenuDropDownButton","isContextMenuRow","isContextMenuColumn","isContentParseError","contentErrors","isContentValidationErrors","isValidationError","isNestedValidationError","isChildError","isSvelteComponentRenderer","isSvelteActionRenderer","action","isObjectRecursiveState","state","isArrayRecursiveState","isValueRecursiveState","isExpandableState","hasSearchResults","searchResults","createDocumentState","_ref14","expand","documentState","_ref13","factory","createArrayDocumentState","createObjectDocumentState","createValueDocumentState","createRecursiveState","documentStateFactory","expandPath","expanded","visibleSections","properties","ensureRecursiveState","_ref15","arrayState","itemState","setIn","objectState","syncDocumentState","_transformDocumentState","nestedJson","nestedState","updatedState","forEachVisibleIndex","itemPath","updatedItem","propPath","updatedProp","jsonArray","_ref16","toRecursiveStatePath","recursiveStatePath","partialPath","updateInDocumentState","some","inVisibleSection","newVisibleSection","expandVisibleSection","_loop2","nestedValue","nestedPath","_expandRecursively","collapsePath","recursive","_collapse","_collapseRecursively","documentStatePatch","operations","initial","reduce","operation","immutableJSONPatch","_documentStatePatch","isJSONPatchAdd","documentStateAdd","isJSONPatchRemove","documentStateRemove","isJSONPatchReplace","parsePath","enforceString","getEnforceString","setInDocumentState","isJSONPatchCopy","isJSONPatchMove","stateValue","getInRecursiveState","documentStateMoveOrCopy","getIn","_unused14","updateInRecursiveState","transform","ensuredState","updateIn","recursiveState","setInRecursiveState","_parent","last","shiftVisibleSections","parentPath","recursivePath","existsIn","deleteIn","deleteInDocumentState","mergeAdjacentSections","getNextKeys","includeKey","getVisiblePaths","_recurse","isJSONArray","isJSONObject","getVisibleCaretPositions","includeInside","valueState","propertyPath","getNextVisiblePath","visiblePaths","expandSmart","expandMinimal","expandAll","relativePath","expandSelf","expandNone","isAfterSelection","selection","isInsideSelection","isKeySelection","isValueSelection","isMultiSelection","isMultiSelectionWithOneItem","isEqual","focusPath","anchorPath","isJSONSelection","isTextSelection","getSelectionPaths","getAnchorPath","getFocusPath","sharedPath","findSharedPath","createMultiSelection","startPath","getStartPath","endPath","getEndPath","startIndex","getChildIndex","endIndex","iterateOverSelection","getParentPath","anchorIndex","getSelectionUp","keepAnchorPath","previousPath","visiblePathPointers","pathPointer","getPreviousVisiblePath","createValueSelection","isEmpty","createKeySelection","findCaretAndSiblings","caret","visibleCaretPositions","getInitialSelection","createSelectionFromOperations","every","firstOp","otherOps","path1","path2","singleItemSelected","findRootPath","pathStartsWith","removeEditModeFromSelection","isEditingSelection","createEditKeySelection","initialValue","edit","createEditValueSelection","createInsideSelection","createAfterSelection","isParent","selectionToPartialJson","hasSelectionContents","canConvert","fromCaretPosition","caretPosition","fromSelectionType","selectionType","selectionIfOverlapping","pathInSelection","pathIndex","classnames","classes","_len2","_key5","arg","hasOwnProperty","getValueClass","mode","table","div_class_value","domValue","valueClass","shortText","onCancel","onFind","onPaste","onValueClass","closed","getDomValue","removeNewLineSuffix","innerText","setDomValue","updatedValue","firstChild","range","createRange","getSelection","setStart","collapse","removeAllRanges","addRange","setCursorToEnd","newValue","no","combo","nextInside","clipboardData","clipboardText","getData","hasFocus","self","editablediv_changes","normalization","onPasteJson","onSelect","findNextInside","convert","handleCancelChange","updateSelection","patchedState","patchedSelection","pastedText","pastedJson","contents","onPasteAsJson","patchedJson","entry","afterKey","nextKeys","newProp","moveDown","rename","oldKey","newKey","newKeyUnique","duplicate","lastPath","beforeKey","clipboard","_unused16","newValues","clipboardToValues","firstPath","removeAll","removeKeys","filteredKeys","nextKey","firstKey","reverse","textIsObject","textIsArray","clipboardOriginal","clipboardRepaired","createRemoveOperations","newSelection","previousKey","revertJSONPatchWithMoveOperations","revertJSONPatch","before","revertOperations","createRevertMoveOperations","searchNext","searchResult","nextActiveIndex","activeIndex","nextActiveItem","active","activeItem","search","searchText","_options$maxResults","searchTextLowerCase","maxResults","columns","results","onMatch","searchRecursive","level","findCaseInsensitiveMatches","field","textLower","fieldIndex","replaceText","replacementText","replaceAllText","occurrences","updatedText","forEachRight","occurrence","createSearchAndReplaceOperations","searchResultItem","currentValue","currentValueText","getSearchResultPath","filterKeySearchResults","filterValueSearchResults","searchResultsFactory","toRecursiveSearchResults","searchResultItems","updateInSearchResults","flattenSearchResults","_node$searchResults","nested","flatMap","span","t","t_value","parts","matches","previousEnd","precedingText","matchingText","lastMatch","splitValue","valueIsUrl","open","tooltip","_ref22","handleMouseEnter","Tooltip","handleMouseLeave","faClock","absolutePopupContext","renderValue","_ref24","isEditing","renderers","BooleanToggle","ColorPicker","EditableValue","ReadonlyValue","TimestampTag","stringifyJSONPath","integerNumberRegex","parseJSONPath","pathStr","parseProp","eatCharacter","isEnd","unescape","prop","char","SyntaxError","pathToOption","stringifyLodashProperty","javaScriptPropertyRegex","propStr","createPropertySelector","transformModalStates","transformModalStateShared","showWizard","showOriginal","round","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getOppositeAlignmentPlacement","alignment","getOppositePlacement","side","getPaddingObject","padding","expandPaddingObject","rectToClientRect","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","computePosition","_ref25","config","strategy","middleware","validMiddleware","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","initialPlacement","elements","_x","_x2","_x3","detectOverflow","_x4","_x5","_detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","_convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","getNodeName","isNode","_node$ownerDocument","documentElement","Node","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","css","perspective","containerType","backdropFilter","willChange","contain","CSS","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","scrollX","scrollY","getParentNode","assignedSlot","getNearestOverflowAncestor","body","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","visualViewport","frameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","noOffsets","getVisualOffsets","includeScale","isFixedStrategy","clientRect","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","isStaticPositioned","getTrueOffsetParent","polyfill","svgOffsetParent","currentNode","getContainingBlock","topLayer","elementClippingAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingElementAncestors","_c","clippingAncestors","firstClippingAncestor","clippingRect","accRect","_ref26","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","_x8","getClientRects","autoUpdate","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","passive","frameId","cleanupIo","onMove","timeoutId","io","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","rootMargin","isFirstUpdate","handleObserve","observe","entries","ratio","intersectionRatio","setTimeout","observeMove","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","_middlewareData$offse","_middlewareData$arrow","diffCoords","_x6","_x7","convertValueToCoords","arrow","alignmentOffset","shift","_evaluate2","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","_objectWithoutProperties","_excluded2","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","_middlewareData$flip","_evaluate","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","_excluded","initialSideAxis","isBasePlacement","oppositePlacement","getExpandedPlacements","hasFallbackAxisSideDirection","isStart","lr","rl","getSideList","getOppositeAxisPlacements","placements","overflows","overflowsData","sides","mainAlignmentSide","getAlignmentSides","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","_overflowsData$filter2","currentSideAxis","acc","mergedOptions","platformWithCache","computePosition$1","_ref27","loadOptions","filterText","multiple","itemId","groupBy","filterSelectedItems","itemFilter","convertStringItemsToObjects","filterGroupedItems","filterResults","matchesFilter","getItems","_x9","_getItems","_ref28","dispatch","res","catch","err","details","cancelled","filteredItems","loading","focused","listOpen","circle","if_block0","create_if_block_13","if_block2","create_if_block_9","_ctx$7","_ctx$8","div0","groupHeader","groupItem","_ctx$9","selectable","div1","listDom","_ctx$10","span0","span1","ClearIcon","create_if_block_6","create_if_block_8","create_if_block_7","create_if_block_4","create_if_block_3","create_if_block_2","create_if_block_1","input_1","if_block6","div3","div2","input_1_readonly_value","_items","timeout","activeValue","prev_value","prev_filterText","prev_multiple","_inputAttributes","slots","justValue","_filter","container","multiFullItemClearable","disabled","placeholder","placeholderAlwaysShow","groupFilter","groups","groupHeaderSelectable","containerStyles","hasError","required","closeListOnChange","clearFilterTextOnBlur","createGroupHeaderItem","groupValue","searchable","inputStyles","clearable","debounce","wait","debounceWait","hideEmptyState","inputAttributes","listAutoWidth","showChevron","listOffset","hoverItemIndex","floatingConfig","containerClasses","groupValues","sortedGroupedItems","checkHoverSelectable","startingIndex","ignoreGroup","setHoverIndex","checkValueForDuplicates","noDuplicates","uniqueValues","val","findItem","matchTo","find","handleMultiItemClear","_x10","_handleMultiItemClear","itemToRemove","handleFocus","_document","_input","handleBlur","_x11","_handleBlur","_input2","isScrolling","closeList","blur","ariaValues","ariaListOpen","ariaFocused","isScrollingTimer","handleListScroll","_list2","remove","handleSelect","itemSelected","handleHover","handleItemClick","isItemSelectable","increment","hasOwn","hover","activeScroll","scrollAction","hoverScroll","scrollIntoView","behavior","initOptions","referenceElement","floatingElement","defaultOptions","getOptions","updatePosition","setupVirtualElementObserver","_floatingConfig","floatingRef","floatingContent","floatingUpdate","mixin","subscribe","$node","contentAction","contentOptions","autoUpdateDestroy","destroyAutoUpdate","initAutoUpdate","_autoUpdate","updateOptions","_options","onComputed","prefloat","setValue","autocapitalize","autocomplete","autocorrect","spellcheck","tabindex","hasValue","hideSelectedItem","showClear","placeholderText","_value5","ariaSelection","ariaContext","_item","handleAriaContent","updateValueDisplay","handleFilterEvent","_floatingConfig2","listMounted","setListWidth","scrollToHoverItem","hoverItem","_list","contains","getFilteredItems","tbody","tr0","th0","td0","tr1","th1","td1","tr2","th2","td2","filterRelationOptions","sortDirectionOptions","filterPath","_queryOptions","filterRelation","_filterRelationOption","_queryOptions$filter","filterValue","_queryOptions2","sortPath","_queryOptions3","sortDirection","_sortDirectionOptions","_queryOptions$sort","_queryOptions4","_queryOptions5","_queryOptions6","_queryOptions8","jsonIsArray","pathsIncludingObjects","fieldOptions","projectionOptions","projectionPaths","_queryOptions10","_filterPath","_filterRelation","_queryOptions7","changeSortPath","_sortPath","_sortDirection","_queryOptions9","changeProjectionPaths","t1_value","button_title_value","t1","queryLanguages","queryLanguageId","onChangeQueryLanguage","handleChangeQueryLanguage","newQueryLanguageId","queryLanguage","faDownLeftAndUpRightToCenter","faUpRightAndDownLeftFromCenter","faTimes","fullScreenButton","fullscreen","click_handler","_onClose","faCog","refConfigButton","SelectQueryLanguage","easeInOutQuad","createJump","stop","easing","a11y","duration","timeStart","timeElapsed","scrolling","scrollTo","loop","timeCurrent","done","querySelector","MAX_HISTORY_ITEMS","createHistory","maxItems","canUndo","canRedo","getState","handleChange","undo","redo","measure","onDuration","now","validationErrorsFactory","updateInValidationErrors","errors","validateJSON","validator","validationParser","validateText","validationErrors","severity","info","convertedJSON","isRepairable","_unused17","canAutoRepair","parseError","createFocusTracker","_ref35","blurTimeoutHandle","onFocus","onBlur","handleFocusIn","newFocus","handleFocusOut","icon_1","Icon","icon_1_changes","button_disabled_value","actions","onClick","onMouseDown","faExclamationTriangle","faAngleRight","tr","tr_class_value","faAngleDown","t3_value","td3","t3","show_if","selectError","warning","validationError","onEscape","handleKeyDown","dialog_1","dialog","showModal","close","div9","div7","div4","div6","div5","div8","ctrl","unknownMenuItem","if_block1","button_class_value","show_if_1","show_if_2","message_changes","textarea","domTextArea","onParse","onRepair","onApply","handleApply","getErrorMessage","repairable","errorActions","gotoAction","repairAction","successActions","faCheck","faArrowDown","setSelectionRange","faWrench","repairedText","handleMouseMove","sectionIndex","total","onExpandSection","visibleSection","getJson","expandItemsSections","section1","start2","section2","currentIndex","previousIndex","section3","showSection2","getExpandItemsSections","expandItemsSection","faCaretDown","insert_1","onContextMenu","buttonElem","showTip","searchresulthighlighter_changes","contextmenupointer_changes","pointer","onUpdateKey","isKeySelected","isEditingKey","updatedKey","updatedPath","previous_key","dispose","action_action","constants_0","onRenderValue","singleton","selecting","selectionAnchor","selectionAnchorType","selectionFocus","dragging","onMoveSelection","_ref47","deltaY","updatedSelection","dragInsideAction","_ref48","initialPath","initialIndex","prevHeight","_items2","cumulativeHeight","beforePath","findSwapPathUp","_ref49","_items$beforeIndex","nextHeight","_items3","findSwapPathDown","startKey","endKey","toKey","toIndex","times","moveInsideParent","_ref50","_items4","_items5","createUpdatedArraySelection","onExpand","appendToJSONPointer","constants_1","constants_2","constants_4","create_if_block_26","create_if_block_24","create_if_block_23","jsonvalue_changes","create_if_block_21","create_if_block_20","if_block4","create_if_block_18","create_if_block_16","create_if_block_17","create_if_block_10","faCaretRight","t2_value","t4_value","t2","t4","create_if_block_14","jsonkey_changes","jsonnode_changes","gutterIndex","collapseditems_changes","onClassName","isNodeSelected","onDragSelectionStart","hoverTimer","handleMouseMoveGlobal","onDrag","handleMouseUpGlobal","onDragEnd","findContentTop","_context$findElement","findElement","calculateDeltaY","contentOffset","initialContentTop","clientY","initialClientY","handleDragSelection","didMoveItems","handleDragSelectionEnd","initialTarget","_validationErrors","selectionStartIndex","selectionItemsCount","indices","buttons","contentEditable","isContentEditableDiv","anchorType","getDocumentState","fullSelection","lastCaretPosition","selectionParentPath","addHeight","currentSection","getVisibleItemsWithHeights","contextMenuProps","faJSONEditorExpand","prefix","faJSONEditorCollapse","faJSONEditorFormat","faJSONEditorCompact","expandMenuItem","collapseMenuItem","searchMenuItem","defaultItems","showSearch","historyState","onExpandAll","onCollapseAll","onUndo","onRedo","onSort","onTransform","onCopy","onRenderMenu","handleToggleSearch","hasJson","faSearch","faCopy","faSortAmountDownAlt","faFilter","faEllipsisV","faUndo","faRedo","button0","button1","onCreateArray","onCreateObject","caseInsensitiveNaturalCompare","aLower","bLower","naturalCompare","sortJson","rootPath","comparator","valueA","valueB","createObjectComparator","sortArray","sortedKeys","keyA","keyB","sortObjectKeys","MAX_ITEM_CHARACTERS","MAX_ITEMS","selectedItem","refNavigationBarItem","handleSelectItem","NavigationBarDropdown","copyToClipBoard","_document$queryComman","_document2","writeText","queryCommandSupported","opacity","execCommand","inputRef","inputPath","pathParser","onError","pathExists","validationActive","copiedTimer","copied","parseAndValidate","validatePathExists","inputValidationError","currentTarget","navigationbaritem_changes","faClose","faEdit","refNavigationBar","editing","handleCloseEditor","hasNextItem","faChevronDown","faChevronUp","form","button2","faCircleNotch","initSearchInput","showReplace","onSearch","appliedText","searching","applyChangedSearchTextDebounced","_x13","_applyChangedSearchText","applyChangedJsonDebounced","_x14","_applyChangedJson","toggleShowReplace","_handlePaste","handleReplace","_handleReplace","_searchResult3","_handleReplaceAll","deduplicatedMatches","previousItem","lastNewSelection","allOperations","createSearchAndReplaceAllOperations","handleNext","_handleNext","handlePrevious","_handlePrevious","previousActiveIndex","previousActiveItem","searchPrevious","_handleFocus","_searchResult4","_applyChangedShowSearch","applySearch","_x15","_x16","_x17","_applySearch","newResultItems","previousResult","activePath","matchingActiveIndex","updateSearchResult","handleClose","cancel","resultCount","_searchResult","_searchResult2","formattedResultCount","_x12","applyChangedShowSearch","endOfPath","Symbol","getColumns","flatten","maxSampleCount","step","forEachSample","_recurseObject","_collectPaths","valueMerged","calculateVisibleSection","viewPortHeight","itemHeights","defaultItemHeight","searchBoxOffset","itemCount","averageItemHeight","calculateAverageItemHeight","viewPortTop","viewPortBottom","getItemHeight","startHeight","visibleHeight","endHeight","visibleItems","calculateAbsolutePosition","rowIndex","toTableCellPosition","columnIndex","fromTableCellPosition","groupValidationErrors","arrayErrors","rootErrors","partition","errorsByRow","findRowIndex","groupedErrorsByRow","mapValues","groupByRow","row","findColumnIndex","rows","mergeValidationErrors","clearSortedColumnWhenAffectedByOperations","sortedColumn","columms","mustBeCleared","selectedColumnIndex","operationAffectsSortedColumn","onCut","_x18","_onCut","_ref58","copyToClipboard","_x19","_onCopy","_ref59","_ref60","onChangeText","openRepairModal","doPaste","_unused20","ensureSelection","onRemove","_ref61","keepSelection","removeSelection","patchResult","onDuplicateRow","_ref62","rowPath","onInsertBeforeRow","_ref63","onInsertAfterRow","_ref64","nextRowIndex","nextRowPath","onRemoveRow","_ref65","newRowIndex","onInsert","_ref66","insertType","selectInside","onReplaceJson","jsonExample","cloneDeepWith","createNewValue","onInsertCharacter","_x20","_onInsertCharacter","_ref67","_x21","_onInsertValueWithCharacter","onInsertValueWithCharacter","_ref68","truncated","onRequestClose","li","ul","visible","handleClick","allItemsDisabled","wasVisible","main","dropdownbutton_changes","each_value_2","show_if_3","faLightbulb","refContextMenu","tip","firstEnabledButton","querySelectorAll","directionByCombo","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","create_if_block_5","faCode","isSSR","refContents","refJsonEditor","sortModalId","transformModalId","jump","externalContent","externalSelection","mainMenuBar","navigationBar","parseMemoizeOne","onChangeMode","onRenderContextMenu","onSortModal","onTransformModal","onJSONEditorModal","modalOpen","copyPasteModalOpen","jsonRepairModalProps","searchResultDetails","documentStateInitialized","_handleFocusSearch","history","isSelectionInsidePath","textIsRepaired","validationErrorList","memoizedValidate","memoizeOne","updateValidationErrors","newValidationErrorList","output","toRecursiveValidationErrors","validate","applyExternalContent","updatedContent","updatedJson","isChanged","currentlyText","previousState","expandWhenNotInitialized","clearSelectionWhenNotExisting","addHistoryItem","applyExternalJson","applyExternalText","canPatch","patch","afterPatch","_createSelectionFromO","previousJson","patched","handleEditKey","handleEditValue","openJSONEditorModal","handleToggleEnforceString","handlePatch","handleCut","_handleCut","indent","handleCopy","_handleCopy","handlePasteFromMenu","handleRemove","handleDuplicate","handleExtract","extract","handleInsert","handleReplaceJson","handleInsertFromContextMenu","handleConvert","convertedValue","parsedValue","_unused11","_unused12","convertValue","handleInsertBefore","selectionBefore","handleContextMenu","handleInsertAfter","handleInsertCharacter","_x23","_handleInsertCharacter","handleUndo","previousContent","emitOnChange","handleRedo","openSortModal","_onSort","_ref75","_x24","handleSortSelection","openTransformModal","transformedJson","handleTransformSelection","_x25","_scrollTo","scrollToWhenVisible","elem","viewPortRect","elemRect","_refContents$querySel","_refContents","elemHeight","_onChange","_onChange2","handleChangeText","handleExpand","openFind","findAndReplace","handleExpandSection","_value","expandSection","handlePasteJson","newPastedJson","openContextMenu","_ref76","_onRenderContextMenu","_ref74","onEditKey","onEditValue","onToggleEnforceString","onDuplicate","onExtract","onInsertBefore","onConvert","onInsertAfter","hasSelection","rootSelected","focusValue","editValueText","canEditKey","canEditValue","canEnforceString","canCut","canCopy","canPaste","canDuplicate","canExtract","convertMode","insertOrConvertText","canInsertOrConvertStructure","canInsertOrConvertObject","canInsertOrConvertArray","canInsertOrConvertValue","handleInsertOrConvert","faPen","faCut","faPaste","faClone","faCropAlt","faTrashCan","faArrowRightArrowLeft","faPlus","faCaretSquareUp","faCaretSquareDown","createTreeContextMenuItems","ContextMenu","clientX","_refContents2","_refContents3","_handleParsePastedJson","childPath","nextPathInside","getSelectionNextInside","handleDrag","autoScrollHandler","handleDragEnd","overflowAnchor","applySearchBoxSpacing","applyExternalSelection","scrollableElement","autoScrollSpeed","autoScrollTimer","calculateSpeed","diff","autoScrollCallback","startAutoScroll","speed","stopAutoScroll","setInterval","clearInterval","createAutoScrollHandler","tree","_x22","_event$clipboardData","collapsedState","nextPath","nextPathAfter","getSelectionDown","getSelectionLeft","getSelectionRight","isContentEditable","outsideEditor","func_3","_jsonRepairModalProps","readonlyProxy","Proxy","property","receiver","Reflect","deleteProperty","description","input_value_value","div19","div17","div16","div12","div11","div10","div15","div14","div18","innerHTML","raw_value","refQueryInput","selectedJson","selectedContent","stateId","_transformModalStates","_state$queryOptions","isManual","_state$isManual","queryError","previewError","previewContent","getSelectedQueryLanguage","_queryLanguages$find","updateQueryByWizard","newQueryOptions","createQuery","_refQueryInput","previewTransformDebounced","previewJson","jsonTransformed","executeQuery","formatSize","kilo","toFixed","KB","MB","GB","onFormat","onCompact","onToggleSearch","canFormat","canCompact","canSort","canTransform","searchItem","pos","lineNumber","columnNumber","charCount","editorState","_editorState","_editorState2","doc","lineAt","number","_editorState3","ranges","to","observer","highlightStyle","HighlightStyle","define","tag","tags","propertyName","bool","string","keyword","highlighter","syntaxHighlighting","originalStyle","get_if_ctx_1","toDiagnostic","codeMirrorRef","domTextMode","codeMirrorView","statusBar","askToFormat","tabSize","formatCompactKeyBinding","handleFormat","handleCompact","acceptTooLarge","askToFormatApplied","linterCompartment","Compartment","readOnlyCompartment","indentCompartment","tabSizeCompartment","themeCompartment","previousEscapeUnicodeCharacters","_ref82","initialText","EditorState","isValidSelection","toCodeMirrorSelection","extensions","keymap","of","indentWithTab","createLinter","lintGutter","lineNumbers","highlightActiveLineGutter","highlightSpecialChars","foldGutter","drawSelection","dropCursor","allowMultipleSelections","indentOnInput","defaultHighlightStyle","fallback","bracketMatching","closeBrackets","autocompletion","rectangularSelection","crosshairCursor","highlightActiveLine","highlightSelectionMatches","closeBracketsKeymap","defaultKeymap","searchKeymap","historyKeymap","foldKeymap","completionKeymap","lintKeymap","indentationMarkers","hideFirstIndent","EditorView","domEventHandlers","dblclick","handleDoubleClick","updateListener","docChanged","onChangeCodeMirrorValueDebounced","selectionSet","emitOnSelect","jsonLang","lineWrapping","createIndent","theme","dark","hasDarkTheme","createCodeMirrorView","disableTextEditor","emitChange","setCodeMirrorContent","handleRepair","jsonStatus","jsonParseError","_ref81","setSelection","view","selectedText","jsmap","jsonSourceMap","pointers","_pointer$value","valueEnd","linter","linterCallback","delay","getPropertyValue","toRichValidationError","pointerName","keyEnd","findTextLocation","toRichParseError","newContent","forceUpdate","newText","changes","updateCanUndoRedo","EditorSelection","fromJSON","_refresh","_updateTheme","updateTheme","onChangeCodeMirrorValue","codeMirrorText","effects","reconfigure","indentUnit","repeat","wrappedLineIndent","undoDepth","redoDepth","toJSON","memoizedValidateText","handleShowMe","richParseError","handleSelectParseError","repairActionShowMe","faEye","eq","updateLinter","updateIndentation","updateTabSize","updateReadOnly","repairActions","_onSort2","_ref80","_x26","closeSearchPanel","openSearchPanel","func","containsValidArray","_ctx$2$stringify","_ctx$2$stringify2","isSelected","containsSearchResult","containsActiveSearchResult","onEdit","dblclick_handler","faCaretUp","t0","t0_value","columnName","_sortedColumn","sortDirectionName","onResize","WeakMap","t7_value","t5","t5_value","t7","nestedArrayPaths","maxLevel","findNestedArrays","hasNestedArrays","isEmptyDocument","documentType","nestedArrayPath","faRotate","onRefresh","_child_ctx$","constants_3","_child_ctx$2","_child_ctx$3","_ctx$11","create_if_block_11","td0_colspan_value","td1_colspan_value","th","_ctx$12","each_blocks_1","inlinevalue_changes","_getInRecursiveState","td","td_data_path_value","create_if_block_15","flattenColumns","_handleFocusSearch2","itemHeightsCache","newValidationErrors","patchedSortedColumn","createDefaultSelectionWhenUndefined","createDefaultSelection","searchBoxHeight","roughDistance","scrollToHorizontal","_callback","scrollToVertical","_refContents$querySel2","_refContents4","resolvedPath","_ref89","_onRenderContextMenu2","_ref88","onEditRow","createTableContextMenuItems","handleEditRow","handleDuplicateRow","handleInsertBeforeRow","handleInsertAfterRow","handleRemoveRow","_refContents5","_refContents6","_handleParsePastedJson2","_x28","_handleCut2","_handleCopy2","_handleInsertCharacter2","handleResizeRow","currentContent","newColumns","previousColumns","orderedColumns","newColumnsSet","maintainColumnOrder","showRefreshButton","extendedOperations","unshift","createNestedValueOperations","groupedValidationErrors","_x27","newSortedColumn","selectPreviousColumn","selectNextColumn","selectPreviousRow","selectNextRow","_x29","_event$clipboardData2","_ref90","resizeObserver_function","_jsonRepairModalProps2","refTreeMode","refTableMode","refTextMode","modeMenuItems","handleRenderMenu","handleRenderContextMenu","insideModal","separatorMenuItem","_refresh2","updatedItems","updatedItemsOriginal","cloneDeep","modal","_onRenderContextMenu3","itemsOriginal","acceptAutoRepair","faCaretLeft","jsoneditorroot_changes","refEditor","rootState","determineMode","stack","scrollToSelection","_last","updateState","_refEditor","currentState","absolutePath","pathDescription","parentJson","updatedParentContent","updatedParentState","_refEditor2","newMode","newError","_ref91","nestedModalState","_refEditor3","sortModalStates","_ctx$13","_ctx$14","colgroup","_ctx$15","_ctx$16","directions","selectedProperty","_sortModalStates$stat","selectedDirection","_sortModalStates$stat2","sortError","_selectedProperty","_properties","_selectedDirection","refJSONEditorRoot","sortModalProps","transformModalProps","alert","instanceId","jsonEditorModalProps","previousParser","_set","contentError","_update","_patch","_select","_expand","_collapse2","_acceptAutoRepair","_scrollTo2","_focus","_refresh3","_updateProps","_destroy","_toggleMode","_ref93","status","_x39","_ref94","_x30","_x31","_x32","_x33","_x34","_x35","_x36","_x37","_x38","_sortModalProps","_transformModalProps","_jsonEditorModalProps","option_1","option_1_value_value","select_class_value","handleMouseDown","refSelect","bindValue","applyFocus","selected_option","getJSONSchemaOptions","schema","schemaDefinitions","schemaForPath","findSchema","composite","enum","findEnum","topLevelSchema","currentSchema","possibleSchemas","subSchemas","oneOf","anyOf","allOf","$ref","_ref$match","schemaUrl","referencedSchema","auxNextPath","refPath","segment","patternProperties","additionalProperties","renderJSONSchemaEnum","enumValues","enumValue","optionsWithValue","EnumValue","createAjvValidator","ajv","ajvOptions","AjvDist","allErrors","verbose","$data","addSchema","createAjvInstance","onCreateAjv","opts","validateAjv","compile","improveAjvError","ajvError","instancePath","normalizeAjvError","enums","more","params","additionalProperty","jmespathQueryLanguage","examplePath","exampleValue","filterValueStr","stringifyPathForJmespath","stringifyProp","preprocessedJson","stringifyAndParse","jmespath","jsonpathQueryLanguage","expression","pathToString","JSONPathPlus","lettersOnlyRegex","lodashQueryLanguage","queryParts","actualValueGetter","isSafeInteger","createLodashPropertySelector","_query$match","_query$match2","chainCount","valueCount","Function","queryFn","javascriptQueryLanguage","createJSONEditor","_ref96","JSONEditorComponent","JSONEditor","_ref97"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,10,11,25,26,27,50,51,52,53,54,55,56,57,58,59,60]}